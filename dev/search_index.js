var documenterSearchIndex = {"docs":
[{"location":"examples/spinw/SW13_LiNiPO4.html","page":"SW13 - LiNiPOâ‚„","title":"SW13 - LiNiPOâ‚„","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW13_LiNiPO4.html#SW13-LiNiPO","page":"SW13 - LiNiPOâ‚„","title":"SW13 - LiNiPOâ‚„","text":"This is a Sunny port of SpinW Tutorial 13, originally authored by Sandor Toth. It calculates the spin wave spectrum of LiNiPOâ‚„.\n\nLoad packages\n\nusing Sunny, GLMakie\n\nBuild an orthorhombic lattice and populate the Ni atoms according to Wyckoff 4c of spacegroup 62.\n\nunits = Units(:meV, :angstrom)\na = 10.02\nb = 5.86\nc = 4.68\nlatvecs = lattice_vectors(a, b, c, 90, 90, 90)\npositions = [[1/4, 1/4, 0]]\ntypes = [\"Ni\"]\ncryst = Crystal(latvecs, positions, 62; types)\nview_crystal(cryst)\n\nCreate a system with exchange parameters taken from T. Jensen, et al., Phys. Rev. B 79, 092413 (2009). The corrected anisotropy values are taken from the thesis of T. Jensen. The mode :dipole_uncorrected avoids a classical-to-quantum rescaling factor of anisotropy strengths, as needed for consistency with the original fits.\n\nsys = System(cryst, [1 => Moment(s=1, g=2)], :dipole_uncorrected)\nJbc =  1.036\nJb  =  0.6701\nJc  = -0.0469\nJac = -0.1121\nJab =  0.2977\nDa  =  0.1969\nDb  =  0.9097\nset_exchange!(sys, Jbc, Bond(2, 3, [0, 0, 0]))\nset_exchange!(sys, Jc, Bond(1, 1, [0, 0, -1]))\nset_exchange!(sys, Jb, Bond(1, 1, [0, 1, 0]))\nset_exchange!(sys, Jab, Bond(1, 2, [0, 0, 0]))\nset_exchange!(sys, Jab, Bond(3, 4, [0, 0, 0]))\nset_exchange!(sys, Jac, Bond(3, 1, [0, 0, 0]))\nset_exchange!(sys, Jac, Bond(4, 2, [0, 0, 0]))\nset_onsite_coupling!(sys, S -> Da*S[1]^2 + Db*S[2]^2, 1)\n\nEnergy minimization yields a co-linear order along the c axis.\n\nrandomize_spins!(sys)\nminimize_energy!(sys)\nplot_spins(sys; color=[S[3] for S in sys.dipoles])\n\nCalculate the spectrum along path [Î¾, 1, 0]\n\nswt = SpinWaveTheory(sys; measure=ssf_perp(sys))\nqs = [[0, 1, 0], [2, 1, 0]]\npath = q_space_path(cryst, qs, 400)\nres = intensities_bands(swt, path)\nfig = Figure(size=(768, 300))\nplot_intensities!(fig[1, 1], res; units);\nnothing #hide\n\nThere are two physical bands with nonvanishing intensity. To extract these intensity curves, we must filter out the additional bands with zero intensity. One way is to sort the data along dimension 1 (the band index) with the comparison operator \"is intensity less than 10^-12\". Doing so moves the physical bands to the end of the array axis. Call the Makie lines! function to make a custom plot.\n\ndata_sorted = sort(res.data; dims=1, by= >(1e-12))\nax = Axis(fig[1, 2], xlabel=\"Momentum (r.l.u.)\", ylabel=\"Intensity\",\n          xticks=res.qpts.xticks, xticklabelrotation=Ï€/6)\nlines!(ax, data_sorted[end, :]; label=\"Lower band\")\nlines!(ax, data_sorted[end-1, :]; label=\"Upper band\")\naxislegend(ax)\nfig\n\nMake the same plots along path [0, 1, Î¾]\n\nqs =  [[0, 1, 0], [0, 1, 2]]\npath = q_space_path(cryst, qs, 400)\nres = intensities_bands(swt, path)\nfig = Figure(size=(768, 300))\nplot_intensities!(fig[1, 1], res; units)\n\ndata_sorted = sort(res.data; dims=1, by=x->abs(x)>1e-12)\nax = Axis(fig[1, 2], xlabel=\"Momentum (r.l.u.)\", ylabel=\"Intensity\",\n          xticks=res.qpts.xticks, xticklabelrotation=Ï€/6)\nlines!(ax, data_sorted[end, :]; label=\"Lower band\")\nlines!(ax, data_sorted[end-1, :]; label=\"Upper band\")\naxislegend(ax)\nfig","category":"section"},{"location":"examples/03_LSWT_SU3_FeI2.html","page":"3. Multi-flavor spin wave simulations of FeIâ‚‚","title":"3. Multi-flavor spin wave simulations of FeIâ‚‚","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/03_LSWT_SU3_FeI2.html#3.-Multi-flavor-spin-wave-simulations-of-FeI","page":"3. Multi-flavor spin wave simulations of FeIâ‚‚","title":"3. Multi-flavor spin wave simulations of FeIâ‚‚","text":"This tutorial illustrates various advanced features such as symmetry analysis, energy minimization, and spin wave theory with multi-flavor bosons.\n\nOur context will be FeIâ‚‚, an effective spin-1 material with strong single-ion anisotropy. Quadrupolar fluctuations give rise to a single-ion bound state that is observable in neutron scattering, and cannot be described by a dipole-only model. We will use the linear spin wave theory of SU(3) coherent states (i.e. 2-flavor bosons) to model the magnetic spectrum of FeIâ‚‚. The original study was performed in Bai et al., Nature Physics 17, 467â€“472 (2021).\n\n<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/FeI2_crystal.jpg\" style=\"float: left;\" width=\"400\">\n\nThe Fe atoms are arranged in stacked triangular layers. The effective spin Hamiltonian takes the form,\n\nmathcalH=sum_(ij) ğ’_i  J_ij ğ’_j - Dsum_i left(S_i^zright)^2\n\nwhere the exchange matrices J_ij between bonded sites (ij) include competing ferromagnetic and antiferromagnetic interactions. This model also includes a strong easy axis anisotropy, D  0.\n\nLoad packages.\n\nusing Sunny, GLMakie\n\nConstruct the chemical cell of FeIâ‚‚ by specifying the lattice vectors and the full set of atoms.\n\nunits = Units(:meV, :angstrom)\na = b = 4.05012  # Lattice constants for triangular lattice (â„«)\nc = 6.75214      # Spacing between layers (â„«)\nlatvecs = lattice_vectors(a, b, c, 90, 90, 120)\npositions = [[0, 0, 0], [1/3, 2/3, 1/4], [2/3, 1/3, 3/4]]\ntypes = [\"Fe\", \"I\", \"I\"]\ncryst = Crystal(latvecs, positions; types)\n\nObserve that the space group 'P -3 m 1' (164) has been inferred, as well as point group symmetries. Only the Fe atoms are magnetic, so we focus on them with subcrystal. Importantly, the new crystal retains the symmetry information for spacegroup 164.\n\ncryst = subcrystal(cryst, \"Fe\")\nview_crystal(cryst)","category":"section"},{"location":"examples/03_LSWT_SU3_FeI2.html#Symmetry-analysis","page":"3. Multi-flavor spin wave simulations of FeIâ‚‚","title":"Symmetry analysis","text":"The command print_symmetry_table provides a list of all the symmetry-allowed interactions out to 8 â„«.\n\nprint_symmetry_table(cryst, 8.0)\n\nThe allowed g-tensor is expressed as a 3Ã—3 matrix in the free coefficients A, B, ... The allowed single-ion anisotropy is expressed as a linear combination of Stevens operators. The latter correspond to polynomials of the spin operators, as we will describe below.\n\nThe allowed exchange interactions are given as 3Ã—3 matrices for representative bonds. The notation Bond(i, j, n) indicates a bond between atom indices i and j, with cell offset n. Note that the order of the pair (i j) is significant if the exchange tensor contains antisymmetric Dzyaloshinskiiâ€“Moriya (DM) interactions.\n\nThe bonds can be visualized in the view_crystal interface. By default, Bond(1, 1, [1,0,0]) is toggled on, to show the 6 nearest-neighbor Fe-Fe bonds on a triangular lattice layer. Toggling Bond(1, 1, [0,0,1]) shows the Fe-Fe bond between layers, etc.","category":"section"},{"location":"examples/03_LSWT_SU3_FeI2.html#Defining-the-spin-model","page":"3. Multi-flavor spin wave simulations of FeIâ‚‚","title":"Defining the spin model","text":"Construct a System with spin s=1 and g=2 for the Fe ions.\n\nRecall that quantum spin-1 is, in reality, a linear combination of basis states m with well-defined angular momentum m = -1 0 1. FeIâ‚‚ has a strong easy-axis anisotropy, which stabilizes a single-ion bound state of zero angular momentum, m=0. Such a bound state is inaccessible to traditional spin wave theory, which works with dipole expectation values of fixed magnitude. This physics is, however, well captured with a theory of SU(N) coherent states, where N = 2S+1 = 3 is the number of levels. Activate this generalized theory by selecting :SUN mode instead of :dipole mode.\n\nAn optional seed for random number generation can be used to to make the calculation exactly reproducible.\n\nsys = System(cryst, [1 => Moment(s=1, g=2)], :SUN; seed=2)\n\nSet the exchange interactions for FeIâ‚‚ following the fits of Bai et al.\n\nJ1pm   = -0.236 # (meV)\nJ1pmpm = -0.161\nJ1zpm  = -0.261\nJ2pm   = 0.026\nJ3pm   = 0.166\nJâ€²0pm  = 0.037\nJâ€²1pm  = 0.013\nJâ€²2apm = 0.068\n\nJ1zz   = -0.236\nJ2zz   = 0.113\nJ3zz   = 0.211\nJâ€²0zz  = -0.036\nJâ€²1zz  = 0.051\nJâ€²2azz = 0.073\n\nJ1xx = J1pm + J1pmpm\nJ1yy = J1pm - J1pmpm\nJ1yz = J1zpm\n\nset_exchange!(sys, [J1xx   0.0    0.0;\n                    0.0    J1yy   J1yz;\n                    0.0    J1yz   J1zz], Bond(1,1,[1,0,0]))\nset_exchange!(sys, [J2pm   0.0    0.0;\n                    0.0    J2pm   0.0;\n                    0.0    0.0    J2zz], Bond(1,1,[1,2,0]))\nset_exchange!(sys, [J3pm   0.0    0.0;\n                    0.0    J3pm   0.0;\n                    0.0    0.0    J3zz], Bond(1,1,[2,0,0]))\nset_exchange!(sys, [Jâ€²0pm  0.0    0.0;\n                    0.0    Jâ€²0pm  0.0;\n                    0.0    0.0    Jâ€²0zz], Bond(1,1,[0,0,1]))\nset_exchange!(sys, [Jâ€²1pm  0.0    0.0;\n                    0.0    Jâ€²1pm  0.0;\n                    0.0    0.0    Jâ€²1zz], Bond(1,1,[1,0,1]))\nset_exchange!(sys, [Jâ€²2apm 0.0    0.0;\n                    0.0    Jâ€²2apm 0.0;\n                    0.0    0.0    Jâ€²2azz], Bond(1,1,[1,2,1]))\n\nThe function set_onsite_coupling! assigns a single-ion anisotropy. The argument can be constructed using spin_matrices or stevens_matrices. Here we use Julia's anonymous function syntax to assign an easy-axis anisotropy along the direction hatz.\n\nD = 2.165 # (meV)\nset_onsite_coupling!(sys, S -> -D*S[3]^2, 1)","category":"section"},{"location":"examples/03_LSWT_SU3_FeI2.html#Finding-the-ground-state","page":"3. Multi-flavor spin wave simulations of FeIâ‚‚","title":"Finding the ground state","text":"This model has been fitted so that energy minimization yields the physically correct ground state. Knowing this, we could set the magnetic configuration manually by calling set_dipole! on each site in the system. Another approach, as we will demonstrate, is to search for the ground-state via minimize_energy!.\n\nTo reduce bias in the search, use resize_supercell to create a relatively large system of 4Ã—4Ã—4 chemical cells. Randomize all spins (represented as SU(3) coherent states) and minimize the energy.\n\nsys = resize_supercell(sys, (4, 4, 4))\nrandomize_spins!(sys)\nminimize_energy!(sys)\n\nDespite successful convergence to a local energy minimum, defects in the spin configuration are visually apparent.\n\nplot_spins(sys; color=[S[3] for S in sys.dipoles])\n\nOne could precisely quantify the Fourier-space static structure factor mathcalS(ğª) of this spin configuration using SampledCorrelationsStatic. For the present purposes, however, it is most convenient to use print_wrapped_intensities, which effectively averages mathcalS(ğª) over all Brillouin zones.\n\nprint_wrapped_intensities(sys)\n\nThe known zero-field energy-minimizing magnetic structure of FeIâ‚‚ is a two-up, two-down order. It can be described as a generalized spiral with a single propagation wavevector ğ¤. Rotational symmetry allows for three equivalent orientations: ğ¤ = 0 -14 14, 14 0 14, or -141414. Energy minimization of large systems can easily get trapped in a metastable state with competing domains and defects. Nonetheless, print_wrapped_intensities shows that a non-trivial fraction of the total intensity is consistent with known ordering wavevectors.\n\nLet's break the three-fold symmetry by hand. The function suggest_magnetic_supercell takes any number of ğ¤ modes and suggests a magnetic cell shape that is commensurate with all of them.\n\nsuggest_magnetic_supercell([[0, -1/4, 1/4]])\n\nUsing the minimal system returned by reshape_supercell, it is now easy to find the ground state. Plot the system again, now including \"ghost\" spins out to 12â„«, to verify that the magnetic order is consistent with FeIâ‚‚.\n\nsys_min = reshape_supercell(sys, [1 0 0; 0 2 1; 0 -2 1])\nrandomize_spins!(sys_min)\nminimize_energy!(sys_min);\nplot_spins(sys_min; color=[S[3] for S in sys_min.dipoles], ghost_radius=12)","category":"section"},{"location":"examples/03_LSWT_SU3_FeI2.html#Spin-wave-theory","page":"3. Multi-flavor spin wave simulations of FeIâ‚‚","title":"Spin wave theory","text":"Now that the system has been relaxed to an energy minimized ground state, we can calculate the spin wave spectrum. Because we are working with a system of SU(3) coherent states, this calculation will require a multi-flavor boson generalization of the usual spin wave theory.\n\nswt = SpinWaveTheory(sys_min; measure=ssf_perp(sys_min))\n\nCalculate and plot the spectrum along a momentum-space path that connects a sequence of high-symmetry ğª-points. This interface abstracts over the underlying calculator type.\n\nqs = [[0,0,0], [1,0,0], [0,1,0], [1/2,0,0], [0,1,0], [0,0,0]]\npath = q_space_path(cryst, qs, 500)\nres = intensities_bands(swt, path)\nplot_intensities(res; units, ylims=(0, 10), title=\"Single Crystal Bands\")\n\nTo make direct comparison with inelastic neutron scattering (INS) data, we must account for empirical broadening of the data. Model this using a lorentzian kernel, with a full-width at half-maximum of 0.3 meV.\n\nkernel = lorentzian(fwhm=0.3)\nenergies = range(0, 10, 300);  # 0 < Ï‰ < 10 (meV)\nnothing #hide\n\nAlso, a real FeIâ‚‚ sample will exhibit competing magnetic domains. We use domain_average to average over the three possible domain orientations. This involves 120Â° rotations about the axis hatz = 0 0 1 in global Cartesian coordinates.\n\nrotations = [([0,0,1], n*(2Ï€/3)) for n in 0:2]\nweights = [1, 1, 1]\nres = domain_average(cryst, path; rotations, weights) do path_rotated\n    intensities(swt, path_rotated; energies, kernel)\nend\nplot_intensities(res; units, colormap=:viridis, title=\"Domain Averaged Intensities\")\n\nThis result can be directly compared to experimental neutron scattering data from Bai et al.\n\n<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/FeI2_intensity.jpg\">\n\n(The publication figure used a non-standard coordinate system to label the wave vectors.)\n\nTo get this agreement, the theory of SU(3) coherent states is essential. The lower band has large quadrupolar character and arises from the strong easy-axis anisotropy of FeIâ‚‚.\n\nAn interesting exercise is to repeat the same study, but using :dipole mode instead of :SUN. That alternative choice would constrain the coherent state dynamics to the space of dipoles only, and the flat band of single-ion bound states would be missing.","category":"section"},{"location":"parallelism.html#Parallelizing-Calculations","page":"Parallelizing Calculations","title":"Parallelizing Calculations","text":"Calculating structure factors with classical dynamics is computationally expensive, and Sunny does not currently parallelize these calculations at a fine-grained level. However, Julia provides facilities that allow users to run multiple simulations in parallel with only a little extra effort. We will look at two approaches to doing this: multithreading and Julia's Distributed package. We'll present these approaches in a series of code snippets that can be copied and pasted into your preferred Julia development environment.","category":"section"},{"location":"parallelism.html#Review-of-the-serial-workflow","page":"Parallelizing Calculations","title":"Review of the serial workflow","text":"The serial approach to calculating a structure factor, covered in the FeIâ‚‚ tutorial, involves thermalizing a spin System and then calling add_sample!. add_sample! uses the state of the System as an initial condition for the calculation of a dynamical trajectory. The correlations of the trajectory are calculated and accumulated into a running average of the mathcalS(ğªÏ‰). This sequence is repeated to generate additional samples.\n\nTo illustrate, we'll set up a a simple model: a spin-1 antiferromagnet on a BCC crystal. Constructing the System with a specific random number seed ensures full reproducibility of the simulation.\n\nusing Sunny, GLMakie\n\nfunction make_system(seed)\n    latvecs = lattice_vectors(1, 1, 1, 90, 90, 90)\n    positions = [[0, 0, 0]/2, [1, 1, 1]/2]\n    cryst = Crystal(latvecs, positions)\n    sys = System(cryst, [1 => Moment(s=1, g=2)], :dipole; dims=(10, 10, 2), seed)\n    set_exchange!(sys, 1.0, Bond(1, 1, [1, 0, 0]))\n    return sys\nend\n\nsys = make_system(0)\n\nA serial calculation of SampledCorrelations involving the Langevin sampling method can now be performed as follows:\n\n# Thermalize the system\ndt = 0.05\nintegrator = Langevin(dt; damping=0.2, kT=0.5)\nfor _ in 1:5000\n    step!(sys, integrator)\nend\n\n# Accumulator for S(q,Ï‰) samples\n\nenergies = range(0.0, 10.0, 100)\nmeasure = ssf_perp(sys)\nsc = SampledCorrelations(sys; dt=0.1, energies, measure)\n\n# Collect 10 samples\nfor _ in 1:10\n    for _ in 1:1000\n        step!(sys, integrator)\n    end\n    add_sample!(sc, sys)\nend\n\nThis will take a second or two on a modern workstation, resulting in a single SampledCorrelations that contains 10 samples.","category":"section"},{"location":"parallelism.html#Multithreading-approach","page":"Parallelizing Calculations","title":"Multithreading approach","text":"To use threads in Julia, you must launch your Julia environment appropriately.\n\nFrom the command line, launch Julia with julia --threads=auto. With this option, Julia will automatically use an optimal number of threads.\nJupyter notebook users will need to to set up a multithreaded Julia kernel and restart into this kernel. The kernel can be created inside Julia with the command IJulia.installkernel(\"Julia Multithreaded\", env=Dict(\"JULIA_NUM_THREADS\" => \"auto\")).\nVSCode users should open their settings and search for Julia: Additional Args. There will be link called Edit in settings.json. Click on this, add \"--threads=auto\" to the list julia.additionalArgs, and start a new REPL.\n\nBefore going further, make sure that Threads.nthreads() returns a number greater than 1.\n\nWe will use multithreading in a very simple way, essentially employing a distributed memory approach to avoid conflicts around memory access. First preallocate a number of systems and correlations. The integer id of each system is used as its random number seed.\n\nnpar = Threads.nthreads()\nsystems = [make_system(id) for id in 1:npar]\nscs = [SampledCorrelations(sys; dt=0.1, energies, measure) for _ in 1:npar]\n\nwarning: Dealing with memory constraints\nIf many threads are available and the system sizes are large, there may not be enough computer memory available to store the dynamical correlation data. In this case, consider reducing the number of parallel threads, npar.\n\nWhen the Threads.@threads macro is applied before a for loop, the iterations of the loop will execute in parallel using the available threads. We will put the entire thermalization and sampling process inside the loop, with each thread acting on a unique System and SampledCorrelations.\n\nThreads.@threads for id in 1:npar\n    integrator = Langevin(dt; damping=0.2, kT=0.5)\n    for _ in 1:5000\n        step!(systems[id], integrator)\n    end\n    for _ in 1:10\n        for _ in 1:1000\n            step!(systems[id], integrator)\n        end\n        add_sample!(scs[id], systems[id])\n    end\nend\n\nYou may find this takes a little bit longer than the serial example, but, at the end of it, you will have generated npar correlation objects, each with 10 samples. We can merge these into a summary SampledCorrelations with 10*npar samples with merge_correlations:\n\nsc = merge_correlations(scs)","category":"section"},{"location":"parallelism.html#Using-Distributed","page":"Parallelizing Calculations","title":"Using Distributed","text":"Julia also provides a distributed memory approach to parallelism through the standard library package Distributed. This works by launching independent Julia environments on different \"processes.\" An advantage of this approach is that it scales naturally to clusters since the processes are easily distributed across many different compute nodes. A disadvantage, especially when working on a single computer, is the increased memory overhead associated with launching all these environments.\n\nWe begin by importing the package,\n\nusing Distributed\n\nand launching some new processes. It is often sensible to create as many processes as there are cores.\n\nncores = length(Sys.cpu_info())\naddprocs(ncores)\n\nYou can think of each process as a separate computer running a fresh Julia environment, so we'll need to import Sunny and define functions in each of these environments. This is easily achieved with the @everywhere macro.\n\n@everywhere using Sunny\n\n@everywhere function make_system(seed)\n    latvecs = lattice_vectors(1, 1, 1, 90, 90, 90)\n    positions = [[0, 0, 0]/2, [1, 1, 1]/2]\n    cryst = Crystal(latvecs, positions)\n    sys = System(cryst, [1 => Moment(s=1, g=2)], :dipole; seed)\n    sys = resize_supercell(sys, (10, 10, 2))\n    set_exchange!(sys, 1.0, Bond(1, 1, [1, 0, 0]))\n    return sys\nend\n\nA simple way to perform work on these processes is to use the parallel map function, pmap. This will apply a function to each element of some iterable, such as a list of numbers, and return a list of the results. It is a parallel map because these function calls may occur at the same time on different Julia processes. The pmap function takes care of distributing the work among the different processes and retrieving the results.\n\nIn the example below, we give pmap a list of RNG seeds to iterate over, and we define the function that will be applied to each of these seeds in a do block. The contents of this block are essentially the same as what we put inside our parallel for loop in the multithreading example. The main difference is that the Systems and SampledCorrelations are not created in advance of the parallelization but are instead created inside each Julia process. The do block returns a SampledCorrelations, and the output of all the parallel computations are collected into list of SampledCorrelations called scs.\n\nscs = pmap(1:ncores) do id\n    sys = make_system(id)\n    sc = SampledCorrelations(sys; dt=0.1, energies, measure)\n    integrator = Langevin(0.05; damping=0.2, kT=0.5)\n\n    for _ in 1:5000\n        step!(sys, integrator)\n    end\n    for _ in 1:10\n        for _ in 1:1000 \n            step!(sys, integrator)\n        end\n        add_sample!(sc, sys)\n    end\n\n    return sc\nend\n\nFinally, merge the results into a summary SampledCorrelations.\n\nsc = merge_correlations(scs)","category":"section"},{"location":"structure-factor.html#Structure-Factor-Conventions","page":"Structure Factor Conventions","title":"Structure Factor Conventions","text":"","category":"section"},{"location":"structure-factor.html#Dynamical-correlations","page":"Structure Factor Conventions","title":"Dynamical correlations","text":"Dynamical correlations are a fundamental observable in condensed matter systems, and facilitate comparison between theory and experimental data.\n\nFrequently, spin-spin correlations are of interest. More generally, one may consider correlations between arbitrary operator fields hatA and hatB. In the Heisenberg picture, operators evolve in time. Consider the dynamical correlation as an equilibrium expectation value,\n\nbeginequation\nC(ğ« t) = int_V hatB^(ğ«â‚€ 0) hatA(ğ«â‚€ + ğ« t) dğ«â‚€\nendequation\n\nwhere the integral runs over some macroscopic volume V  . By construction, C(ğ« t) is an extensive quantity. Ignoring surface effects, the correlation becomes an ordinary product in momentum-space,\n\nbeginequation\nC(ğª t) = hatB_ğª^(0) hatA_ğª(t)\nendequation\n\nOur convention for the Fourier transform from position ğ« to momentum ğª is,\n\nbeginequation\nhatA_ğª  int_V e^+ i ğªğ« hatA(ğ«) dğ«\nendequation\n\nFor a Hermitian operator hatA^(ğ«) = hatA(ğ«), it follows that hatA_ğª^  (hatA_ğª)^ = hatA_-ğª in momentum space. ","category":"section"},{"location":"structure-factor.html#Lehmann-representation-in-frequency-space","page":"Structure Factor Conventions","title":"Lehmann representation in frequency space","text":"Dynamical correlations are most conveniently calculated in frequency space. We use the convention,\n\nbeginequation\nC(ğª Ï‰)  frac12Ï€ int_-^ e^-iÏ‰t C(ğª t) dt\nendequation\n\nOn the right-hand side, substitute the definition of Heisenberg time evolution,\n\nbeginequation\nhatA(t)  e^i t hatH hatA e^-i t hatH\nendequation\n\nand the definition of the thermal average,\n\nbeginequation\nhatO  frac1mathcalZmathrmtr e^-Î² hatH hatO quad mathcalZ  mathrmtr e^-Î² hatH\nendequation\n\nLet Ïµ_Î¼ and Î¼ denote the exact eigenvalues and eigenstates of the full Hamiltonian hatH. The eigenstates comprise a complete, orthonormal basis. The operator trace can be evaluated as a sum over eigenbasis states Î½. Insert a resolution of the identity, Î¼Î¼ = 1, with implicit summation on the repeated Î¼ index. Then, collecting results and applying,\n\nbeginequation\nint_-^ e^-iÏ‰t dt = 2Ï€Î´(Ï‰)\nendequation\n\nthe result is the Lehmann representation of dynamical correlations,\n\nbeginequation\nC(ğªÏ‰) = frac1mathcalZ e^-Î² Ïµ_Î½ Î´(Ïµ_Î¼ - Ïµ_Î½ - Ï‰) Î½hatB^_ğªÎ¼Î¼hatA_ğª Î½\nendequation\n\nwith implicit summation over eigenbasis indices Î¼ and Î½. This representation is the usual starting point for quantum calculations such as linear spin wave theory and its various generalizations.\n\nUsing the Lehmann representation, it can be shown that positive and negative frequencies are linked through a detailed balance condition,\n\nbeginequation\nC_BA^(ğª-Ï‰) = e^-Î² Ï‰  C_B^A(ğª Ï‰)^*\nendequation\n\nThis subscript notation indicates that the left-hand side is a correlation of Hermitian-conjugated operators. Typically hatA and hatB will be Hermitian in real-space, and then detailed balance becomes C(-ğª-Ï‰) = e^-Î² Ï‰ C(ğª Ï‰)^*.","category":"section"},{"location":"structure-factor.html#Discrete-sums-on-the-lattice","page":"Structure Factor Conventions","title":"Discrete sums on the lattice","text":"A chemical (crystallographic) unit cell is associated with three lattice vectors ğš_123. Site positions are\n\nbeginequation\nğ«_ğ¦j  m_1 ğš_1 + m_2 ğš_2 + m_3 ğš_3 + Î´ğ«_j\nendequation\n\nfor integers ğ¦ = m_1 m_2 m_3. If the crystal is decorated, then Î´ğ«_j denotes the relative displacement of the Bravais sublattice j. \n\nLet hatA(ğ«) be decomposed into discrete contributions hatA_ğ¦j Î´(ğ«-ğ«_ğ¦j) at each lattice point ğ«_ğ¦j. The Fourier transform becomes a discrete sum,\n\nbeginequation\nhatA_ğª = sum_j sum_ğ¦ e^i ğªğ«_ğ¦j hatA_ğ¦j  sum_j hatA_ğªj\nendequation\n\nThe second equality above introduces hatA_ğªj as the Fourier transform of hatA_ğ¦j for single sublattice j. It can also be written,\n\nbeginequation\nhatA_ğªj = e^i ğªÎ´ğ«_j sum_ğ¦ e^i 2Ï€ tildeğªğ¦ hatA_ğ¦j\nendequation\n\nwhere tildeğª expresses momentum in dimensionless reciprocal lattice units (RLU),\n\nbeginequation\nğª = tildeq_1 ğ›_1 + tildeq_2 ğ›_2 + tildeq_3 ğ›_3\nendequation\n\nand ğ›_123 are the reciprocal lattice vectors. Equivalently, tildeq_Î¼  ğª  ğš_Î¼  2Ï€.\n\nIt will be convenient to introduce a dynamical correlation for the operators on sublattices i and j only,\n\nbeginequation\nC_ij(ğªt)  hatB^_ğªi(0) hatA_ğªj(t)\nendequation\n\nBy the linearity of expectation values,\n\nbeginequation\nC(ğª t) = sum_ij C_ij(ğªt)\nendequation","category":"section"},{"location":"structure-factor.html#Quantum-sum-rule","page":"Structure Factor Conventions","title":"Quantum sum rule","text":"Integrating over all frequencies Ï‰ yields the instant correlation at real-time t = 0,\n\nbeginequation\nint_-^ C(ğªÏ‰) dÏ‰ = C(ğª t=0) = sum_ij C_ij(ğª t=0)\nendequation\n\nHere, we will investigate spin-spin correlations. For this, select hatB_ğªi = hatğ’_ğªi and A_ğªj = hatğ’_ğªj, such that the dynamical correlations become tensor valued,\n\nbeginequation\nC_ij^Î±Î²(ğª t=0) = hatS_ğªi^Î± hatS_ğªj^Î²\nendequation\n\nIn the quantum spin-s representation, the spin dipole on one site satisfies\n\nbeginequation\nhatğ’^2 = hatS^Î± hatS^Î± = s(s+1)\nendequation\n\nwith implicit summation on the repeated Î± index.\n\nSuppose that each site of sublattice j carries quantum spin of magnitude s_j. Then there is a quantum sum rule of the form,\n\nbeginequation\nint_tildeV_mathrmBZ fracC_jj^Î±Î±(ğª t=0)N_mathrmcells dtildeğª = s_j (s_j + 1)\nendequation\n\nwith summation on Î±, but not j, implied. The integral runs over the cubic volume in reciprocal lattice units tildeğª,\n\nbeginequation\ntildeV_mathrmBZ  01^3\nendequation\n\nThis volume represents one unit cell on the reciprocal lattice, and has the shape of a parallelepiped in physical momentum units ğª. This volume is equivalent to the first Brillouin zone because of the reciprocal-space periodicity inherent to the Bravais sublattice. Note that the integral over tildeğª  tildeV_mathrmBZ could be converted to an integral over physical momentum ğª by applying a Jacobian transformation factor, d tildeğª = dğª V_mathrmcell  (2Ï€)^3, where V_mathrmcell = ğš_1  (ğš_2  ğš_3) is the volume of the chemical unit cell. The scaling factor\n\nbeginequation\nN_mathrmcells  V  V_mathrmcell\nendequation\n\ndenotes the number of chemical unit cells in the macroscopic volume V.\n\nThe derivation of the sum rule proceeds as follows. Substitute twice the definition,\n\nbeginequation\nhatS^Î±_ğªj  e^i ğªÎ´ğ«_j sum_ğ¦ e^i 2Ï€ tildeğªğ¦ hatS^Î±_ğ¦j\nendequation\n\nAccounting for complex conjugation, the two phase factors e^i ğªÎ´ğ«_j cancel. The remaining ğª-dependence can be integrated to yield a Kronecker-Î´,\n\nbeginequation\nint_tildeV_mathrmBZ e^2Ï€i tildeğª  (ğ¦ - ğ¦)  dtildeğª = Î´_ğ¦ ğ¦\nendequation\n\nNote that hatS_ğ¦j^Î± hatS_ğ¦j^Î± = s_j(s_j+1) is constant, independent of the cell ğ¦. This leaves a double sum over integers ğ¦, which evaluates to sum_ğ¦ ğ¦ Î´_ğ¦ ğ¦ = N_mathrmcells. Combined, these results verify the above-stated quantum sum rule for the sublattice j.\n\nOne can also derive a quantum sum rule on the full dynamical correlation C^Î± Î²(ğª Ï‰). Contributions from distinct sublattices i  j introduce a phase factor e^- i ğª(Î´ğ«_i - Î´ğ«_j) that cancels when the momentum ğª is averaged over a large number N_mathrmBZ   of Brillouin zones. The final result is a sum over contributions C_jj(ğª t=0) for each sublattice j,\n\nbeginequation\nfrac1N_mathrmBZ int_N_mathrmBZ  tildeV_mathrmBZ int_-^ fracC^Î±Î±(ğª Ï‰) N_mathrmcells dÏ‰ dtildeğª = sum_j s_j (s_j + 1)\nendequation","category":"section"},{"location":"structure-factor.html#Neutron-scattering-cross-section","page":"Structure Factor Conventions","title":"Neutron scattering cross section","text":"The magnetic moment of a neutron is hatboldsymbolÎ¼_mathrmneutron = - 2 Î³ Î¼_N hatğ’_mathrmneutron, where Î³ = 1913, Î¼_N is the nuclear magneton, and hatğ’_mathrmneutron is spin-1/2 angular momentum. Neutrons interact with the magnetic moments of a material. These have the form hatboldsymbolÎ¼ = -Î¼_B g hatğ’, where Î¼_B is the Bohr magneton and hatğ’ is the effective angular momentum. For a single electron, g = 20023 is known to high precision. Within a crystal, however, the appropriate g_j for each sublattice j may be any 33 matrix consistent with point group symmetries.\n\nEach idealized magnetic moment hatboldsymbolÎ¼_ğ¦j is, in reality, smoothly distributed around the site position ğ«_ğ¦ j. This can be modeled through convolution with a density function f_j(ğ«). Fourier transform the full magnetic density field ğŒ(ğ«) to obtain\n\nbeginequation\nhatğŒ_ğª  sum_j hatğŒ_ğªj\nendequation\n\nwhere,\n\nbeginequation\nhatğŒ_ğªj  - Î¼_B e^i ğªÎ´ğ«_j g_j sum_ğ¦ e^i 2Ï€ tildeğªğ¦ hatğ’_ğ¦j f_j(ğª)\nendequation\n\nIn Fourier space, f_j(ğª) is called the magnetic form factor. Frequently, it will be approximated as an isotropic function of q = ğª. Tabulated formula, for various magnetic ions and charge states, are available in Sunny via the FormFactor function. The idealized case f_j(ğª) = 1 would describe completely localized magnetic moments.\n\nNeutron scattering intensities are given by the total differential cross-section, d^2 Ïƒ(ğª Ï‰)dÏ‰dÎ©, where ğª = ğª_i - ğª_f is the momentum transfer to the sample, Ï‰ is the energy transfer to the sample, and Î© is the solid angle. Experimental intensity data will typically be provided in units of q_f  q_i. Within the dipole approximation, the result for an unpolarized neutron beam is,\n\nbeginequation\nfracd^2 Ïƒ(ğª Ï‰)dÏ‰ dÎ© = fracq_fq_i left(fracÎ³ r_02right)^2 sum_Î±Î² left(Î´_Î±Î² - fracq^Î± q^Î²q^2right) fracmathcalS^Î±Î²(ğª Ï‰)Î¼_B^2\nendequation\n\nThe prefactor q_fq_i will be provided experimentally. Dimensions of area arise from the characteristic scattering length, Î³ r_0  2  26910^-5 mathrmâ„«, where r_0 is the classical electron radius.\n\nThe structure factor is of central importance to neutron scattering,\n\nbeginequation\nmathcalS^Î±Î²(ğª Ï‰)  frac12Ï€ int_-^ e^-iÏ‰t hatM_ğª^Î±(0) hatM_ğª^Î²(t) dt\nendequation\n\nand describes dynamical correlations of magnetic moments. It will differ nontrivially from the spin-spin correlations if the g_j-tensor varies with sublattice j.","category":"section"},{"location":"structure-factor.html#Conventions-for-the-Sunny-calculated-structure-factor","page":"Structure Factor Conventions","title":"Conventions for the Sunny-calculated structure factor","text":"Calculating the structure factor involves several steps, with various possible settings. Sunny provides tools to facilitate this calculation and to extract information from the results. For details, please see our tutorials as well as the complete Library Reference.\n\nThrough ssf_custom and related functions, Sunny will calculate the spin structure factor as a 3Ã—3 matrix in dimensionless units,\n\nbeginequation\nğ’®^Î±Î²(ğª Ï‰)  frac1N_mathrmcells Î¼_B^2 mathcalS^Î±Î²(ğª Ï‰)\nendequation\n\nThis is an intensive quantity because N_mathrmcells, the number of chemical cells in the macroscopic sample, is extensive. Note that the Sunny-calculated intensity will depend on the chemical cell convention: intensity scales linearly with chemical cell size.\n\nUse ssf_perp to contract with Î´_Î±Î² - q^Î± q^Î²q^2, i.e., to project in the direction perpendicular to momentum transfer ğª.\n\nSet apply_g = false to calculate the correlation C_ğ’ğ’(ğª Ï‰)  N_mathrmcells between pure spin operators, rather than between magnetic moments. In this special case that g is a uniform scalar, this is equivalent to ğ’®(ğª Ï‰)  g^2","category":"section"},{"location":"structure-factor.html#Calculations-with-spin-wave-theory","page":"Structure Factor Conventions","title":"Calculations with spin wave theory","text":"Calculating the dynamical structure factor with linear SpinWaveTheory is relatively direct. In the traditional approach, quantum spin operators are expressed with Holstein-Primakoff bosons, and dynamical correlations are calculated to leading order in inverse powers of the quantum spin-s. For systems constructed with mode = :SUN, Sunny automatically switches to a multi-flavor boson variant of spin wave theory, which captures more single-ion physics. Use SpinWaveTheorySpiral to study generalized spiral phases, which allow for an incommensurate propagation wavevector. The module SpinWaveTheoryKPM uses iterated matrix-vector multiplication to achieve linear-scaling cost in the magnetic cell size. It can be useful for studying systems with large magnetic cells include systems with long-wavelength structures, or systems with quenched chemical disorder.","category":"section"},{"location":"structure-factor.html#Calculations-with-classical-spin-dynamics","page":"Structure Factor Conventions","title":"Calculations with classical spin dynamics","text":"Finite temperature structure factor intensities can be estimated from the dynamical correlations of classical spin dynamics (e.g. Landau-Lifshitz, or its SU(N) generalization). This is fundamentally a Monte Carlo approach, as the trajectories must be initialized to a spin configuration that is sampled from the finite-temperature thermal equilibrium. Samples are accumulated into a SampledCorrelations, from which intensity information may be extracted.\n\nCreating a SampledCorrelations requires specifying three keyword arguments. These will determine the dynamics used to calculate samples and, consequently, the Ï‰ information that will be available. \n\nenergies: A uniform range of resolved energies.\ndt: The step size for dynamical time-integration. Larger may reduce simulation time, but the choice will be limited by the stability and accuracy requirements of the ImplicitMidpoint integration method. The function suggest_timestep can recommend a good value. The timestep may be adjusted downward so that the specified energies are sampled exactly.\nmeasure: Specification of the pair correlations. This will frequently be reduced from the spin structure factor using one of ssf_trace, ssf_perp, or ssf_custom_bm.\n\nA sample may be added by calling add_sample!. The input sys must be a spin configuration in good thermal equilibrium, e.g., using the continuous Langevin dynamics or using single spin flip trials with LocalSampler. The statistical quality of the ğ’®(ğªÏ‰) can be improved by repeatedly generating decorrelated spin configurations in sys and calling add_sample! on each configuration.\n\nThe outline of typical use case might look like this:\n\n# Make a `SampledCorrelations`\nsc = SampledCorrelations(sys; dt=0.05, energies=range(0.0, 10.0, 100))\n\n# Add samples\nfor _ in 1:nsamples\n   decorrelate_system(sys) # Perform some type of Monte Carlo simulation\n   add_sample!(sc, sys)    # Use spins to calculate trajectory and accumulate new sample of ğ’®(ğª,Ï‰)\nend","category":"section"},{"location":"structure-factor.html#Extracting-intensities-sampled-correlation-data","page":"Structure Factor Conventions","title":"Extracting intensities sampled correlation data","text":"Like in spin wave theory, the basic function for extracting intensities information from a SampledCorrelations is intensities. It takes a SampledCorrelations, a collection of ğª-vectors, a collection of energies, and possible other options.\n\nSince classical dynamics simulation take place on a finite lattice, the fundamental intensities measurements are only available at a discrete grid of wave vectors. In reciprocal lattice units, available grid points are ğª = fracn_1L_1 fracn_2L_2 fracn_3L_3, where n_i runs from (frac-L_i2+1) to fracL_i2 and L_i is the linear dimension of the lattice used in the calculation. (An internal function Sunny.available_wave_vectors provides access to this grid.) By default intensities will adjust each wavevector ğª to the nearest available grid point. \n\nSimilarly, the resolution in energies is controlled the dynamical trajectory length in real-time. Because the dynamical trajectory is not periodic in time, some blurring between neighboring energy bins is unavoidable. Sunny's algorithm for estimating the structure factor from real-time dynamics is specified here.\n\nThe temperature parameter kT is required for SampledCorrelations calculations, and will be used to perform classical-to-quantum rescaling of intensities. If kT = nothing, then intensities will be provided according to the classical Boltzmann distribution.","category":"section"},{"location":"structure-factor.html#The-instantaneous-structure-factor","page":"Structure Factor Conventions","title":"The instantaneous structure factor","text":"Use intensities_static to calculate mathcalS(ğª), i.e.,  correlations that are \"instantaneous\" in real-time. Mathematically, mathcalS(ğª) denotes an integral of the dynamical structure factor mathcalS(ğª Ï‰) over all energies Ï‰. In SpinWaveTheory, the energy integral becomes a discrete sum over bands. In SampledCorrelations, a classical-to-quantum correction factor will be applied within intensities prior to energy integration.\n\nSunny also supports a mechanism to calculate static correlations without any spin dynamics. To collect such statistics, construct a SampledCorrelationsStatic object. In this case, intensities_static will return static correlations sampled from the classical Boltzmann distribution. This dynamics-free approach is faster, but may miss important features that derive from the quantum mechanical excitation spectrum.","category":"section"},{"location":"writevtk.html#ParaView-Rendering","page":"ParaView Rendering","title":"ParaView Rendering","text":"The 4D correlation data produced by Sunny is too high-dimensional to visualize directly. This page describes how to export 3D slices of correlation data from Sunny to the Visual ToolKit (VTK) format, which is compatible with the ParaView visualization software. ParaView supports volumetric rendering:\n\n<img src=\"./assets/paraviewrender.jpg\" style=\"margin: 30px; \" width=\"400\">","category":"section"},{"location":"writevtk.html#Simulation-data","page":"ParaView Rendering","title":"Simulation data","text":"First, generate some correlation data in Sunny. We will use a 2D lattice, since the correlation data S(Q_xQ_yomega) is 3D and can be exported in its entirety. The following code sets up the system, thermalizes it, and records the correlation data in a SampledCorrelations called dsf.\n\nusing Sunny\n\nlatvecs = lattice_vectors(8.,8.,12.,90,100,90)\npositions = [[0,0,0]]\ntypes = [\"Cu\"]\nformfactors = [FormFactor(\"Cu2\")]\nxtal = Crystal(latvecs, positions; types)\n\nsys = System(xtal, [1 => Moment(s=1/2, g=2)], :SUN; dims=(12, 12, 1), seed=1)\n\nJ = 10.\nset_exchange!(sys, J, Bond(1,1,[1,0,0]))\nset_exchange!(sys, J, Bond(1,1,[0,1,0]))\n\ndt = 0.01\nkT = 0.5\nlangevin = Langevin(dt; damping=0.5, kT)\nrandomize_spins!(sys)\nfor i in 1:10_000 # Long enough to reach equilibrium\n    step!(sys, langevin)\nend \n\nÏ‰max=10.\ndsf = SampledCorrelations(sys; dt, energies=range(0, Ï‰max, 48))\n\nnsamples = 10\nfor _ in 1:nsamples\n    for _ in 1:1000 \n        step!(sys, langevin)\n    end\n    add_sample!(dsf, sys)\nend\n\nThe default histogram BinningParameters are already integrated over the z direction because the system is 2D:\n\nunit_resolution_binning_parameters(dsf)\n\nâŠ¡    12 bins from -0.042 to +0.958 along [+1.27 dx] (Î” = 0.065)\nâŠ¡    12 bins from -0.042 to +0.958 along [+1.27 dy] (Î” = 0.065)\nâˆ« Integrated from +0.000 to +0.000 along [-0.33 dx +1.88 dz] (Î” = 0.524)\nâŠ¡    48 bins from -0.107 to +10.134 along [+1.00 dE] (Î” = 0.213)\n\nThe histogram is very oblong; it's approximately 1x1x10. To make it a nicer shape, we will rescale the energy axis to be be fractions of Ï‰max:\n\nparams = unit_resolution_binning_parameters(dsf)\nscale_factor = Ï‰max\nparams.binend[4] /= scale_factor\nparams.binstart[4] /= scale_factor\nparams.binwidth[4] /= scale_factor\nparams.covectors[4,:] ./= scale_factor\n\nDoing this changes the last axis of the histogram to fit in [0,1]:\n\nâŠ¡    49 bins from -0.011 to +1.013 along [+0.10 dE] (Î” = 0.213)\n\nNow that our histogram is a cube, we compute the intensity in the histogram bins using the usual intensities_binned:\n\nformula = intensity_formula(dsf, :trace)\nsignal, counts = intensities_binned(dsf, params; formula)\nintensity = signal ./ counts\n\nNow that we have our intensity data and the binning parameters, we can export to VTK format using export_vtk and move to ParaView for the visualization.\n\n# Importing WriteVTK enables Sunny's export-to-VTK functions\nimport WriteVTK\n\n# [1,2,4] specifies that the (x,y,z) axes in ParaView are (Qx,Qy,Ï‰)\nexport_vtk(\"square_lattice\", params, intensity; dims_kept = [1,2,4])\n# Writes a file square_lattice.vti in the current directory","category":"section"},{"location":"writevtk.html#Loading-in-ParaView","page":"ParaView Rendering","title":"Loading in ParaView","text":"In ParaView, use File > Open to open square_lattice.vti. This will add the file to the Pipeline Browser with a closed eye icon, indicating that the data is ready to be loaded.\n\nIn the Properties panel, both bin_centers and data will be selected for import by default. Uncheck bin_centers because we don't need that information for the visualization. Click the green Apply button to load the data.\n\nBy default, only the outline of the data is shown in the 3D viewport. Since we adjusted the energy axis, the outline is a 1x1x1 cube. Optionally enable the axes grid under \"View\", and customize using the adjacent edit button.\n\n<img src=\"./assets/paraviewimport.png\" style=\"margin: 30px;\" width=\"200\">\n\nTo enable the volumetric render:\n\nSelect \"Volume\" from the \"Representation\" drop-down menu under \"Display\".\nThe \"Coloring\" drop-down should automatically select data because it's the only data loaded.\nOpen the Color Map Editor to adjust the opacity of the fog, which may be too faint to see by default.\n\n<img src=\"./assets/paraviewvolume.png\" style=\"margin: 30px; \" width=\"400\">\n\nDepending on your computer and your dataset size, the volumetric rendering may be slow, but our dataset is relatively small, so the render should be fast.\n\nIf nothing shows up at first, don't despair. Often, there are Bragg-like peaks in the correlation data which outshine everything else. To see this, enable Display Data Histogram in the Color Map Editor panel. To zoom in on the lower-intensity data, click and drag the right side handle of the opacity transfer function box to the middle a few times.\n\n<img src=\"./assets/paraviewcolormap.png\" style=\"margin: 30px; \" width=\"200\">\n\nAfter suitable color mapping, the dispersion curve should become visible:\n\n<img src=\"./assets/paraviewrender.jpg\" style=\"margin: 30px; \" width=\"400\">","category":"section"},{"location":"writevtk.html#Experiment-data","page":"ParaView Rendering","title":"Experiment data","text":"Note that since only the data and binning parameters are required for exporting to VTK, experiment data can be exported in the same way. For example, to visualize S(Q_xQ_yQ_z), do this:\n\n# Load 4D histogram data from Mantid\nparams, signal = load_nxs(\"experiment_data.nxs\")\n\n# Integrate out the energy axis so we are 3D\nintegrate_axes!(params; axes = 4)\nsignal = sum(signal; dims = 4)\n\n# Export to ParaView\nexport_vtk(\"experiment_data_as_vtk\", params, signal)","category":"section"},{"location":"examples/01_LSWT_CoRh2O4.html","page":"1. Spin wave simulations of CoRhâ‚‚Oâ‚„","title":"1. Spin wave simulations of CoRhâ‚‚Oâ‚„","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/01_LSWT_CoRh2O4.html#1.-Spin-wave-simulations-of-CoRhO","page":"1. Spin wave simulations of CoRhâ‚‚Oâ‚„","title":"1. Spin wave simulations of CoRhâ‚‚Oâ‚„","text":"This tutorial introduces Sunny through its features for performing conventional spin wave theory calculations. We consider the crystal CoRhâ‚‚Oâ‚„ and reproduce the calculations of Ge et al., Phys. Rev. B 96, 064413 (2017).","category":"section"},{"location":"examples/01_LSWT_CoRh2O4.html#Get-Julia-and-Sunny","page":"1. Spin wave simulations of CoRhâ‚‚Oâ‚„","title":"Get Julia and Sunny","text":"Sunny is implemented in Julia, which allows for interactive development (like Python or Matlab) while also providing high numerical efficiency (like C++ or Fortran). New Julia users should begin with our Getting Started guide. Sunny requires Julia 1.10 or later.\n\nFrom the Julia prompt, load Sunny and also GLMakie for graphics.\n\nusing Sunny, GLMakie\n\nIf these packages are not yet installed, Julia will offer to install them. If executing this tutorial gives an error, you may need to update Sunny and GLMakie from the built-in package manager.","category":"section"},{"location":"examples/01_LSWT_CoRh2O4.html#Units-system","page":"1. Spin wave simulations of CoRhâ‚‚Oâ‚„","title":"Units system","text":"The Units object selects reference energy and length scales, and uses these to provide physical constants. For example, units.K returns one kelvin as 0.086 meV, where the Boltzmann constant is implicit.\n\nunits = Units(:meV, :angstrom);\nnothing #hide","category":"section"},{"location":"examples/01_LSWT_CoRh2O4.html#Crystal-cell","page":"1. Spin wave simulations of CoRhâ‚‚Oâ‚„","title":"Crystal cell","text":"A crystallographic cell may be loaded from a .cif file, or specified from atom positions and types.\n\nStart by defining the shape of the conventional chemical cell. CoRhâ‚‚Oâ‚„ has cubic spacegroup 227 (Fd-3m). Its lattice constants are 8.5 â„« and the cell angles are 90Â°. With this information, lattice_vectors constructs a 3Ã—3 matrix latvecs. Columns of latvecs define the lattice vectors (ğš_1 ğš_2 ğš_3) in the global Cartesian coordinate system. Conversely, columns of inv(latvecs) define the global Cartesian axes (hatx haty hatz) in components of the lattice vectors.\n\na = 8.5031 # (Ã…)\nlatvecs = lattice_vectors(a, a, a, 90, 90, 90)\n\nConstruct a Crystal cell from spacegroup 227 in the ITA standard setting. Cobalt atoms belong to Wyckoff 8a, which is the diamond cubic lattice.\n\npositions = [[1/8, 1/8, 1/8]]\ncryst = Crystal(latvecs, positions, 227; types=[\"Co\"])\n\nview_crystal launches an interface for interactive inspection and symmetry analysis.\n\nview_crystal(cryst)","category":"section"},{"location":"examples/01_LSWT_CoRh2O4.html#Spin-system","page":"1. Spin wave simulations of CoRhâ‚‚Oâ‚„","title":"Spin system","text":"A System will define the spin model. Each cobalt atom carries quantum spin s = 32, with a g-factor of 2. Specify this Moment data for cobalt atom 1. By symmetry, the same moment data also applies to cobalt atoms 2, 3, ... 7. The option :dipole indicates a traditional model type, for which quantum spin is modeled as a dipole expectation value.\n\nsys = System(cryst, [1 => Moment(s=3/2, g=2)], :dipole)\n\nGe et al. demonstrated that inelastic neutron scattering data for CoRhâ‚‚Oâ‚„ is well modeled by antiferromagnetic nearest neighbor exchange, J = 0.63 meV. Call set_exchange! with the bond that connects atom 1 to atom 3, and has zero displacement between chemical cells. Consistent with the symmetries of spacegroup 227, this interaction will be propagated to all other nearest-neighbor bonds. Calling view_crystal with sys now shows the antiferromagnetic Heisenberg interactions as blue polkadot spheres.\n\nJ = +0.63 # (meV)\nset_exchange!(sys, J, Bond(2, 3, [0, 0, 0]))\nview_crystal(sys)","category":"section"},{"location":"examples/01_LSWT_CoRh2O4.html#Optimizing-spins","page":"1. Spin wave simulations of CoRhâ‚‚Oâ‚„","title":"Optimizing spins","text":"To search for the ground state, call randomize_spins! and minimize_energy! in sequence. For this problem, optimization converges rapidly to the expected NÃ©el order. See this with plot_spins, where spins are colored according to their global z-component.\n\nrandomize_spins!(sys)\nminimize_energy!(sys)\nplot_spins(sys; color=[S[3] for S in sys.dipoles])\n\nThe diamond lattice is bipartite, allowing each spin to perfectly anti-align with its 4 nearest-neighbors. Each of these 4 bonds contribute -J s^2 to the total energy. Two sites participate in each bond, so the energy per site is -2 J s^2. Check this by calling energy_per_site.\n\n@assert energy_per_site(sys) â‰ˆ -2J*(3/2)^2","category":"section"},{"location":"examples/01_LSWT_CoRh2O4.html#Reshaping-the-magnetic-cell","page":"1. Spin wave simulations of CoRhâ‚‚Oâ‚„","title":"Reshaping the magnetic cell","text":"The most compact magnetic cell for this NÃ©el order is the primitive unit cell. Columns of the primitive_cell matrix provide the primitive lattice vectors as multiples of the conventional cubic lattice vectors.\n\nshape = primitive_cell(cryst)\n\nReduce the magnetic cell size using reshape_supercell. Verify that the energy per site is unchanged after the reshaping the supercell.\n\nsys_prim = reshape_supercell(sys, shape)\n@assert energy_per_site(sys_prim) â‰ˆ -2J*(3/2)^2\n\nPlotting sys_prim shows the two spins within the primitive cell, as well as the larger conventional cubic cell for context.\n\nplot_spins(sys_prim; color=[S[3] for S in sys_prim.dipoles])","category":"section"},{"location":"examples/01_LSWT_CoRh2O4.html#Spin-wave-theory","page":"1. Spin wave simulations of CoRhâ‚‚Oâ‚„","title":"Spin wave theory","text":"With this primitive cell, we will perform a SpinWaveTheory calculation of the structure factor mathcalS(ğªÏ‰). The measurement ssf_perp indicates projection of the spin structure factor mathcalS(ğªÏ‰) perpendicular to the direction of momentum transfer, as appropriate for unpolarized neutron scattering. The isotropic FormFactor for CoÂ²âº dampens intensities at large ğª.\n\nformfactors = [1 => FormFactor(\"Co2\")]\nmeasure = ssf_perp(sys_prim; formfactors)\nswt = SpinWaveTheory(sys_prim; measure)\n\nSelect lorentzian broadening with a full-width at half-maximum (FWHM) of 0.8 meV.\n\nkernel = lorentzian(fwhm=0.8)\n\nDefine a q_space_path that connects high-symmetry points in reciprocal space. The ğª-points are given in reciprocal lattice units (RLU) for the original cubic cell. For example, [1/2, 1/2, 0] denotes the sum of the first two reciprocal lattice vectors, ğ›_12 + ğ›_22. A total of 500 ğª-points will be sampled along the path.\n\nqs = [[0, 0, 0], [1/2, 0, 0], [1/2, 1/2, 0], [0, 0, 0]]\npath = q_space_path(cryst, qs, 500)\n\nCalculate single-crystal scattering intensities along this path, for energies between 0 and 6 meV. Use plot_intensities to visualize the result.\n\nenergies = range(0, 6, 300)\nres = intensities(swt, path; energies, kernel)\nplot_intensities(res; units, title=\"CoRhâ‚‚Oâ‚„ LSWT\")\n\nSometimes experimental data is only available as a powder average, i.e., as an average over all possible crystal orientations. Use powder_average to simulate these intensities. Each ğª-magnitude defines a spherical shell in reciprocal space. Consider 200 radii from 0 to 3 inverse angstroms and collect 2000 random samples per spherical shell. As configured, this calculation completes in about two seconds. Had we used the conventional cubic cell, the calculation would be an order of magnitude slower.\n\nradii = range(0, 3, 200) # (1/Ã…)\nres = powder_average(cryst, radii, 2000) do qs\n    intensities(swt, qs; energies, kernel)\nend\nplot_intensities(res; units, saturation=1.0, title=\"CoRhâ‚‚Oâ‚„ Powder Average\")\n\nThis result can be compared to experimental neutron scattering data from Fig. 5 of Ge et al.\n\n<img width=\"95%\" src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/CoRh2O4_intensity.jpg\">","category":"section"},{"location":"examples/01_LSWT_CoRh2O4.html#What's-next?","page":"1. Spin wave simulations of CoRhâ‚‚Oâ‚„","title":"What's next?","text":"For more spin wave calculations of this type, browse the SpinW tutorials ported to Sunny.\nSpin wave theory neglects thermal fluctuations of the magnetic order. The next CoRhâ‚‚Oâ‚„ tutorial demonstrates how to sample spins in thermal equilibrium and measure correlations from the classical spin dynamics.\nSunny also offers features that go beyond the dipole approximation of a quantum spin via the theory of SU(N) coherent states. This can be especially useful for systems with strong single-ion anisotropy, as demonstrated in the FeIâ‚‚ tutorial.","category":"section"},{"location":"examples/04_GSD_FeI2.html","page":"4. Generalized spin dynamics of FeIâ‚‚ at finite T","title":"4. Generalized spin dynamics of FeIâ‚‚ at finite T","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/04_GSD_FeI2.html#4.-Generalized-spin-dynamics-of-FeI-at-finite-*T*","page":"4. Generalized spin dynamics of FeIâ‚‚ at finite T","title":"4. Generalized spin dynamics of FeIâ‚‚ at finite T","text":"The previous FeIâ‚‚ tutorial used multi-flavor spin wave theory to calculate the dynamical spin structure factor. This tutorial performs an analogous calculation at finite temperature using the classical dynamics of SU(N) coherent states.\n\nCompared to spin wave theory, classical spin dynamics in real-space is typically much slower and is limited in ğª-space resolution. The approach, however, allows for thermal fluctuations. This allows to explore finite temperature phases and enables the study of non-equilibrium processes.\n\nThe structure of this tutorial largely follows the previous study of CoRhâ‚‚Oâ‚„ at finite T. The main difference is that CoRhâ‚‚Oâ‚„ can be well described with :dipole mode, whereas FeIâ‚‚ is best modeled using :SUN mode, owing to its strong easy-axis anisotropy.\n\nConstruct the FeIâ‚‚ system as previously described.\n\nusing Sunny, GLMakie\n\nunits = Units(:meV, :angstrom)\na = b = 4.05012\nc = 6.75214\nlatvecs = lattice_vectors(a, b, c, 90, 90, 120)\ncryst = Crystal(latvecs, [[0,0,0]], 164; types=[\"Fe\"])\n\nsys = System(cryst, [1 => Moment(s=1, g=2)], :SUN)\nJ1pm   = -0.236\nJ1pmpm = -0.161\nJ1zpm  = -0.261\nJ2pm   = 0.026\nJ3pm   = 0.166\nJâ€²0pm  = 0.037\nJâ€²1pm  = 0.013\nJâ€²2apm = 0.068\nJ1zz   = -0.236\nJ2zz   = 0.113\nJ3zz   = 0.211\nJâ€²0zz  = -0.036\nJâ€²1zz  = 0.051\nJâ€²2azz = 0.073\nJ1xx = J1pm + J1pmpm\nJ1yy = J1pm - J1pmpm\nJ1yz = J1zpm\nset_exchange!(sys, [J1xx 0.0 0.0; 0.0 J1yy J1yz; 0.0 J1yz J1zz], Bond(1,1,[1,0,0]))\nset_exchange!(sys, [J2pm 0.0 0.0; 0.0 J2pm 0.0; 0.0 0.0 J2zz], Bond(1,1,[1,2,0]))\nset_exchange!(sys, [J3pm 0.0 0.0; 0.0 J3pm 0.0; 0.0 0.0 J3zz], Bond(1,1,[2,0,0]))\nset_exchange!(sys, [Jâ€²0pm 0.0 0.0; 0.0 Jâ€²0pm 0.0; 0.0 0.0 Jâ€²0zz], Bond(1,1,[0,0,1]))\nset_exchange!(sys, [Jâ€²1pm 0.0 0.0; 0.0 Jâ€²1pm 0.0; 0.0 0.0 Jâ€²1zz], Bond(1,1,[1,0,1]))\nset_exchange!(sys, [Jâ€²2apm 0.0 0.0; 0.0 Jâ€²2apm 0.0; 0.0 0.0 Jâ€²2azz], Bond(1,1,[1,2,1]))\nD = 2.165\nset_onsite_coupling!(sys, S -> -D*S[3]^2, 1)","category":"section"},{"location":"examples/04_GSD_FeI2.html#Thermalization","page":"4. Generalized spin dynamics of FeIâ‚‚ at finite T","title":"Thermalization","text":"To study thermal fluctuations in real-space, use a large system size with 16Ã—16Ã—4 copies of the chemical cell.\n\nsys = resize_supercell(sys, (16, 16, 4))\n\nDirect optimization via minimize_energy! is susceptible to trapping in a local minimum. An alternative approach is to simulate the system using Langevin spin dynamics. This requires a bit more set-up, but allows sampling from thermal equilibrium at any target temperature. Select the temperature 2.3 K â‰ˆ 0.2 meV. This temperature is small enough to magnetically order, but large enough so that the dynamics can readily overcome local energy barriers and annihilate defects.\n\nlangevin = Langevin(; damping=0.2, kT=2.3*units.K)\n\nUse suggest_timestep to select an integration timestep for the error tolerance tol=1e-2. Initializing sys to some low-energy configuration usually works well.\n\nrandomize_spins!(sys)\nminimize_energy!(sys; maxiters=10)\nsuggest_timestep(sys, langevin; tol=1e-2)\nlangevin.dt = 0.03;\nnothing #hide\n\nRun a Langevin trajectory for 10,000 time-steps and plot the spins. The magnetic order is present, but may be difficult to see.\n\nfor _ in 1:10_000\n    step!(sys, langevin)\nend\nplot_spins(sys; color=[S[3] for S in sys.dipoles])\n\nVerify the expected two-up, two-down spiral magnetic order by calling print_wrapped_intensities. A single propagation wavevector ğ¤ dominates the static intensity in mathcalS(ğª), indicating the expected 2 up, 2 down magnetic spiral order. A smaller amount of intensity is spread among many other wavevectors due to thermal fluctuations.\n\nprint_wrapped_intensities(sys)\n\nThermalization has not substantially altered the suggested dt.\n\nsuggest_timestep(sys, langevin; tol=1e-2)","category":"section"},{"location":"examples/04_GSD_FeI2.html#Structure-factor-in-the-paramagnetic-phase","page":"4. Generalized spin dynamics of FeIâ‚‚ at finite T","title":"Structure factor in the paramagnetic phase","text":"The remainder of this tutorial will focus on the paramagnetic phase. Re-thermalize the system to the temperature of 3.5 K â‰ˆ 0.30 meV.\n\nlangevin.kT = 3.5 * units.K\nfor _ in 1:10_000\n    step!(sys, langevin)\nend\n\nThe suggested timestep has increased slightly. Following this suggestion will make the simulations a bit faster.\n\nsuggest_timestep(sys, langevin; tol=1e-2)\nlangevin.dt = 0.040;\nnothing #hide\n\nCollect dynamical spin structure factor data using SampledCorrelations. This procedure involves sampling spin configurations from thermal equilibrium and using the spin dynamics of SU(N) coherent states to estimate dynamical correlations. With proper classical-to-quantum corrections, the associated structure factor intensities S^Î±Î²(qÏ‰) can be compared with finite-temperature inelastic neutron scattering data. Incorporate the FormFactor appropriate to FeÂ²âº.\n\ndt = 2*langevin.dt\nenergies = range(0, 7.5, 120)\nformfactors = [1 => FormFactor(\"Fe2\"; g_lande=3/2)]\nsc = SampledCorrelations(sys; dt, energies, measure=ssf_perp(sys; formfactors))\n\nThe function add_sample! will collect data by running a dynamical trajectory starting from the current system configuration.\n\nadd_sample!(sc, sys)\n\nTo collect additional data, it is required to re-sample the spin configuration from the thermal distribution. Statistical error is reduced by fully decorrelating the spin configurations between calls to add_sample!.\n\nfor _ in 1:2\n    for _ in 1:1000               # Enough steps to decorrelate spins\n        step!(sys, langevin)\n    end\n    add_sample!(sc, sys)\nend\n\nPerform an intensity calculation for two special ğª-points in reciprocal lattice units (RLU). A classical-to-quantum rescaling of normal mode occupations will be performed according to the temperature kT. The large statistical noise could be reduced by averaging over more thermal samples.\n\nres = intensities(sc, [[0, 0, 0], [0.5, 0.5, 0.5]]; energies, langevin.kT)\nfig = lines(res.energies, res.data[:, 1]; axis=(xlabel=\"Energy (meV)\", ylabel=\"Intensity\"), label=\"(0,0,0)\")\nlines!(res.energies, res.data[:, 2]; label=\"(Ï€,Ï€,Ï€)\")\naxislegend()\nfig\n\nNext, we will measure intensities along a q_space_path that connects high symmetry points. Because this is a real-space calculation, data is only available for discrete ğª modes, with resolution that scales inversely to linear system size. Intensities at Ï‰ = 0 dominate, so to enhance visibility, we restrict the color range empirically.\n\nqs = [[0,   0, 0],  # List of wave vectors that define a path\n      [1,   0, 0],\n      [0,   1, 0],\n      [1/2, 0, 0],\n      [0,   1, 0],\n      [0,   0, 0]]\nqpath = q_space_path(cryst, qs, 500)\nres = intensities(sc, qpath; energies, langevin.kT)\nplot_intensities(res; units, colorrange=(0.0, 1.0), title=\"Intensities at T = 2.3 K\")\n\nOne can also view the intensity along a q_space_grid for a fixed energy value. Alternatively, use intensities_static to integrate over all available energies.\n\ngrid = q_space_grid(cryst, [1, 0, 0], range(-1.5, 1.5, 300), [0, 1, 0], (-1.5, 1.5); orthogonalize=true)\nres = intensities(sc, grid; energies=[3.5], langevin.kT)\nplot_intensities(res; title=\"Intensity slice at Ï‰ = 3.5 meV\")","category":"section"},{"location":"examples/spinw/SW08_sqrt3_kagome_AFM.html","page":"SW08 - âˆš3Ã—âˆš3 kagome antiferromagnet","title":"SW08 - âˆš3Ã—âˆš3 kagome antiferromagnet","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW08_sqrt3_kagome_AFM.html#SW08-33-kagome-antiferromagnet","page":"SW08 - âˆš3Ã—âˆš3 kagome antiferromagnet","title":"SW08 - âˆš3Ã—âˆš3 kagome antiferromagnet","text":"This is a Sunny port of SpinW Tutorial 8, originally authored by Bjorn Fak and Sandor Toth. It calculates the linear spin wave theory spectrum for the sqrt3 times sqrt3 order of a kagome antiferromagnet.\n\nLoad Sunny and the GLMakie plotting package.\n\nusing Sunny, GLMakie\n\nDefine the chemical cell of a kagome lattice with spacegroup 147 (P-3).\n\nunits = Units(:meV, :angstrom)\nlatvecs = lattice_vectors(6, 6, 40, 90, 90, 120)\ncryst = Crystal(latvecs, [[1/2, 0, 0]], 147)\nview_crystal(cryst; ndims=2)\n\nConstruct a spin system with nearest neighbor antiferromagnetic exchange.\n\nsys = System(cryst, [1 => Moment(s=1, g=2)], :dipole)\nJ = 1.0\nset_exchange!(sys, J, Bond(2, 3, [0, 0, 0]))\n\nInitialize to an energy minimizing magnetic structure, for which nearest-neighbor spins are at 120Â° angles.\n\nset_dipole!(sys, [cos(0), sin(0), 0], (1, 1, 1, 1))\nset_dipole!(sys, [cos(0), sin(0), 0], (1, 1, 1, 2))\nset_dipole!(sys, [cos(2Ï€/3), sin(2Ï€/3), 0], (1, 1, 1, 3))\nk = [-1/3, -1/3, 0]\naxis = [0, 0, 1]\nsys_enlarged = repeat_periodically_as_spiral(sys, (3, 3, 1); k, axis)\nplot_spins(sys_enlarged; ndims=2)\n\nCheck energy per site. Each site participates in 4 bonds with energy Jcos(2Ï€3). Factor of 1/2 avoids double counting. The two calculation methods agree.\n\n@assert energy_per_site(sys_enlarged) â‰ˆ (4/2)*J*cos(2Ï€/3)\n@assert spiral_energy_per_site(sys; k, axis) â‰ˆ (4/2)*J*cos(2Ï€/3)\n\nCalculate and plot intensities for a path through ğª-space using two calculation methods. The two methods agree in intensity, but the \"supercell method\" gives rise to ghost modes in the dispersion that have zero intensity.\n\nqs = [[-1/2,0,0], [0,0,0], [1/2,1/2,0]]\npath = q_space_path(cryst, qs, 400)\n\nfig = Figure(size=(768, 300))\nswt = SpinWaveTheory(sys_enlarged; measure=ssf_perp(sys_enlarged))\nres = intensities_bands(swt, path)\nplot_intensities!(fig[1, 1], res; units, saturation=0.5,title=\"Supercell method\")\nswt = SpinWaveTheorySpiral(sys; measure=ssf_perp(sys), k, axis)\nres = intensities_bands(swt, path)\nplot_intensities!(fig[1, 2], res; units, saturation=0.5, title=\"Spiral method\")\nfig\n\nCalculate and plot the powder averaged spectrum. Continuing to use the \"spiral method\", this calculation executes in about two seconds. Because the intensities are dominated by a flat band at zero energy transfer, select an empirical colorrange that brings the lower-intensity features into focus.\n\nradii = range(0, 2.5, 200)\nenergies = range(0, 2.5, 200)\nkernel = gaussian(fwhm=0.05)\nres = powder_average(cryst, radii, 200) do qs\n    intensities(swt, qs; energies, kernel)\nend\nplot_intensities(res; units, colorrange=(0, 20))","category":"section"},{"location":"examples/spinw/SW10_Energy_cut.html","page":"SW10 - Energy cut on square lattice","title":"SW10 - Energy cut on square lattice","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW10_Energy_cut.html#SW10-Energy-cut-on-square-lattice","page":"SW10 - Energy cut on square lattice","title":"SW10 - Energy cut on square lattice","text":"This is a Sunny port of SpinW Tutorial 10, originally authored by Sandor Toth. It calculates the spin wave spectrum on a constant energy cut of the frustrated square lattice.\n\nLoad Sunny and the GLMakie plotting package.\n\nusing Sunny, GLMakie\n\nDefine the chemical cell for the 2D square lattice.\n\nunits = Units(:meV, :angstrom)\nlatvecs = lattice_vectors(1.0, 1.0, 3.0, 90, 90, 90)\ncryst = Crystal(latvecs, [[0, 0, 0]])\n\nConstruct a spin system with nearest-neighbor antiferomagnetic interactions of 1.0 meV. Energy minimization yields the expected NÃ©el order on the 2Ã—2 magnetic cell.\n\nsys = System(cryst, [1 => Moment(s=1, g=2)], :dipole; dims=(2, 2, 1))\nset_exchange!(sys, 1.0, Bond(1, 1, [1, 0, 0]))\nrandomize_spins!(sys)\nminimize_energy!(sys)\nplot_spins(sys; ndims=2)\n\nDefine a 2D slice through ğª-space with q_space_grid.\n\ngrid = q_space_grid(cryst, [1, 0, 0], range(0, 2, 201), [0, 1, 0], range(0, 2, 201))\n\nCalculate and plot a constant energy cut at the precise value of 3.75 meV. Apply a line broadening with a full-width half-max of 0.2 meV to approximately capture intensities between 3.5 and 4.0 meV.\n\nswt = SpinWaveTheory(sys; measure=ssf_trace(sys))\nres = intensities(swt, grid; energies=[3.75], kernel=gaussian(fwhm=0.2))\nplot_intensities(res; units)\n\nIntegrate intensities between 3.5 and 4 meV using intensities_static with the bounds option.\n\nres = intensities_static(swt, grid; bounds=(3.5, 4.01))\nplot_intensities(res; units)","category":"section"},{"location":"examples/08_Momentum_Conventions.html","page":"8. Momentum transfer conventions","title":"8. Momentum transfer conventions","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/08_Momentum_Conventions.html#8.-Momentum-transfer-conventions","page":"8. Momentum transfer conventions","title":"8. Momentum transfer conventions","text":"Sunny defines the dynamical structure factor following conventions as in Squire and Boothroyd,\n\nmathcalS^Î±Î²(ğª Ï‰)  frac12Ï€ int_-^ e^-iÏ‰t hatM^Î±_ğª(0) hatM^Î²_ğª(t) dt\n\nThe momentum-space dipole operator hatğŒ_ğª is obtained from the real-space density hatğŒ(ğ«) using the Fourier transform convention,\n\nhatğŒ_ğª  int_V e^+ i ğªğ« hatğŒ(ğ«) dğ«\n\nWith appropriate contraction of spin components, mathcalS^Î±Î²(ğª Ï‰) directly relates to the neutron scattering cross-section. Here, ğª and Ï‰ represent momentum and energy transfer to the sample. Sunny will report the structure factor as an intensive quantity by dividing by the number of chemical cells in the macroscopic sample. Full details are given in the documentation page Structure Factor Conventions.\n\nIf the spin Hamiltonian lacks inversion symmetry, intensities at ğª may be inequivalent. A simple example is the 1D chain with competing Ising and Dzyaloshinskiiâ€“Moriya couplings. Sunny calculations on this model can be compared to those of other codes. For example, SpinW employs the opposite sign convention for the momentum transfer ğª.","category":"section"},{"location":"examples/08_Momentum_Conventions.html#1D-model-lacking-reflection-symmetry","page":"8. Momentum transfer conventions","title":"1D model lacking reflection symmetry","text":"using Sunny, GLMakie\n\nCreate a Crystal with spacegroup P1 to effectively disable all symmetry analysis. This avoids any symmetry-imposed constraints on the couplings. Because all bonds are treated as symmetry-inequivalent, each coupling must be specified independently; there is no automatic propagation to \"equivalent\" bonds.\n\nlatvecs = lattice_vectors(1, 1, 1, 90, 90, 90)\ncryst = Crystal(latvecs, [[0, 0, 0]], \"P1\")\n\nInclude DM and Ising couplings between nearest neighbors on a chain. Letting j denote the site position along axis ğš_3, the full Hamiltonian is\n\nâ„‹ = ğƒ  _j ğ’_j  ğ’_j+1 - J _j _j S^z_j S^z_j+1\n\nwith dmvec ğƒ = D z.\n\ns = 3/2\nsys = System(cryst, [1 => Moment(; s, g=2)], :dipole)\nJ = 1.0\nD = 0.2\nz = [0, 0, 1]\nset_exchange!(sys, dmvec(D * z) - J * z * z', Bond(1, 1, [0, 0, 1]))\n\nThe relatively large Ising coupling favors one of two polarized states, z. Use polarize_spins! to align ğ’ with +z. This polarization could also be realized via an applied ğ field in the opposite direction, as documented in set_field!.\n\npolarize_spins!(sys, [0, 0, 1])\n@assert energy(sys) â‰ˆ - s^2\nplot_spins(sys)","category":"section"},{"location":"examples/08_Momentum_Conventions.html#Intensities-from-linear-spin-wave-theory","page":"8. Momentum transfer conventions","title":"Intensities from linear spin wave theory","text":"The SpinWaveTheory calculation shows a single band with dispersion Ïµ(ğª) = 2 s J  D sin(2Ï€q_3) for the polarization state ğ’ =  s z. There is a clear dependence on the sign of q_3.\n\npath = q_space_path(cryst, [[0, 0, -1/2], [0, 0, 0], [0, 0, +1/2]], 400)\nswt = SpinWaveTheory(sys; measure=ssf_trace(sys))\nres = intensities_bands(swt, path)\nplot_intensities(res; ylims=(0, 5))","category":"section"},{"location":"examples/08_Momentum_Conventions.html#Intensities-from-classical-spin-dynamics","page":"8. Momentum transfer conventions","title":"Intensities from classical spin dynamics","text":"Classical dynamics at low temperatures produces, in principle, the same excitation spectrum. Here, finite-size effects will limit ğª-space resolution. Use resize_supercell to study a chain of 32 sites.\n\nsys2 = resize_supercell(sys, (1, 1, 32))\n\nUse Langevin dynamics to sample from the classical Boltzmann distribution at a relatively low temperature, k_B T  J = 003\n\ndt = 0.03 / J\nkT = 0.03 * J\ndamping = 0.1\nlangevin = Langevin(dt; kT, damping)\nsuggest_timestep(sys2, langevin; tol=1e-2)\nfor _ in 1:10_000\n    step!(sys, langevin)\nend\n\nUse SampledCorrelations to collect statistics from classical spin dynamic trajectories.\n\nsc = SampledCorrelations(sys2; dt, energies=range(0, 5, 100), measure=ssf_trace(sys2))\nadd_sample!(sc, sys2)\nnsamples = 100\nfor _ in 1:nsamples\n    for _ in 1:1000\n        step!(sys2, langevin)\n    end\n    add_sample!(sc, sys2)\nend\n\nIn the limit T  0, the intensities match linear spin wave theory up to finite-size effects and statistical error. Additionally, the classical dynamics calculation shows the elastic peak at ğª = 000, associated with the ferromagnetic ground state.\n\nres2 = intensities(sc, path; energies=:available, kT)\nplot_intensities(res2)","category":"section"},{"location":"examples/06_CP2_Skyrmions.html","page":"6. Dynamical quench into CPÂ² skyrmion liquid","title":"6. Dynamical quench into CPÂ² skyrmion liquid","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/06_CP2_Skyrmions.html#6.-Dynamical-quench-into-CP-skyrmion-liquid","page":"6. Dynamical quench into CPÂ² skyrmion liquid","title":"6. Dynamical quench into CPÂ² skyrmion liquid","text":"This example demonstrates a non-equilibrium study of SU(3) spin dynamics leading to the formation of a CPÂ² skyrmion liquid. As proposed in Zhang et al., Nature Communications 14, 3626 (2023), CPÂ² skyrmions are topological defects that involve both the dipolar and quadrupolar parts of quantum spin-1, and can be studied using the formalism SU(3) coherent states.\n\nThis study uses the SU(N) generalization of Landau-Lifshitz spin dynamics, with Langevin coupling to a thermal bath, as described in Dahlbom et al., Phys. Rev. B 106, 235154 (2022). Beginning from an initial high-temperature state, the dynamics following a rapid quench in temperature gives rise a disordered liquid of CPÂ² skyrmions.\n\nusing Sunny, GLMakie\n\nBegin with a Crystal cell for the triangular lattice.\n\nlat_vecs = lattice_vectors(1, 1, 10, 90, 90, 120)\npositions = [[0, 0, 0]]\ncryst = Crystal(lat_vecs, positions)\n\nCreate a spin System containing LL cells. Following previous worse, select g=-1 so that the Zeeman coupling has the form -ğğ’.\n\nL = 40\nsys = System(cryst, [1 => Moment(s=1, g=-1)], :SUN; dims=(L, L, 1))\n\nThe Hamiltonian,\n\nmathcalH = sum_langle ij rangle J_ij( hatS_i^x hatS_j^x + hatS_i^y hatS_j^y + DeltahatS_i^z hatS_j^z) - hsum_ihatS_i^z + Dsum_i(hatS_i^z)^2\n\ncontains competing ferromagnetic first-neighbor and antiferromagnetic second-neighbor exchange terms on a triangular lattice. Both exchange matrices include anisotropy in the hatz direction. Additionally, there is an external magnetic field h and an easy-plane single-ion anisotropy D. Select parameters for a point in the Zhang et al. phase diagram where the CPÂ² skyrmions are stable.\n\nJ1 = -1           # Nearest-neighbor ferromagnetic\nJ2 = (2.0/(1+âˆš5)) # Tune competing exchange to set skyrmion scale length\nÎ” = 2.6           # Exchange anisotropy\n\nex1 = J1 * [1 0 0;\n            0 1 0;\n            0 0 Î”]\nex2 = J2 * [1 0 0;\n            0 1 0;\n            0 0 Î”]\nset_exchange!(sys, ex1, Bond(1, 1, [1, 0, 0]))\nset_exchange!(sys, ex2, Bond(1, 1, [1, 2, 0]))\n\nh = 15.5         # External field in energy units\nfield = set_field!(sys, [0, 0, h])\n\nD = 19.0         # Easy-plane anisotropy\nset_onsite_coupling!(sys, S -> D*S[3]^2, 1)\n\nInitialize system to an infinite temperature (fully randomized) initial condition.\n\nWe will study a temperature quench process using a generalized Langevin spin dynamics. In this SU(3) treatment of quantum spin-1, the dynamics include coupled dipoles and quadrupoles. Select a relatively small damping magnitude to overcome local minima and disable thermal fluctuations.\n\ndamping = 0.05\nkT = 0;\nnothing #hide\n\nThe first step is to estimate a reasonable integration timestep dt. In this case, a random spin configuration gives a tighter bound than does an energy-minimized configuration. A relatively large error tolerance is OK for this phenomenological study.\n\nrandomize_spins!(sys)\nintegrator = Langevin(; damping, kT)\nsuggest_timestep(sys, integrator; tol=0.05)\n\nApply the suggested timestep.\n\nintegrator.dt = 0.01;\nnothing #hide\n\nNow run the dynamical quench starting from a randomized configuration. The field frames stores the system spin configuration, as SU(3) coherent states, at three different times during the quenching process.\n\nrandomize_spins!(sys)\nÏ„s = [4, 16, 256]   # Times to record snapshots\nframes = []         # Empty array to store snapshots\nfor i in eachindex(Ï„s)\n    dur = i == 1 ? Ï„s[1] : Ï„s[i] - Ï„s[i-1] # Determine the length of time to simulate\n    numsteps = round(Int, dur/integrator.dt)\n    for _ in 1:numsteps                    # Perform the integration\n        step!(sys, integrator)\n    end\n    push!(frames, copy(sys.coherents))     # Save a snapshot spin configuration\nend\n\nVisualize the state of the system contained in each snapshot by plotting the SU(3) Berry phase curvature over triangular plaquettes. This is a measure of CPÂ² skyrmion density. The function plot_triangular_plaquettes is not part of the core Sunny package, but rather something you could define yourself using Makie. Find this helper function at examples/extra/Plotting/.\n\ninclude(pkgdir(Sunny, \"examples\", \"extra\", \"Plotting\", \"plotting2d.jl\"))\n\nfunction sun_berry_curvature(zâ‚, zâ‚‚, zâ‚ƒ)\n    zâ‚, zâ‚‚, zâ‚ƒ = normalize.((zâ‚, zâ‚‚, zâ‚ƒ))\n    nâ‚ = zâ‚ â‹… zâ‚‚\n    nâ‚‚ = zâ‚‚ â‹… zâ‚ƒ\n    nâ‚ƒ = zâ‚ƒ â‹… zâ‚\n    return angle(nâ‚ * nâ‚‚ * nâ‚ƒ)\nend\n\nplot_triangular_plaquettes(sun_berry_curvature, frames; size=(600, 200),\n    offset_spacing=10, texts=[\"\\tt = \"*string(Ï„) for Ï„ in Ï„s], text_offset=(0, 6)\n)\n\nThe times are given in hbarJ_1. The white background corresponds to a quantum paramagnetic state, where the local spin exhibits a strong quadrupole moment and little or no dipole moment. At late times, there are well-formed skyrmions of positive (red) and negative (blue) charge, and other metastable spin configurations. A full-sized version of this figure is available in Dahlbom et al..","category":"section"},{"location":"examples/spinw/SW02_AFM_Heisenberg_chain.html","page":"SW02 - AFM Heisenberg chain","title":"SW02 - AFM Heisenberg chain","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW02_AFM_Heisenberg_chain.html#SW02-AFM-Heisenberg-chain","page":"SW02 - AFM Heisenberg chain","title":"SW02 - AFM Heisenberg chain","text":"This is a Sunny port of SpinW Tutorial 2, originally authored by Bjorn Fak and Sandor Toth. It calculates the spin wave spectrum of the antiferromagnetic Heisenberg nearest-neighbor spin chain.\n\nLoad Sunny and the GLMakie plotting package.\n\nusing Sunny, GLMakie\n\nDefine the chemical cell for a 1D chain following the previous tutorial.\n\nunits = Units(:meV, :angstrom)\nlatvecs = lattice_vectors(3, 8, 8, 90, 90, 90)\ncryst = Crystal(latvecs, [[0, 0, 0]])\nview_crystal(cryst; ndims=2, ghost_radius=8)\n\nUnlike in the previous tutorial, here the magnetic cell should include 2Ã—1Ã—1 chemical cells to support antiferromagnetic (NÃ©el) order along the chain.\n\nsys = System(cryst, [1 => Moment(s=1, g=2)], :dipole; dims=(2, 1, 1))\n\nSet a nearest neighbor interaction of J = +1 meV along the chain and find the energy-minimizing NÃ©el order. As before, a global rotation in spin-space is arbitrary.\n\nJ = 1\nset_exchange!(sys, J, Bond(1, 1, [1, 0, 0]))\nrandomize_spins!(sys)\nminimize_energy!(sys)\nplot_spins(sys; ndims=2, ghost_radius=8)\n\nPerform a SpinWaveTheory calculation for a path between 000 and 100 in RLU.\n\nswt = SpinWaveTheory(sys; measure=ssf_perp(sys))\nqs = [[0,0,0], [1,0,0]]\npath = q_space_path(cryst, qs, 401)\nres = intensities_bands(swt, path)\nplot_intensities(res; units)\n\nThis system includes two bands that are fully degenerate in their dispersion.\n\nisapprox(res.disp[1, :], res.disp[2, :])\n\nPlot the intensities summed over the two degenerate bands using the Makie lines function.\n\nxs = [q[1] for q in path.qs]\nys = res.data[1, :] + res.data[2, :]\nlines(xs, ys; axis=(; xlabel=\"[H, 0, 0]\", ylabel=\"Intensity\", yscale=log10))","category":"section"},{"location":"examples/spinw/SW11_La2CuO4.html","page":"SW11 - Laâ‚‚CuOâ‚„","title":"SW11 - Laâ‚‚CuOâ‚„","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW11_La2CuO4.html#SW11-LaCuO","page":"SW11 - Laâ‚‚CuOâ‚„","title":"SW11 - Laâ‚‚CuOâ‚„","text":"This is a Sunny port of SpinW Tutorial 11, originally authored by Sandor Toth. It calculates the spin wave spectrum of Laâ‚‚CuOâ‚„.\n\nLoad packages\n\nusing Sunny, GLMakie\n\nBuild a square lattice for the the CuÂ²âº atoms. The lattice constant 1 â„« is selected arbitrarily.\n\nunits = Units(:meV, :angstrom)\nlatvecs = lattice_vectors(3.85, 3.85, 12.25, 90, 90, 90)\npositions = [[0, 0, 0]]\ntypes = [\"Cu\"]\ncryst = Crystal(latvecs, positions, 139; types)\nview_crystal(cryst)\n\nBuild a spin system using the exchange parameters from R. Coldea, Phys. Rev. Lett. 86, 5377 (2001).\n\nsys = System(cryst, [1 => Moment(s=1/2, g=2)], :dipole; dims=(2, 2, 1))\nJ   = 138.3\nJp  = 2\nJpp = 2\nJc  = 38\nset_exchange!(sys, J-Jc/2, Bond(1, 1, [1, 0, 0]))\nset_exchange!(sys, Jp-Jc/4, Bond(1, 1, [1, 1, 0]))\nset_exchange!(sys, Jpp, Bond(1, 1, [2, 0, 0]))\n\nEnergy minimization yields the expected NÃ©el order within each plane.\n\nrandomize_spins!(sys)\nminimize_energy!(sys)\nplot_spins(sys)\n\nPlot the spin wave spectrum for a path through ğª-space. Apply a manual \"quantum correction\" that adjusts energy scale by the factor 1.18.\n\nqs = [[3/4,1/4,0], [1/2, 1/2, 0], [1/2, 0, 0], [3/4, 1/4, 0], [1,0,0], [1/2 0 0]]\nlabels = [\"P\", \"M\", \"X\", \"P\", \"Î“\", \"X\"]\npath = q_space_path(cryst, qs, 400; labels)\nenergies = range(0, 320, 400)\nswt = SpinWaveTheory(sys; measure=ssf_perp(sys))\nres = intensities(swt, path; energies, kernel=gaussian(fwhm=35))\nres.energies .*= 1.18\nplot_intensities(res; units)\n\nPlot instantaneous itensities, integrated over Ï‰.\n\nres = intensities_static(swt, path)\nplot_intensities(res; ylims=(0, 20), units)","category":"section"},{"location":"library.html#Library-Reference","page":"Library Reference","title":"Library Reference","text":"This page describes the public types and functions exported by Sunny. This documentation can be also be accessed using the Julia help system (enter ? at the Julia command prompt).","category":"section"},{"location":"library.html#Index","page":"Library Reference","title":"Index","text":"Modules = [Sunny]","category":"section"},{"location":"library.html#Core-Sunny-functions","page":"Library Reference","title":"Core Sunny functions","text":"","category":"section"},{"location":"library.html#Optional-Makie-extensions","page":"Library Reference","title":"Optional Makie extensions","text":"Load a Makie graphics package (GLMakie, WGLMakie, or CairoMakie) to enable the following extensions:","category":"section"},{"location":"library.html#Optional-WriteVTK-extensions","page":"Library Reference","title":"Optional WriteVTK extensions","text":"Load the WriteVTK package to enable the following extensions:","category":"section"},{"location":"library.html#Sunny.BinningParameters","page":"Library Reference","title":"Sunny.BinningParameters","text":"BinningParameters(binstart, binend, binwidth; covectors=I(4))\nBinningParameters(binstart, binend; numbins, covectors=I(4))\n\nDescribes a 4D parallelepided histogram in a format compatible with experimental Inelasitic Neutron Scattering data. See generate_mantid_script_from_binning_parameters to convert BinningParameters to a format understandable by the Mantid software, or load_nxs to load BinningParameters from a Mantid .nxs file.\n\nThe coordinates of the histogram axes are specified by multiplication of (q,Ï‰) with each row of the covectors matrix, with q given in [R.L.U.]. Since the default covectors matrix is the identity matrix, the default axes are (qx, qy, qz, Ï‰) in absolute units.\n\nThe convention for the binning scheme is that:\n\nThe left edge of the first bin starts at binstart\nThe bin width is binwidth\nThe last bin contains binend\nThere are no \"partial bins;\" the last bin may contain values greater than binend.\n\nA value can be binned by computing its bin index:\n\n    coords = covectors * value\n    bin_ix = 1 .+ floor.(Int64, (coords .- binstart) ./ binwidth)\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.Bond","page":"Library Reference","title":"Sunny.Bond","text":"Bond(i, j, n)\n\nRepresents a bond between atom indices i and j. n is a vector of three integers specifying unit cell displacement in terms of lattice vectors.\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.Crystal","page":"Library Reference","title":"Sunny.Crystal","text":"An object describing a crystallographic unit cell and its space group symmetry. Constructors are as follows:\n\nCrystal(filename; symprec=nothing)\n\nReads the crystal from a CIF or mCIF at filename. Lattice vectors will be in units of angstrom. In most cases, symprec can be omitted. If provided, it will specify the precision of the dimensionless site position data (commonly between 1e-2 and 1e-5).\n\nIn case of an mCIF, returns the standardized chemical cell. Use this crystal to build an appropriately shaped System and then load the magnetic order with set_dipoles_from_mcif!.\n\nCrystal(latvecs, positions; types=nothing, symprec=1e-5)\n\nConstructs a crystal from the complete list of atom positions positions, with coordinates (between 0 and 1) in units of lattice vectors latvecs. Spacegroup symmetry information is automatically inferred using the Spglib package [1] at the dimensionless symmetry precision symprec. The optional parameter types is a list of strings, one for each atom, and can be used to break symmetry-equivalence between atoms.\n\nCrystal(latvecs, positions, spacegroup; types=nothing, choice=nothing, symprec=1e-5)\n\nBuilds a crystal using the symmetries of a spacegroup. One representative atom must be specified for each occupied Wyckoff. The spacegroup may be passed as a number 1..230 or as a string. A spacegroup number will imply the ITA standard setting [2], consistent with conventions from the Bilbao crystallographic server. Alternatively, a spacegroup symbol can select among all possible ITA settings (origin choice and orientation) for the spacegroup. In case of ambiguity, an error message will list the options.\n\nExamples\n\n# Read a Crystal from a .cif or .mcif file\nCrystal(\"filename.cif\")\n\n# Build a BCC crystal in the conventional cubic unit cell by specifying both\n# atoms. The spacegroup 229 is inferred.\nlatvecs = lattice_vectors(1, 1, 1, 90, 90, 90)\npositions = [[0, 0, 0], [1/2, 1/2, 1/2]]\nCrystal(latvecs, positions)\n\n# Build a CsCl crystal (two simple cubic sublattices). Because of the distinct\n# atom types, the spacegroup number 221 is now inferred.\ntypes = [\"Na\", \"Cl\"]\ncryst = Crystal(latvecs, positions; types)\n\n# Build a diamond cubic crystal from its spacegroup number 227 and a single\n# atom position belonging to Wyckoff 8a.\npositions = [[1/8, 1/8, 1/8]]\ncryst = Crystal(latvecs, positions, 227)\n\n# Build the same crystal for 227 (Fd-3m), but with non-standard origin choice.\npositions = [[0, 0, 0]]\ncryst = Crystal(latvecs, positions, \"Fd-3m\"; choice=\"1\")\n\n# Spacegroup 5 has the short name \"C2\", which admits multiple ITA settings.\nCrystal(latvecs, positions, 5)         # Standard ITA setting, \"C 1 2 1\"\nCrystal(latvecs, positions, \"C2\")      # Error due to ambiguous setting\nCrystal(latvecs, positions, \"B 1 1 2\") # Specific non-standard ITA setting\n\nSee also lattice_vectors.\n\nReferences\n\nA. Togo, K. Shinohara, I. Tanaka, Spglib: a software library for crystal symmetry search (2018) [arXiv:1808.01590].\nInternational Tables of Crystallography, Volume A (2016).\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.FormFactor","page":"Library Reference","title":"Sunny.FormFactor","text":"FormFactor(ion::String; g_lande=2, length=:angstrom)\n\nThe magnetic form factor for a given magnetic ion and charge state. When passed to intensities, it rescales structure factor intensities based on the magnitude of the scattering vector ğª. The default length unit is â„«. If lattice_vectors for the relevant Crystal have a different unit, then that length symbol must be specified here (cf. Units).\n\nThe parameter ion must be one of the following strings:\n\nAm2, Am3, Am4, Am5, Am6, Am7, Au1, Au2, Au3, Au4, Au5, Ce2, Ce3, Co0, Co1, Co2,\nCo3, Co4, Cr0, Cr1, Cr2, Cr3, Cr4, Cu0, Cu1, Cu2, Cu3, Cu4, Dy2, Dy3, Er2, Er3,\nEu2, Eu3, Fe0, Fe1, Fe2, Fe3, Fe4, Gd2, Gd3, Hf2, Hf3, Ho2, Ho3, Ir0a, Ir0b,\nIr0c, Ir1a, Ir1b, Ir2, Ir3, Ir4, Ir5, Ir6, Mn0, Mn1, Mn2, Mn3, Mn4, Mn5, Mo0,\nMo1, Nb0, Nb1, Nd2, Nd3, Ni0, Ni1, Ni2, Ni3, Ni4, Np3, Np4, Np5, Np6, Os0a,\nOs0b, Os0c, Os1a, Os1b, Os2, Os3, Os4, Os5, Os6, Os7, Pd0, Pd1, Pr3, Pt1, Pt2,\nPt3, Pt4, Pt5, Pt6, Pu3, Pu4, Pu5, Pu6, Re0a, Re0b, Re0c, Re1a, Re1b, Re2, Re3,\nRe4, Re5, Re6, Rh0, Rh1, Ru0, Ru1, Sc0, Sc1, Sc2, Sm2, Sm3, Ta2, Ta3, Ta4, Tb2,\nTb3, Tc0, Tc1, Ti0, Ti1, Ti2, Ti3, Tm2, Tm3, U3, U4, U5, V0, V1, V2, V3, V4,\nW0a, W0b, W0c, W1a, W1b, W2c, W3, W4, W5, Y0, Yb2, Yb3, Zr0, Zr1\n\nThe trailing number denotes ionization state. For example, \"Fe0\" denotes a neutral iron atom, while \"Fe2\" denotes FeÂ²âº. If multiple electronic configurations are possible, they will be distinguished by a trailing letter (a, b, ...). Omitting this letter will print an informative error,\n\nFormFactor(\"Ir0\")\n\nERROR: Disambiguate form factor according to electronic configuration:\n    \"Ir0a\" -- 6sâ°5dâ¹\n    \"Ir0b\" -- 6sÂ¹5dâ¸\n    \"Ir0c\" -- 6sÂ²5dâ·\n\nIn the dipolar approximation (small ğª) the form factor is\n\nF(s) = j_0(s) + (2-g)g j_2(s),\n\ninvolving s = ğª4Ï€ and the LandÃ© g-factor. The j_l(s) are radial averages of the lth spherical Bessel function of the magnetic dipole. More details are provided in Ref. [1].\n\nThe standard approximation tables involve expansion in Gaussians,\n\nj_0(s) = A e^-as^2 + B e^-bs^2 + C e^-cs^2 + D e^-ds^2 + E\n\nand\n\nj_2(s) = (A e^-as^2 + B e^-bs^2 + C e^-cs^2 + D e^-ds^2 + E) s^2\n\nSunny uses form factor tables as documented in the McPhase package [1]. For 3d and 4d transition atoms and ions, rare-earth ions (4f), and actinide ions (5f), the coefficients follow the Neutron Data Booklet [2]. The fit for CeÂ³âº follows Lisher and Forsyth [3]. Additional 5d transition elements (Hf-Au) follow Kobayashi, Nagao, and Ito [4].\n\nTwo special, ğª-independent form factor values are available: one(FormFactor) and zero(FormFactor). The first idealizes the magnetic ion as a perfect point particle, while the second zeros all contributions from the magnetic ion.\n\nReferences\n\nCoefficient tables in McPhase documentation.\nP. J. Brown, The Neutron Data Booklet, 2nd ed., Sec. 2.5 Magnetic Form Factors (2003).\nLisher and Forsyth, Analytic approximations to form factors, Acta Cryst. A 27, 545-549 (1971).\nK. Kobayashi, T. Nagao, M. Ito, Radial integrals for the magnetic form factor of 5d transition elements, Acta Cryst. A 67, 473â€“480 (2011).\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.ImplicitMidpoint","page":"Library Reference","title":"Sunny.ImplicitMidpoint","text":"ImplicitMidpoint(dt::Float64; tol=1e-12)\n\nThe implicit midpoint method for integrating the Landau-Lifshitz spin dynamics or its generalization to SU(N) coherent states [1]. One call to the step! function will advance a System by dt units of time. This integration scheme is exactly symplectic and eliminates energy drift over arbitrarily long simulation trajectories.\n\nReferences\n\nH. Zhang and C. D. Batista, Classical spin dynamics based on SU(N) coherent states, Phys. Rev. B 104, 104409 (2021).\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.Langevin","page":"Library Reference","title":"Sunny.Langevin","text":"Langevin(dt::Float64; damping::Float64, kT::Float64)\n\nAn integrator for Langevin spin dynamics using the explicit Heun method. The damping parameter controls the coupling to an implicit thermal bath. One call to the step! function will advance a System by dt units of time. Can be used to sample from the Boltzmann distribution at temperature kT. An alternative approach to sampling states from thermal equilibrium is LocalSampler, which proposes local Monte Carlo moves. For example, use LocalSampler instead of Langevin to sample Ising-like spins.\n\nSetting damping = 0 disables coupling to the thermal bath, yielding an energy-conserving spin dynamics. The Langevin integrator uses an explicit numerical integrator which cannot prevent energy drift. Alternatively, the ImplicitMidpoint method can be used, which is more expensive but prevents energy drift through exact conservation of the symplectic 2-form.\n\nIf the System has mode = :dipole, then the dynamics is the stochastic Landau-Lifshitz equation,\n\n    dğ’dt = -ğ’  (Î¾ - ğ + Î» ğ’  ğ)\n\nwhere ğ = -dEdğ’ is the effective field felt by the expected spin dipole ğ’. The components of Î¾ are Gaussian white noise, with magnitude (2 k_B T Î») set by a fluctuation-dissipation theorem. The parameter damping sets the phenomenological coupling Î» to the thermal bath.\n\nIf the System has mode = :SUN, then this dynamics generalizes [1] to a stochastic nonlinear SchrÃ¶dinger equation for SU(N) coherent states ğ™,\n\n    dğ™dt = -i P Î¶ + (1 - i Î») â„‹ ğ™\n\nHere, P projects onto the space orthogonal to ğ™, and Î¶ denotes complex Gaussian white noise with magnitude (2 k_B T Î»). The local-Hamiltonian â„‹ embeds the energy gradient into the ğ”°ğ”²(N) Lie algebra, and generates evolution of spin dipoles, quadrupoles, etc. The parameter damping here sets Î», which is analogous to Î» above.\n\nWhen applied to SU(2) coherent states, the generalized spin dynamics reduces exactly to the stochastic Landau-Lifshitz equation. The mapping is as follows. Normalized coherent states ğ™ map to dipole expectation values ğ’ = ğ™^ S ğ™, where spin operators S are a spin-ğ’ representation of SU(2). The local effective Hamiltonian â„‹ = -ğ  S generates rotation of the dipole in analogy to the vector cross product S  ğ. The coupling to the thermal bath maps as Î» = ğ’ Î». Note, therefore, that the scaling of the damping parameter varies subtly between :dipole and :SUN modes.\n\nReferences\n\nD. Dahlbom et al., Langevin dynamics of generalized spins as SU(N) coherent states, Phys. Rev. B 106, 235154 (2022).\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.LocalSampler","page":"Library Reference","title":"Sunny.LocalSampler","text":"LocalSampler(; kT, nsweeps=1.0, propose=propose_uniform)\n\nMonte Carlo simulation involving Metropolis updates to individual spins. One call to the step! function will perform nsweeps of MCMC sampling for a provided System. The default value of 1.0 means that step! performs, on average, one trial update per spin.\n\nAssuming ergodicity, the LocalSampler will sample from thermal equilibrium for the target temperature kT. \n\nThe trial spin updates are sampled using the propose function. Options include propose_uniform, propose_flip, and propose_delta. Multiple proposals can be mixed with the macro @mix_proposals.\n\nThe returned object stores fields Î”E and Î”S, which represent the cumulative change to the net energy and dipole, respectively.\n\nwarning: Efficiency considerations\nPrefer Langevin sampling in most cases. Langevin dynamics will usually be much more efficient for sampling Heisenberg-like spins that vary continuously. LocalSampler is most useful for sampling from discrete spin states. In particular, propose_flip may be required for sampling Ising-like spins that arise due to a strong easy-axis anisotropy. For strong but finite single-ion anisotropy, consider alternating between Langevin and LocalSampler update steps.\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.Moment","page":"Library Reference","title":"Sunny.Moment","text":"Moment(; s, g)\n\nCharacterizes a effective spin magnetic moment on an atom. Quantum spin-s is a multiple of 1/2 in units of Ä§. The g-factor or tensor defines the magnetic_moment Î¼ = - g ğ’ in units of the Bohr magneton.\n\nExample\n\nMoment(s=3/2, g=2)\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.SampledCorrelations","page":"Library Reference","title":"Sunny.SampledCorrelations","text":"SampledCorrelations(sys::System; measure, energies, dt)\n\nAn object to accumulate samples of dynamical pair correlations. The measure argument specifies a pair correlation type, e.g. ssf_perp. The energies must be evenly-spaced and starting from 0, e.g. energies = range(0, 3, 100). Select the integration time-step dt according to accuracy and speed considerations. suggest_timestep can help in selecting an appropriate value.\n\nDynamical correlations will be accumulated through calls to add_sample!, which expects a spin configuration in thermal equilibrium. A classical spin dynamics trajectory will be simulated of sufficient length to achieve the target energy resolution. The resulting data can can then be extracted as pair-correlation intensities with appropriate classical-to-quantum correction factors. See also intensities_static, which integrates over energy.\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.SampledCorrelationsStatic","page":"Library Reference","title":"Sunny.SampledCorrelationsStatic","text":"SampledCorrelationsStatic(sys::System; measure)\n\nAn object to accumulate samples of static pair correlations. It is similar to SampledCorrelations, but no time-integration will be performed on calls to add_sample!. The resulting object can be used with intensities_static to calculate statistics from the classical Boltzmann distribution. Dynamical intensities data, however, will be unavailable. Similarly, classical-to-quantum corrections that rely on the excitation spectrum cannot be performed.\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.SCGA","page":"Library Reference","title":"Sunny.SCGA","text":"SCGA(sys::System; measure, kT, dq)\n\nConstructs an object to calculate intensities_static within the self-consistent Gaussian approximation (SCGA). This theory assumes a classical Boltzmann distribution with temperature kT. It is expected to be meaningful above the ordering temperature, where fluctuations are approximately Gaussian.\n\nOnly :dipole and :dipole_uncorrected system modes are supported.\n\nThe theory of SCGA approximates local spin magnitude constraints with a weaker global constraint condition. For each spin sublattice, the global spin sum rule can be expressed as an integral over the unit cube ğª  01^3 for wavevectors ğª in reciprocal lattice units (RLU). Each such integral will be approximated as a discrete sum over a regular grid of floor(1/dq)^3 wavevectors for the provided dq value.\n\nIf the conventional crystal cell admits a smaller primitive cell, then the SCGA calculations can be accelerated. Construct a smaller system with reshape_supercell and primitive_cell. In this case, the discretized ğª-point grid runs over the full Brillouin zone associated with the primitive cell of the crystal.\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.Site","page":"Library Reference","title":"Sunny.Site","text":"(cell1, cell2, cell3, i) :: Site\n\nFour indices identifying a single site in a System. The first three indices select the unit cell and the last index selects the sublattice, i.e., the ith atom within the unit cell.\n\nThis object can be used to index dipoles and coherents fields of a System. A Site is also required to specify inhomogeneous interactions via functions such as set_field_at! or set_exchange_at!.\n\nNote that the definition of a cell may change when a system is reshaped. In this case, it is convenient to construct the Site using position_to_site, which always takes a position in fractional coordinates of the original lattice vectors.\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.SpinWaveTheory","page":"Library Reference","title":"Sunny.SpinWaveTheory","text":"SpinWaveTheory(sys::System; measure, regularization=1e-8)\n\nConstructs an object to perform linear spin wave theory. The measure object specifies observable fields, ğª-dependent contractions, and form factors. Common choices are ssf_perp, ssf_trace, and ssf_custom. The resulting SpinWaveTheory object can be used to calculate intensities_bands and broadened intensities. If measure=nothing, it is still possible to calculate the dispersion curves. Eigenvectors describing the Bogoliubov bosons are available in excitations.\n\nThe magnetic structure in sys must be energy minimized, otherwise the Cholesky step of the Bogoliubov diagonalization procedure will fail. The parameter regularization adds a small positive shift to the diagonal of the dynamical matrix to avoid numerical issues with quasi-particle modes of vanishing energy. Physically, this shift can be interpreted as application of an inhomogeneous field aligned with the magnetic ordering.\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.SpinWaveTheoryKPM","page":"Library Reference","title":"Sunny.SpinWaveTheoryKPM","text":"SpinWaveTheoryKPM(sys::System; measure, regularization=1e-8, tol=nothing,\n                  niters=nothing, niters_bounds=10, method=:lanczos)\n\nA variant of SpinWaveTheory that estimates intensities using iterated matrix-vector products. By avoiding direct matrix diagonalization, this method reduces computational cost from cubic to linear-scaling in the system size N. Large system sizes can arise, e.g., for models of quenched disorder or models with nearly incommensurate ordering wavevectors.\n\nComputational cost scales like ğ’ª(N M + M^2). The number of iterations M may be specified directly with the niters parameter. Alternatively, one may specify a dimensionless error tolerance tol such that M â‰ˆ -2 log10(tol) Î”Ïµ / fwhm where Î”Ïµ is the estimated spectral bandwidth of excitations and fwhm is the full width at half maximum of the user-supplied broadening kernel. Common choices for tol are 0.05 (more speed) or 0.01 (more accuracy). Either tol or niters is required. The parameter niters_bounds selects the Krylov subspace dimension to be used for estimating spectral bounds.\n\nwarning: Accuracy considerations\nEnergy-space resolution scales inversely with the number M of iterations. Such broadening errors can usually be well controlled via the tolerance parameter tol. A more serious problem is intensity loss at bands with small excitation energy, e.g., in the viscinity of Goldstone modes. In certain cases this missing intensity will be due to numerical roundoff error that cannot be fixed by increasing the number of iterations M.\n\nTwo method options are available, :lanczos and :kpm.  Lanczos is generally preferred, as it achieves near-optimal accuracy for a given number of iterations [1, 2]. The Lanczos implementation builds on earlier research using the Kernel Polynomial Method [3], which may be of historical interest.\n\nReferences\n\nT. Chen, The Lanczos algorithm for matrix functions: a handbook for scientists (2024) [arXiv:2410.11090].\nN. Amsel, T. Chen, A. Greenbaum, C. Musco, C. Musco, Near-Optimal Approximation of Matrix Functions by the Lanczos Method (2023) [arXiv:2303.03358].\nH. Lane et al., Kernel Polynomial Method for Linear Spin Wave Theory (2023) [arXiv:2312.08349].\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.SpinWaveTheorySpiral","page":"Library Reference","title":"Sunny.SpinWaveTheorySpiral","text":"SpinWaveTheorySpiral(sys::System; k, axis, measure, regularization=1e-8)\n\nAnalogous to SpinWaveTheory, but interprets the provided system as having a generalized spiral order. This order is described by a single propagation wavevector k (in reciprocal lattice units, RLU) an axis vector that is normal to the polarization plane (in global Cartesian coordinates). Typically the spin configuration in sys and the propagation wavevector k will be optimized using minimize_spiral_energy!. In contrast, axis will typically be determined from symmetry considerations.\n\nThe resulting object can be used to calculate the spin wave dispersion, or the structure factor via intensities_bands and intensities.\n\nThe algorithm for this calculation was developed in Toth and Lake, J. Phys.: Condens. Matter 27, 166002 (2015) and implemented in the SpinW code.\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.System","page":"Library Reference","title":"Sunny.System","text":"System(crystal::Crystal, moments, mode; dims=(1, 1, 1), seed=nothing)\n\nA spin system is constructed from the Crystal unit cell, a specification of the spin moments symmetry-distinct sites, and a calculation mode. Interactions can be added to the system using, e.g., set_exchange!. The default supercell dimensions are 1Ã—1Ã—1 chemical cells, but this can be changed with dims.\n\nSpin moments comprise a list of pairs, [i1 => Moment(...), i2 => ...], where i1, i2, ... are a complete set of symmetry-distinct atoms. Each Moment contains spin and g-factor information.\n\nThe two primary options for mode are :SUN and :dipole. In the former, each spin-s degree of freedom is described as an SU(N) coherent state, i.e. a quantum superposition of N = 2s + 1 levels. This formalism can be useful to capture multipolar spin fluctuations or local entanglement effects. \n\nMode :dipole projects the SU(N) dynamics onto the restricted space of pure dipoles. In practice this means that Sunny will simulate Landau-Lifshitz dynamics, but single-ion anisotropy and biquadratic exchange interactions will be renormalized to improve accuracy. To disable this renormalization, use the mode :dipole_uncorrected, which corresponds to the formal s   limit. For details, see the documentation page: Interaction Renormalization.\n\nStochastic operations on this system can be made reproducible by selecting a seed for this system's pseudo-random number generator. The default system seed will be generated from Julia's task-local RNG, which can itself be seeded using Random.seed!.\n\nAll spins are initially polarized in the global z-direction.\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.Units","page":"Library Reference","title":"Sunny.Units","text":"Units(energy, length)\n\nPhysical constants in units of reference energy and length scales. Possible lengths are [:angstrom, :nm]. For atomic scale modeling, it is preferable to work in units of length=:angstrom, which follows the CIF file standard. Possible energy units are [:meV, :K, :THz, :inverse_cm, :T]. Kelvin is converted to energy via the Boltzmann constant k_B. Similarly, hertz is converted via the Planck constant h, inverse cm via the speed of light c, and tesla (field strength) via the Bohr magneton Î¼_B. For a given Units system, one can access any of the length and energy scale symbols listed above.\n\nExamples\n\n# Unit system with [energy] = meV and [length] = â„«\nunits = Units(:meV, :angstrom)\n\n# Use the Boltzmann constant kB to convert 1 kelvin into meV\n@assert units.K â‰ˆ 0.0861733326\n\n# Use the Planck constant h to convert 1 THz into meV\n@assert units.THz â‰ˆ 4.135667696\n\n# Use the constant h c to convert 1 cmâ»Â¹ into meV\n@assert units.inverse_cm â‰ˆ 0.1239841984\n\n# Use the Bohr magneton Î¼B to convert 1 tesla into meV\n@assert units.T â‰ˆ 0.05788381806\n\n# The physical constant Î¼0 Î¼BÂ² in units of â„«Â³ meV.\n@assert u.vacuum_permeability â‰ˆ 0.6745817653\n\n\n\n\n\n","category":"type"},{"location":"library.html#Sunny.add_sample!","page":"Library Reference","title":"Sunny.add_sample!","text":"add_sample!(sc::SampledCorrelations, sys::System)\nadd_sample!(sc::SampledCorrelationsStatic, sys::System)\n\nMeasure pair correlation data for the spin configuration in sys, and accumulate these statistics into sc. For a dynamical SampledCorrelations, this involves time-integration of the provided spin trajectory, recording correlations in both space and time. Conversely, SampledCorrelationsStatic, will record only spatial correlations for the single spin configuration that is provided.\n\nTime-integration will update the spin configuration of sys in-place. To avoid this mutation, consider calling clone_system prior to add_sample!.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.clone_correlations","page":"Library Reference","title":"Sunny.clone_correlations","text":"clone_correlations(sc::SampledCorrelations)\n\nCreate a copy of a SampledCorrelations.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.clone_system","page":"Library Reference","title":"Sunny.clone_system","text":"clone_system(sys::System)\n\nCreates a full clone of the system, such that mutable updates to one copy will not affect the other, and thread safety is guaranteed.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.dispersion","page":"Library Reference","title":"Sunny.dispersion","text":"dispersion(swt::SpinWaveTheory, qpts)\n\nGiven a list of wavevectors qpts in reciprocal lattice units (RLU), returns excitation energies for each band. The return value ret is 2D array, and should be indexed as ret[band_index, q_index].\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.dmvec","page":"Library Reference","title":"Sunny.dmvec","text":"dmvec(D)\n\nAntisymmetric matrix representation of the Dzyaloshinskii-Moriya pseudo-vector,\n\n  [  0    D[3] -D[2]\n   -D[3]   0    D[1]\n    D[2] -D[1]   0  ]\n\nBy construction, Si'*dmvec(D)*Sj â‰ˆ Dâ‹…(SiÃ—Sj) for any dipoles Si and Sj. This helper function is intended for use with set_exchange!.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.domain_average","page":"Library Reference","title":"Sunny.domain_average","text":"domain_average(f, cryst, qpts; rotations, weights)\n\nCalculate an average intensity for the reciprocal-space points qpts under a discrete set of rotations. Rotations, in global coordinates, may be given either as an axis-angle pair or as a 3Ã—3 rotation matrix. Each rotation is weighted according to the elements in weights. The function f should accept a list of rotated q-points and return an intensities calculation.\n\nExample\n\n# 0, 120, and 240 degree rotations about the global z-axis\nrotations = [([0,0,1], n*(2Ï€/3)) for n in 0:2]\nweights = [1, 1, 1]\nres = domain_average(cryst, path; rotations, weights) do path_rotated\n    intensities(swt, path_rotated; energies, kernel)\nend\nplot_intensities(res)\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.eachsite","page":"Library Reference","title":"Sunny.eachsite","text":"eachsite(sys::System)\n\nAn iterator over all Sites in the system.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.enable_dipole_dipole!","page":"Library Reference","title":"Sunny.enable_dipole_dipole!","text":"enable_dipole_dipole!(sys::System, Î¼0_Î¼BÂ²; demag=1/3)\n\nEnables long-range interactions between magnetic dipole moments,\n\n    -(Î¼_04Ï€) _ij  3 (Î¼_iğ«_ij)(Î¼_jğ«_ij) - Î¼_iÎ¼_j  r_ij^3\n\nwhere the sum is over all pairs of sites (singly counted), including periodic images. Each magnetic moment is Î¼_i = -g Î¼_B ğ’_i, where ğ’_i is the spin angular momentum dipole. The parameter Î¼0_Î¼BÂ² specifies the physical constant Î¼_0 Î¼_B^2, which has dimensions of lengthÂ³-energy. Obtain this constant for a given system of Units via its vacuum_permeability property.\n\nGeometry of the macroscopic sample enters through the demagnetization factor or tensor demag. Special cases are:\n\ndemag = 1/3 for isotropic demagnetization. This is the default and is valid for sphere and cube sample geometries.\ndemag = Diagonal([0, 0, 1]) for a sheet-like geometry with surface normal in z.\ndemag = Diagonal([1/2, 1/2, 0]) for a needle-like geometry aligned with z.\n\nIn a vacuum background, the demagnetization tensor should have trace 1. Set demag = 0 to artificially neglect demagnetization effects.\n\nExample\n\nunits = Units(:meV, :angstrom)\nenable_dipole_dipole!(sys, units.vacuum_permeability)\n\nSee also modify_exchange_with_truncated_dipole_dipole!.\n\ntip: Demagnetization details\nFormal summation over the infinitely many dipole-dipole pair interactions becomes mathematically ambiguous when the macroscopic sample has a nonzero net magnetic moment, ğŒ = _i Î¼_i. The traditional Ewald method resolves this ambiguity by neglecting surface effects that would lead to demagnetization. For physical correctness, however, the Ewald energy must be augmented with a surface energy term,    E_mathrmsurf = fracÎ¼_02V ğŒmathcalN ğŒwhere mathcalN is the demagnetization tensor (demag). Assuming vacuum background, it can be expressed as an integral over the sample volume V,    mathcalN^Î±Î² = - frac14Ï€ _V dğ± ^Î± ^Î² ğ±^-1Note that mathcalN has trace 1 because ^2ğ±^-1 = -4Ï€Î´(ğ±) when the integration domain contains the origin.This surface correction to the Ewald energy originally appeared in S. de Leeuw, J. Perram, and E. Smith, Proc. R. Soc. London A 373, 27 (1980); 373, 57 (1980); 388, 177 (1983). For a pedagogical review, see V. Ballenegger, J. Chem. Phys. 140, 161102 (2014).If the sample is embedded in another material, the surface correction E_mathrmsurf still applies, but mathcalN should be calculated differently. For example, a spherical inclusion generally has mathcalN = 1(2Î¼+1)  13 where Î¼  1 denotes the relative permeability of the background medium.\n\ntip: Efficiency considerations\nDipole-dipole interactions are very efficient in the context of spin dynamics simulation, e.g. Langevin. Sunny applies the fast Fourier transform (FFT) to spins on each Bravais sublattice, such that the computational cost to integrate one time-step scales like M^2 N ln N, where N is the number of cells in the system and M is the number of Bravais sublattices per cell. Conversely, dipole-dipole interactions are highly inefficient in the context of a LocalSampler. Each Monte Carlo update of a single spin currently requires scanning over all other spins in the system.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.energy","page":"Library Reference","title":"Sunny.energy","text":"energy(sys::System)\n\nThe total system energy. See also energy_per_site.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.energy_per_site","page":"Library Reference","title":"Sunny.energy_per_site","text":"energy_per_site(sys::System)\n\nThe total system energy divided by the number of sites.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.excitations","page":"Library Reference","title":"Sunny.excitations","text":"excitations(swt::SpinWaveTheory, q)\nexcitations(swt::SpinWaveTheorySpiral, q; branch)\n\nReturns a pair (energies, T) providing the excitation energies and eigenvectors. Prefer excitations! for performance, which avoids matrix allocations. See the documentation of excitations! for more details.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.excitations!","page":"Library Reference","title":"Sunny.excitations!","text":"excitations!(T, tmp, swt::SpinWaveTheory, q)\n\nGiven a wavevector q, solves for the matrix T representing quasi-particle excitations, and returns a list of quasi-particle energies. Both T and tmp must be supplied as 2L2L complex matrices, where L is the number of bands for a single ğª value.\n\nThe columns of T are understood to be contracted with the Holstein-Primakoff bosons ğ›_ğª ğ›_-ğª^. The first L columns provide the eigenvectors of the quadratic Hamiltonian for the wavevector ğª. The next L columns of T describe eigenvectors for -ğª. The return value is a vector with similar grouping: the first L values are energies for ğª, and the next L values are the negation of energies for -ğª.\n\nexcitations!(T, tmp, swt::SpinWaveTheorySpiral, q; branch)\n\nCalculations on a SpinWaveTheorySpiral additionally require a branch index. The possible branches (1 2 3) correspond to scattering processes ğª - ğ¤ ğª ğª + ğ¤ respectively, where ğ¤ is the ordering wavevector. Each branch will contribute L excitations, where L is the number of spins in the magnetic cell. This yields a total of 3L excitations for a given momentum transfer ğª.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.gaussian","page":"Library Reference","title":"Sunny.gaussian","text":"gaussian(; {fwhm, Ïƒ})\n\nReturns the function exp(-x^2/2Ïƒ^2) / âˆš(2Ï€*Ïƒ^2). Either fwhm or Ïƒ must be specified, where fwhm = (2.355...) * Ïƒ is the full width at half maximum.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.global_position","page":"Library Reference","title":"Sunny.global_position","text":"global_position(sys::System, site::Site)\n\nPosition of a Site in global coordinates.\n\nTo precompute a full list of positions, one can use eachsite as below:\n\npos = [global_position(sys, site) for site in eachsite(sys)]\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.intensities","page":"Library Reference","title":"Sunny.intensities","text":"intensities(swt::SpinWaveTheory, qpts; energies, kernel, kT=0)\nintensities(sc::SampledCorrelations, qpts; energies, kernel=nothing, kT)\n\nCalculates dynamical pair correlation intensities for a set of ğª-points in reciprocal space.\n\nLinear spin wave theory calculations are performed with an instance of SpinWaveTheory. The alternative SpinWaveTheorySpiral allows to study generalized spiral orders with a single, incommensurate-ğ¤ ordering wavevector. Another alternative SpinWaveTheoryKPM is favorable for calculations on large magnetic cells, and allows to study systems with disorder. An optional nonzero temperature kT will scale intensities by the quantum thermal occupation factor 1 + n_B(Ï‰) where n_B(Ï‰) = 1(e^Î²Ï‰-1) is the Bose function.\n\nIntensities can also be calculated for SampledCorrelations associated with classical spin dynamics. In this case, thermal broadening will already be present, and the line-broadening kernel becomes optional. Conversely, the parameter kT becomes required. If positive, it will introduce an intensity correction factor Î²Ï‰ (1 + n_B(Ï‰)) that undoes the occupation factor for the classical Boltzmann distribution and applies the quantum thermal occupation factor. The special choice kT = nothing will suppress the classical-to-quantum correction factor, and yield statistics consistent with the classical Boltzmann distribution.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.intensities_bands","page":"Library Reference","title":"Sunny.intensities_bands","text":"intensities_bands(swt::SpinWaveTheory, qpts; kT=0)\n\nCalculate spin wave excitation bands for a set of q-points in reciprocal space. This calculation is analogous to intensities, but does not perform line broadening of the bands.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.intensities_static","page":"Library Reference","title":"Sunny.intensities_static","text":"intensities_static(swt::SpinWaveTheory, qpts; bounds=(-Inf, Inf), kernel=nothing, kT=0)\nintensities_static(sc::SampledCorrelations, qpts; bounds=(-Inf, Inf), kT)\nintensities_static(sc::SampledCorrelationsStatic, qpts)\n\nLike intensities, but integrates the dynamical correlations mathcalS(ğª Ï‰) over a range of energies Ï‰. By default, the integration bounds are (- ), yielding the instantaneous (equal-time) correlations.\n\nIn SpinWaveTheory, the integral will be realized as a sum over discrete bands. Alternative calculation methods are SpinWaveTheorySpiral and SpinWaveTheoryKPM.\n\nClassical dynamics data in SampledCorrelations can also be used to calculate static intensities. In this case, the domain of integration will be a finite grid of available energies. Here, the parameter kT will be used to account for the quantum thermal occupation of excitations, as documented in intensities.\n\nStatic intensities calculated from SampledCorrelationsStatic are dynamics-independent. Instead, instantaneous correlations sampled from the classical Boltzmann distribution will be reported.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.lattice_params","page":"Library Reference","title":"Sunny.lattice_params","text":"lattice_params(latvecs)\n\nCompute the lattice parameters (a b c Î± Î² Î³) for the three lattice vectors provided as columns of latvecs. The inverse mapping is lattice_vectors.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.lattice_vectors","page":"Library Reference","title":"Sunny.lattice_vectors","text":"lattice_vectors(a, b, c, Î±, Î², Î³)\n\nReturn the lattice vectors, as columns of the 33 output matrix, that define the shape of a crystallographic cell in global Cartesian coordinates. Conversely, one can view the output matrix as defining the global Cartesian coordinate system with respect to the lattice system.\n\nThe lattice constants (a b c) have units of length, and the angles (Î± Î² Î³) are in degrees. The inverse mapping is lattice_params.\n\nExample\n\nlatvecs = lattice_vectors(1, 1, 2, 90, 90, 120)\na1, a2, a3 = eachcol(latvecs)\n@assert a1 â‰ˆ [1, 0, 0]       # a1 always aligned with global x\n@assert a2 â‰ˆ [-1/2, âˆš3/2, 0] # a2 always in global (x,y) plane\n@assert a3 â‰ˆ [0, 0, 2]       # a3 may generally be a combination of (x,y,z)\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.load_nxs","page":"Library Reference","title":"Sunny.load_nxs","text":"params, signal = load_nxs(filename; field=\"signal\")\n\nGiven the name of a Mantid-exported MDHistoWorkspace file, load the BinningParameters and the signal from that file.\n\nTo load another field instead of the signal, specify e.g. field=\"errors_squared\". Typical fields include errors_squared, mask, num_events, and signal.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.lorentzian","page":"Library Reference","title":"Sunny.lorentzian","text":"lorentzian(; fwhm)\n\nReturns the function (Î“/2) / (Ï€*(x^2+(Î“/2)^2)) where Î“ = fwhm is the full width at half maximum.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.magnetic_moment","page":"Library Reference","title":"Sunny.magnetic_moment","text":"magnetic_moment(sys::System, site::Site)\n\nReturns - g ğ’, the local magnetic moment in units of the Bohr magneton. The spin dipole ğ’ and g-tensor may both be Site dependent.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.merge_correlations","page":"Library Reference","title":"Sunny.merge_correlations","text":"merge_correlations(scs::Vector{SampledCorrelations)\n\nAccumulate a list of SampledCorrelations into a single, summary SampledCorrelations. Useful for reducing the results of parallel computations.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.minimize_energy!","page":"Library Reference","title":"Sunny.minimize_energy!","text":"minimize_energy!(sys::System; maxiters=1000, kwargs...)\n\nOptimizes the spin configuration in sys to minimize energy. A total of maxiters iterations will be attempted. Any remaining kwargs will be included in the Options constructor of the Optim.jl package\n\nConvergence status is stored in the field ret.converged of the return value ret. Additional optimization statistics are stored in the field ret.data.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.minimize_spiral_energy!","page":"Library Reference","title":"Sunny.minimize_spiral_energy!","text":"minimize_spiral_energy!(sys, axis; maxiters=10_000, k_guess=randn(sys.rng, 3))\n\nFinds a generalized spiral order that minimizes the spiral_energy. This involves optimization of the spin configuration in sys, and the propagation wavevector ğ¤, which will be returned in reciprocal lattice units (RLU). The axis vector normal to the polarization plane cannot yet be optimized; it should be determined according to symmetry considerations and provided in global Cartesian coordinates. The initial k_guess will be random, unless otherwise provided.\n\nSee also suggest_magnetic_supercell to find a system shape that is approximately commensurate with the returned propagation wavevector ğ¤.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.modify_exchange_with_truncated_dipole_dipole!","page":"Library Reference","title":"Sunny.modify_exchange_with_truncated_dipole_dipole!","text":"modify_exchange_with_truncated_dipole_dipole!(sys::System, cutoff, Î¼0_Î¼BÂ²)\n\nLike enable_dipole_dipole!, the purpose of this function is to introduce long-range dipole-dipole interactions between magnetic moments. Whereas enable_dipole_dipole! employs Ewald summation, this function instead employs real-space pair couplings with truncation at the specified cutoff distance. The implicit demagnetization factor is 1/3, as appropriate for a spherical sample in vacuum. If the cutoff is relatively small, then this function may be faster than enable_dipole_dipole!.\n\nwarning: Mutation of existing couplings\nThis function will modify existing bilinear couplings between spins by adding dipole-dipole interactions. It must therefore be called after all other pair couplings have been specified. Conversely, any calls to set_exchange!, set_pair_coupling!, etc. will irreversibly delete the dipole-dipole interactions that have been introduced by this function.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.polarize_spins!","page":"Library Reference","title":"Sunny.polarize_spins!","text":"polarize_spins!(sys::System, dir)\n\nPolarize all spin dipoles in the direction dir.\n\nIn the common case where the g-factor is scalar, this corresponds to aligning all magnetic_moment dipoles in the direction opposite to dir.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.position_to_site","page":"Library Reference","title":"Sunny.position_to_site","text":"position_to_site(sys::System, r)\n\nConverts a position r to four indices of a Site. The coordinates of r are given in units of the lattice vectors for the original crystal. This function can be useful for working with systems that have been reshaped using reshape_supercell.\n\nExample\n\n# Find the `site` at the center of a unit cell which is displaced by four\n# multiples of the first lattice vector\nsite = position_to_site(sys, [4.5, 0.5, 0.5])\n\n# Print the dipole at this site\nprintln(sys.dipoles[site])\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.powder_average","page":"Library Reference","title":"Sunny.powder_average","text":"powder_average(f, cryst, radii, n; seed=0)\n\nCalculate a powder-average over structure factor intensities. The radii, with units of inverse length, define spherical shells in reciprocal space. The Fibonacci lattice yields n points on the sphere, with quasi-uniformity. Sample points on different shells are decorrelated through random rotations. A consistent random number seed will yield reproducible results. The function f should accept a list of q-points and call intensities or intensities_static.\n\nExample\n\nradii = range(0.0, 3.0, 200)\nres = powder_average(cryst, radii, 500) do qs\n    intensities(swt, qs; energies, kernel)\nend\nplot_intensities(res)\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.primitive_cell","page":"Library Reference","title":"Sunny.primitive_cell","text":"primitive_cell(cryst)\n\nThe shape of a primitive cell in multiples of the lattice vectors for cryst. Specifically, columns of cryst.latvecs * primitive(cryst) define the primitive lattice vectors in global Cartesian coordinates. Returns nothing if spacegroup setting information is missing.\n\nThis function may be useful for constructing inputs to reshape_supercell.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.print_bond","page":"Library Reference","title":"Sunny.print_bond","text":"print_bond(cryst::Crystal, b::Bond; b_ref=b)\n\nPrints symmetry information for bond b. An optional symmetry-equivalent reference bond b_ref can be provided to keep a consistent meaning of the free parameters A, B, etc.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.print_irreducible_bz_paths","page":"Library Reference","title":"Sunny.print_irreducible_bz_paths","text":"print_irreducible_bz_paths(cryst::Crystal)\n\nPrints certain high-symmetry points with suggested paths between them. The points lie in the irreducible Brillouin, which is reduced from the first Brillouin zone by the point group symmetries of the crystal. Coordinates are printed in reciprocal lattice units (RLU), i.e., as multiples of the conventional lattice vectors of cryst. These high-symmetry paths were originally formulated in Ref. [1] and implemented in SeeK-path. Sunny obtains this functionality from the Brillouin.jl package.\n\nSee also view_bz for an interactive visualization of these high-symmetry paths.\n\nReferences\n\nY. Hinuma, G. Pizzi, Y. Kumagai, F. Oba, I. Tanaka, Band structure diagram paths based on crystallography, Comp. Mat. Sci. 128, 140 (2017).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.print_site","page":"Library Reference","title":"Sunny.print_site","text":"print_site(cryst, i; i_ref=i, R=I)\n\nPrint symmetry information for the site i, including allowed g-tensor and allowed anisotropy operator.  An optional symmetry-equivalent reference atom i_ref can be provided to keep a consistent meaning of the free parameters. An optional rotation matrix R can map to a new Cartesian reference frame for expression of the allowed anisotropy.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.print_stevens_expansion","page":"Library Reference","title":"Sunny.print_stevens_expansion","text":"function print_stevens_expansion(op)\n\nPrints a local Hermitian operator as a linear combination of Stevens operators. The operator op may be a finite-dimensional matrix or an abstract spin polynomial in the large-s limit.\n\nExamples\n\nS = spin_matrices(2)\nprint_stevens_expansion(S[1]^4 + S[2]^4 + S[3]^4)\n# Prints: (1/20)ğ’ªâ‚„â‚€ + (1/4)ğ’ªâ‚„â‚„ + 102/5\n\nS = spin_matrices(Inf)\nprint_stevens_expansion(S[1]^4 + S[2]^4 + S[3]^4)\n# Prints: (1/20)ğ’ªâ‚„â‚€ + (1/4)ğ’ªâ‚„â‚„ + (3/5)ğ’®â´\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.print_suggested_frame","page":"Library Reference","title":"Sunny.print_suggested_frame","text":"print_suggested_frame(cryst, i)\n\nPrint a suggested reference frame, as a rotation matrix R, that can be used as input to print_site(). The purpose is to simplify the description of allowed anisotropies.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.print_symmetry_table","page":"Library Reference","title":"Sunny.print_symmetry_table","text":"print_symmetry_table(cryst::Crystal, max_dist)\n\nPrint symmetry information for all equivalence classes of sites and bonds, up to a maximum bond distance of max_dist. Equivalent to calling print_bond(cryst, b) for every bond b in reference_bonds(cryst, max_dist), where Bond(i, i, [0,0,0]) refers to a single site i.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.print_wrapped_intensities","page":"Library Reference","title":"Sunny.print_wrapped_intensities","text":"print_wrapped_intensities(sys::System; nmax=10)\n\nFor Bravais lattices: Prints up to nmax wavevectors according to their instantaneous (static) structure factor intensities, listed in descending order. For non-Bravais lattices: Performs the same analysis for each spin sublattice independently; the output weights are naÃ¯vely averaged over sublattices, without incorporating phase shift information. This procedure therefore wraps all wavevectors into the first Brillouin zone. Each wavevector coordinate is given between -12 and 12 in reciprocal lattice units (RLU).  The output from this function will typically be used as input to suggest_magnetic_supercell.\n\nBecause this function does not incorporate phase information in its averaging over sublattices, the printed weights are not directly comparable with experiment. For that purpose, use SampledCorrelationsStatic instead.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.propose_delta","page":"Library Reference","title":"Sunny.propose_delta","text":"propose_delta(magnitude)\n\nGenerate a proposal function that adds a Gaussian perturbation to the existing spin state. In :dipole mode, the procedure is to first introduce a random three-vector perturbation ğ’ = ğ’ + ğ’ Î¾ and then return the properly normalized spin ğ’ (ğ’ğ’). Each component of the random vector Î¾ is Gaussian distributed with a standard deviation of magnitude; the latter is dimensionless and typically smaller than one. \n\nIn :SUN mode, the procedure is analogous, but now involving Gaussian perturbations to each of the N complex components of an SU(N) coherent state.\n\nIn the limit of very large magnitude, this function coincides with propose_uniform.\n\nConsider also Langevin sampling, which is rejection free.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.propose_flip","page":"Library Reference","title":"Sunny.propose_flip","text":"propose_flip\n\nFunction to propose pure spin flip updates in the context of a LocalSampler. Dipoles are flipped as ğ’  -ğ’. SU(N) coherent states are flipped using the time-reversal operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.propose_uniform","page":"Library Reference","title":"Sunny.propose_uniform","text":"propose_uniform\n\nFunction to propose a uniformly random spin update in the context of a LocalSampler. In :dipole mode, the result is a random three-vector with appropriate normalization. In :SUN mode, the result is a random SU(N) coherent state with appropriate normalization.\n\nFor low-temperature Monte Carlo simulations, uniform spin proposals can be very inefficient due to a high probability of rejection in the Metropolis accept/reject step. Consider also Langevin sampling, which is rejection free.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.q_space_grid","page":"Library Reference","title":"Sunny.q_space_grid","text":"q_space_grid(cryst::Crystal, axis1, range1, axis2, range2; offset=[0,0,0], orthogonalize=false)\nq_space_grid(cryst::Crystal, axis1, range1, axis2, range2, axis3, range3; orthogonalize=false)\n\nReturns a 2D or 3D grid of q-points with uniform spacing. The volume shape is defined by (axis1, axis2, ...) in reciprocal lattice units (RLU). Elements of (range1, range2, ...) provide coefficients c_i used to define grid positions,\n\n    offset + c1 * axis1 + c2 * axis2 + ...\n\nA nonzero offset is allowed only in the 2D case. \n\nThe first range parameter, range1, must be a regularly spaced list of coefficients, e.g., range1 = range(lo1, hi1, n). Subsequent range parameters may be a pair of bounds, without grid spacing information. For example, by selecting range2 = (lo2, hi2), an appropriate step-size will be inferred to provide an approximately uniform sampling density in global Cartesian coordinates.\n\nSetting orthogonalize=true will project axis2 and axis3 such that all axes become orthogonal in global Cartesian ğª coordinates.\n\nTo specify a 1D grid, use q_space_path instead.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.q_space_path","page":"Library Reference","title":"Sunny.q_space_path","text":"q_space_path(cryst::Crystal, qs, n; labels=nothing)\n\nReturns a 1D path consisting of n wavevectors sampled piecewise-linearly between the points in qs. Although the qs are provided in reciprocal lattice units (RLU), consecutive samples are spaced uniformly in the global (inverse-length) Cartesian coordinate system. Optional labels can be associated with each special q-point, and will be used in plotting functions.\n\nSee also q_space_grid.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.randomize_spins!","page":"Library Reference","title":"Sunny.randomize_spins!","text":"randomize_spins!(sys::System)\n\nRandomizes all spins under appropriate the uniform distribution.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.reference_bonds","page":"Library Reference","title":"Sunny.reference_bonds","text":"reference_bonds(cryst::Crystal, max_dist)\n\nReturns a full list of bonds, one for each symmetry equivalence class, up to distance max_dist. The reference bond b for each equivalence class is selected according to a scoring system that prioritizes simplification of the elements in basis_for_symmetry_allowed_couplings(cryst, b).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.remove_periodicity!","page":"Library Reference","title":"Sunny.remove_periodicity!","text":"remove_periodicity!(sys::System, flags)\n\nRemove periodic interactions along each dimension d if flags[d] is true. The system must support inhomogeneous interactions via to_inhomogeneous.\n\nExample\n\n# Remove periodic boundaries along the 1st and 3rd dimensions\nremove_periodicity!(sys::System, (true, false, true))\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.repeat_periodically","page":"Library Reference","title":"Sunny.repeat_periodically","text":"repeat_periodically(sys::System, counts::NTuple{3, Int})\n\nCreates a System identical to sys but repeated a given number of times along each system axis according to the specified counts. This is a special case of the more general reshape_supercell.\n\nSee also repeat_periodically_as_spiral, which rotates the spins between periodic copies.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.repeat_periodically_as_spiral","page":"Library Reference","title":"Sunny.repeat_periodically_as_spiral","text":"repeat_periodically_as_spiral(sys::System, counts::NTuple{3, Int}; k, axis)\n\nRepeats the magnetic cell of System a number of times along each system axis according to the specified counts. Spins in each system image will be rotated according to the propagation wavevector k (in RLU) and the rotation axis (in global Cartesian coordinates). Coincides with repeat_periodically in the special case of k = [0, 0, 0]\n\nSee also minimize_spiral_energy! to find an energy-minimizing wavevector k and spin dipole configuration.\n\nExample\n\nk = minimize_spiral_energy!(sys, axis; k_guess=randn(3))\nrepeat_periodically_as_spiral(sys, counts; k, axis)\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.reshape_supercell","page":"Library Reference","title":"Sunny.reshape_supercell","text":"reshape_supercell(sys::System, shape)\n\nMaps an existing System to a new one that has the shape and periodicity of a requested supercell. The columns of the 33 integer matrix shape represent the supercell lattice vectors measured in units of the original crystal lattice vectors. Interactions, spins, and other settings will be inherited from sys.\n\nIn the special case that shape is a diagonal matrix, this function coincides with resize_supercell.\n\nSee also repeat_periodically.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.resize_supercell","page":"Library Reference","title":"Sunny.resize_supercell","text":"resize_supercell(sys::System, dims::NTuple{3, Int})\n\nCreates a System with a given number of conventional unit cells in each lattice vector direction. Interactions, spins, and other settings will be inherited from sys.\n\nEquivalent to:\n\nreshape_supercell(sys, [dims[1] 0 0; 0 dims[2] 0; 0 0 dims[3]])\n\nSee also reshape_supercell and repeat_periodically.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.rotate_operator","page":"Library Reference","title":"Sunny.rotate_operator","text":"rotate_operator(A, R)\n\nRotates the local quantum operator A according to the 33 rotation matrix R.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.set_coherent!","page":"Library Reference","title":"Sunny.set_coherent!","text":"set_coherent!(sys::System, Z, site::Site)\n\nSet a coherent spin state at a Site using the N complex amplitudes in Z.\n\nFor a single quantum spin-s, these amplitudes will be interpreted in the eigenbasis of S^z. That is, Z[1] represents the amplitude for the basis state fully polarized along the z-direction, and subsequent components represent states with decreasing angular momentum along this axis (m = s s-1  -s).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.set_dipole!","page":"Library Reference","title":"Sunny.set_dipole!","text":"set_dipole!(sys::System, dir, site::Site)\n\nPolarize the spin dipole at one Site in the direction dir.\n\nSee also polarize_spins!.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.set_dipoles_from_mcif!","page":"Library Reference","title":"Sunny.set_dipoles_from_mcif!","text":"set_dipoles_from_mcif!(sys::System, filename::AbstractString; symprec=nothing)\n\nLoad the magnetic moments from data in the mCIF at filename.\n\nThe system shape must exactly match the magnetic cell described by the mCIF. If mismatched, an error message will provide instructions for calling reshape_supercell.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.set_exchange!","page":"Library Reference","title":"Sunny.set_exchange!","text":"set_exchange!(sys::System, J, bond::Bond; biquad=0)\n\nSets an exchange interaction ğ’_iJ ğ’_j along the specified bond. This interaction will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous interactions on these bonds will be overwritten. The parameter bond has the form Bond(i, j, offset), where i and j are atom indices within the unit cell, and offset is a displacement in unit cells.\n\nAs a convenience, scalar J can be used to specify a Heisenberg interaction. Also, the function dmvec(D) can be used to construct the antisymmetric part of the exchange, where D is the Dzyaloshinskii-Moriya pseudo-vector. The resulting interaction will be ğƒ(ğ’_iğ’_j).\n\nThe optional numeric parameter biquad multiplies a scalar biquadratic interaction, (ğ’_iğ’_j)^2, with Interaction Renormalization if appropriate. For more general interactions, use set_pair_coupling! instead.\n\nExamples\n\nusing LinearAlgebra\n\n# Set a Heisenberg and DM interaction: 2Siâ‹…Sj + Dâ‹…(SiÃ—Sj)\nD = [0, 0, 3]\nset_exchange!(sys, 2I + dmvec(D), bond)\n\n# The same interaction as an explicit exchange matrix\nJ = [2 3 0;\n    -3 2 0;\n     0 0 2]\nset_exchange!(sys, J, bond)\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.set_exchange_at!","page":"Library Reference","title":"Sunny.set_exchange_at!","text":"set_exchange_at!(sys::System, J, site1::Site, site2::Site; biquad=0, offset=nothing)\n\nSets an exchange interaction `ğ’_iâ‹…J ğ’_j along the single bond connecting two Sites, ignoring crystal symmetry. Any previous coupling on this bond will be overwritten. The system must support inhomogeneous interactions via to_inhomogeneous.\n\nUse symmetry_equivalent_bonds to find (site1, site2, offset) values that would be symmetry equivalent to a given Bond in a homogeneous system. For smaller systems, the offset vector (in multiples of unit cells) will resolve ambiguities in the periodic wrapping.\n\nSee also set_exchange! for more details on specifying J and biquad. For more general couplings, use set_pair_coupling_at! instead.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.set_field!","page":"Library Reference","title":"Sunny.set_field!","text":"set_field!(sys::System, B_Î¼B)\n\nSets the external magnetic field ğ scaled by the Bohr magneton Î¼_B. This scaled field has units of energy and couples directly to the dimensionless magnetic_moment. At every site, the Zeeman coupling contributes an energy + (ğ Î¼_B)  (g ğ’), involving the local g-tensor and spin angular momentum ğ’. Commonly, g  +2 such that ğ’ is favored to anti-align with the applied field ğ. Note that a given system of Units will implicitly use the Bohr magneton to convert between field and energy dimensions.\n\nExample\n\n# In units of meV, apply a 2 tesla field in the z-direction\nunits = Units(:meV, :angstrom)\nset_field!(sys, [0, 0, 2] * units.T)\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.set_field_at!","page":"Library Reference","title":"Sunny.set_field_at!","text":"set_field_at!(sys::System, B_Î¼B, site::Site)\n\nSets the external magnetic field ğ scaled by the Bohr magneton Î¼_B for a single Site. This scaled field has units of energy and couples directly to the dimensionless magnetic_moment. Note that a given system of Units will implicitly use the Bohr magneton to convert between field and energy dimensions.\n\nSee the documentation of set_field! for more information.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.set_onsite_coupling!","page":"Library Reference","title":"Sunny.set_onsite_coupling!","text":"set_onsite_coupling!(sys::System, op, i::Int)\n\nSet the single-ion anisotropy for the ith atom of every unit cell, as well as all symmetry-equivalent atoms. The operator op may be provided as an abstract function of the local spin operators, as a polynomial of spin_matrices, or as a linear combination of stevens_matrices.\n\nIn :dipole mode, the onsite couplings are subject to a classical-to-quantum renormalization. This procedure is designed such that :dipole and :SUN modes agree in the onsite coupling energy for a purely dipolar state. Use :dipole_uncorrected mode to disable this renormalization. See the documentation page Interaction Renormalization for more information.\n\nExamples\n\n# An easy axis anisotropy in the z-direction\nset_onsite_coupling!(sys, S -> -D*S[3]^3, i)\n\n# The unique quartic single-ion anisotropy for a site with cubic point group\n# symmetry\nset_onsite_coupling!(sys, S -> 20*(S[1]^4 + S[2]^4 + S[3]^4), i)\n\n# An equivalent expression of this quartic anisotropy, up to a constant shift\nO = stevens_matrices(spin_label(sys, i))\nset_onsite_coupling!(sys, O[4,0] + 5*O[4,4], i)\n\nwarning: Limitations arising from quantum spin operators\nSingle-ion anisotropy is physically impossible in a bare Hamiltonian with quantum spin s = 12. Consider, for example, that any Pauli matrix squared gives the identity. More generally, one can verify that the kth order Stevens operators O[k, q] are zero whenever s  k2. Consequently, an anisotropy quartic in the spin operators requires s  2 and an anisotropy of sixth order requires s  3. To build an effective spin Hamiltonian that is not subject to these limitations, consider mode :dipole_uncorrected, which formally works in the s   limit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.set_onsite_coupling_at!","page":"Library Reference","title":"Sunny.set_onsite_coupling_at!","text":"set_onsite_coupling_at!(sys::System, op, site::Site)\n\nSets the single-ion anisotropy operator op for a single Site, ignoring crystal symmetry.  The system must support inhomogeneous interactions via to_inhomogeneous.\n\nSee also set_onsite_coupling!.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.set_pair_coupling!","page":"Library Reference","title":"Sunny.set_pair_coupling!","text":"set_pair_coupling!(sys::System, op, bond)\n\nSets an arbitrary coupling op along bond. This coupling will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous interactions on these bonds will be overwritten. The parameter bond has the form Bond(i, j, offset), where i and j are atom indices within the unit cell, and offset is a displacement in unit cells. The operator op may be provided as an anonymous function that accepts two spin dipole operators, or as a matrix that acts in the tensor product space of the two sites.\n\nExamples\n\n# Bilinear+biquadratic exchange involving 3Ã—3 matrices J1 and J2\nset_pair_coupling!(sys, (Si, Sj) -> Si'*J1*Sj + (Si'*J2*Sj)^2, bond)\n\n# Equivalent expression using an appropriate fixed matrix representation\nS = spin_matrices(1/2)\nSi, Sj = to_product_space(S, S)\nset_pair_coupling!(sys, Si'*J1*Sj + (Si'*J2*Sj)^2, bond)\n\nSee also spin_matrices, to_product_space.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.set_pair_coupling_at!","page":"Library Reference","title":"Sunny.set_pair_coupling_at!","text":"set_pair_coupling_at!(sys::System, op, site1::Site, site2::Site; offset=nothing)\n\nSets an arbitrary coupling along the single bond connecting two Sites, ignoring crystal symmetry. Any previous coupling on this bond will be overwritten. The system must support inhomogeneous interactions via to_inhomogeneous.\n\nUse symmetry_equivalent_bonds to find (site1, site2, offset) values that would be symmetry equivalent to a given Bond in a homogeneous system. For smaller systems, the offset vector (in multiples of unit cells) will resolve ambiguities in the periodic wrapping.\n\nThe operator op may be provided as an anonymous function that accepts two spin dipole operators, or as a matrix that acts in the tensor product space of the two sites. The documentation for set_pair_coupling! provides examples constructing op.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.set_spin_rescaling!","page":"Library Reference","title":"Sunny.set_spin_rescaling!","text":"set_spin_rescaling!(sys, [i1 => Î±1, i2 => Î±2, â€¦])\n\nSets an internal rescaling parameter Î± for each symmetry-distinct sublattice i. In dipole mode, this fixes each spin magnitude S = Î± s, where s is the spin_label of the relevant magnetic moment. In SU(N) mode, this fixes each coherent state magnitude, Z = Î±, which leads to an effective renormalization of local expectation values, A  Î± A.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.set_spin_rescaling_for_static_sum_rule!","page":"Library Reference","title":"Sunny.set_spin_rescaling_for_static_sum_rule!","text":"set_spin_rescaling_for_static_sum_rule!(sys)\n\nSets the classical dipole magnitude to sqrts(s+1) rather than s for each quantum spin-s moment. Valid only for systems in dipole mode.\n\nThis dipole rescaling convention may be helpful in combination with SampledCorrelationsStatic or SCGA calculators, which sample spins from the classical Boltzmann distribution. The estimated intensities_static mathcalS(ğª), when integrated over all ğª, will be exactly consistent with the quantum-mechanical identity hatS^2 = s(s+1) for dipole operator hatS.\n\nAt high temperatures, this dipole rescaling may also be useful in combination with the SampledCorrelations calculator, which estimates structure factor intensities using classical spin dynamics [1]. Note, however, that this dipole rescaling is not appropriate for SampledCorrelations measurements at low temperatures; a better kT-dependent classical-to-quantum correction factor is already provided in intensities and intensities_static. Obtaining good structure factor estimates at intermediate temperatures is an ongoing research topic. One strategy is to employ the more general and expensive \"Îº rescaling\" procedure, which dynamically rescales spins according to running quantum sum rule estimates [2]. See set_spin_rescaling!, which allows fine-grained control over the dipole rescaling.\n\nReferences\n\nT. Huberman et al., A study of the quantum classical crossover in the spin dynamics of the 2D S=5/2 antiferromagnet Rbâ‚‚MnFâ‚„: neutron scattering, computer simulations and analytic theories, J. Stat. Mech. P05017 (2008).\nD. Dahlbom et al., Quantum-to-classical crossover in generalized spin systems: Temperature-dependent spin dynamics of FeIâ‚‚, Phys. Rev. B 109, 014427 (2024).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.set_spin_s_at!","page":"Library Reference","title":"Sunny.set_spin_s_at!","text":"set_spin_s_at!(sys, s, site)\n\nSets the quantum spin-s magnitude at a single Site. The system must support inhomogeneous interactions via to_inhomogeneous. Mode :SUN is not yet supported.\n\nwarning: Restriction on existing couplings\nGeneral interaction operators cannot be translated between spin representations. The sole exception is 3Ã—3 bilinear exchange. Higher order couplings should be added only after the spin-s representation has been fixed. To set these, use set_onsite_coupling_at! and set_pair_coupling_at!.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.set_vacancy_at!","page":"Library Reference","title":"Sunny.set_vacancy_at!","text":"set_vacancy_at!(sys::System, site::Site)\n\nMake a single Site nonmagnetic. The system must support inhomogeneous interactions via to_inhomogeneous.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.spin_label","page":"Library Reference","title":"Sunny.spin_label","text":"spin_label(sys::System, i::Int)\n\nReturns the half-integer label s for an atom index i in the original crystal. This will match the original Moment specification of sys, except in :dipole_uncorrected mode, which formally corresponds to a s   limit. The returned label can be used with spin_matrices and stevens_matrices.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.spin_matrices","page":"Library Reference","title":"Sunny.spin_matrices","text":"spin_matrices(s)\n\nReturns a triple of NN spin matrices, where N = 2s+1. These are the generators of SU(2) in the spin-s representation. Any polynomial of these matrices can be passed to set_onsite_coupling!.\n\nIf s == Inf, then the return values are abstract symbols denoting infinite-dimensional operators that commute. This representation is needed when the System is in :dipole_uncorrected mode. See the documentation page Interaction Renormalization for technical discussion.\n\nExample\n\nS = spin_matrices(3/2)\n@assert S'*S â‰ˆ (3/2)*(3/2+1)*I\n@assert S[1]*S[2] - S[2]*S[1] â‰ˆ im*S[3]\n\nS = spin_matrices(Inf)\n@assert S[1]*S[2] - S[2]*S[1] == 0\n\nSee also print_stevens_expansion.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.spiral_energy","page":"Library Reference","title":"Sunny.spiral_energy","text":"spiral_energy(sys::System; k, axis)\n\nReturns the energy of a generalized spiral phase associated with the propagation wavevector k (in reciprocal lattice units, RLU) and an axis vector that is normal to the polarization plane (in global Cartesian coordinates).\n\nWhen ğ¤ is incommensurate, this calculation can be viewed as creating an infinite number of periodic copies of sys. The spins on each periodic copy are rotated about the axis vector, with the angle Î¸ = 2Ï€ ğ¤ğ«, where ğ« denotes the displacement vector between periodic copies of sys in multiples of the lattice vectors of the chemical cell.\n\nThe return value is the energy associated with one periodic copy of sys. Selecting ğ¤ = 0 yields the ordinary system energy.\n\nSee also minimize_spiral_energy! and repeat_periodically_as_spiral.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.spiral_energy_per_site","page":"Library Reference","title":"Sunny.spiral_energy_per_site","text":"spiral_energy_per_site(sys::System; k, axis)\n\nThe spiral_energy divided by the number of sites in sys. The special case ğ¤ = 0 yields a result identical to energy_per_site.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.ssf_custom","page":"Library Reference","title":"Sunny.ssf_custom","text":"ssf_custom(f, sys::System; apply_g=true, formfactors=nothing)\n\nSpecify measurement of the spin structure factor with a custom contraction function f. This function accepts a wavevector ğª in global Cartesian coordinates, and a 3Ã—3 matrix with structure factor intensity components mathcalS^Î±Î²(ğªÏ‰). Indices (Î± Î²) denote dipole components in global coordinates. The return value of f can be any number or isbits type. With specific choices of f, one can obtain measurements such as defined in ssf_perp and ssf_trace.\n\nBy default, the g-factor or tensor is applied at each site, such that the structure factor components are correlations between the magnetic moment operators. Set apply_g=false to measure correlations between the bare spin operators.\n\nThe optional formfactors comprise a list of pairs [i1 => FormFactor(...), i2 => ...], where i1, i2, ... are a complete set of symmetry-distinct atoms, and each FormFactor implements ğª-space attenuation for the given atom.\n\nIntended for use with SpinWaveTheory and instances of SampledCorrelations.\n\nExamples\n\n# Measure all structure factor components Sáµ…áµ as a 3Ã—3 matrix\nmeasure = ssf_custom((q, ssf) -> ssf, sys)\n\n# Measure the structure factor trace Sáµ…áµ…\nmeasure = ssf_custom((q, ssf) -> real(ssf[1, 1] + ssf[2, 2] + ssf[3, 3]), sys)\n\nSee also the Sunny documentation on Structure Factor Conventions.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.ssf_custom_bm","page":"Library Reference","title":"Sunny.ssf_custom_bm","text":"ssf_custom_bm(f, sys::System; u, v, apply_g=true, formfactors=nothing)\n\nSpecify measurement of the spin structure factor with a custom contraction function f. The interface is identical to ssf_custom except that f here receives momentum ğª and the 3Ã—3 structure factor data mathcalS^Î±Î²(ğª Ï‰) in the basis of the Blume-Maleev axis system. The wavevectors u and v, provided in reciprocal lattice units, will be used to define the scattering plane. In global Cartesian coordinates, the three orthonormal BM axes (e1, e2, e3) are defined as follows:\n\ne3 = normalize(u Ã— v)  # normal to the scattering plane (u, v)\ne1 = normalize(q)      # momentum transfer q within scattering plane\ne2 = normalize(e3 Ã— q) # perpendicular to q and in the scattering plane\n\nExample\n\n# Measure imaginary part of SÂ²Â³ - SÂ³Â² in the Blume-Maleev axis system for\n# the scattering plane [0, K, L].\nmeasure = ssf_custom_bm(sys; u=[0, 1, 0], v=[0, 0, 1]) do q, ssf\n    imag(ssf[2,3] - ssf[3,2])\nend\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.ssf_perp","page":"Library Reference","title":"Sunny.ssf_perp","text":"ssf_perp(sys::System; apply_g=true, formfactors=nothing)\n\nSpecify measurement of the spin structure factor with contraction by (I-ğªğªq^2). The contracted value provides an estimate of unpolarized scattering intensity. In the singular limit ğª  0, the contraction matrix is replaced by its rotational average, (23) I.\n\nThis function is a special case of ssf_custom.\n\nExample\n\n# Select CoÂ²âº form factor for atom 1 and its symmetry equivalents\nformfactors = [1 => FormFactor(\"Co2\")]\nssf_perp(sys; formfactors)\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.ssf_trace","page":"Library Reference","title":"Sunny.ssf_trace","text":"ssf_trace(sys::System; apply_g=true, formfactors=nothing)\n\nSpecify measurement of the spin structure factor, with trace over spin components. This quantity can be useful for checking quantum sum rules.\n\nThis function is a special case of ssf_custom.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.standardize","page":"Library Reference","title":"Sunny.standardize","text":"standardize(cryst::Crystal)\n\nConverts the provided crystal to an equivalent one that is standardized following ITA conventions [1].\n\nInternational Tables of Crystallography, Volume A (2016).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.step!","page":"Library Reference","title":"Sunny.step!","text":"step!(sys::System, dynamics)\n\nAdvance the spin configuration one dynamical time-step. The dynamics object may be a continuous spin dynamics, such as Langevin or ImplicitMidpoint, or it may be a discrete Monte Carlo sampling scheme such as LocalSampler.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.stevens_matrices","page":"Library Reference","title":"Sunny.stevens_matrices","text":"stevens_matrices(s)\n\nReturns the Stevens operators in the spin-s representation. The return value O can be indexed as O[k,q], where 0  k  6 labels an irrep of SO(3) and -k  q  k. This will produce an NN matrix where N = 2s + 1. Linear combinations of Stevens operators can be used as a \"physical basis\" for decomposing local observables. To see this decomposition, use print_stevens_expansion.\n\nIf s == Inf, then symbolic operators will be returned. In this infinite dimensional representation, the Stevens operators become homogeneous polynomials of commuting spin operators.\n\nExample\n\nO = stevens_matrices(2)\nS = spin_matrices(2)\n\nA = (1/20)O[4,0] + (1/4)O[4,4] + (102/5)I\nB = S[1]^4 + S[2]^4 + S[3]^4\n@assert A â‰ˆ B\n\nSee also spin_matrices and Interaction Renormalization.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.subcrystal","page":"Library Reference","title":"Sunny.subcrystal","text":"subcrystal(cryst, types) :: Crystal\n\nFilters sublattices of a Crystal by atom types, keeping the space group unchanged.\n\nsubcrystal(cryst, classes) :: Crystal\n\nFilters sublattices of Crystal by equivalence classes, keeping the space group unchanged.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.suggest_magnetic_supercell","page":"Library Reference","title":"Sunny.suggest_magnetic_supercell","text":"suggest_magnetic_supercell(ks; tol=1e-12, maxsize=100)\n\nSuggests a magnetic supercell, in units of the crystal lattice vectors, that is consistent with periodicity of the wavevectors ks in RLU. If the wavevectors are incommensurate (with respect to the maximum supercell size maxsize), one can select a larger error tolerance tol to find a supercell that is almost commensurate.\n\nPrints a 33 matrix of integers that is suitable for use in reshape_supercell.\n\nExamples\n\n# A magnetic supercell for a single-Q structure. Will print\nk1 = [0, -1/4, 1/4]\nsuggest_magnetic_supercell([k1])       # [1 0 0; 0 2 1; 0 -2 1]\n\n# A larger magnetic supercell for a double-Q structure\nk2 = [1/4, 0, 1/4]\nsuggest_magnetic_supercell([k1, k2])   # [1 2 2; -1 2 -2; -1 2 2]\n\n# If given incommensurate wavevectors, find an approximate supercell that\n# is exactly commensurate for nearby wavevectors.\nsuggest_magnetic_supercell([[0, 0, 1/âˆš5], [0, 0, 1/âˆš7]]; tol=1e-2)\n\n# This prints [1 0 0; 0 1 0; 0 0 16], which becomes commensurate under the\n# approximations `1/âˆš5 â‰ˆ 7/16` and `1/âˆš7 â‰ˆ 3/8`.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.suggest_timestep","page":"Library Reference","title":"Sunny.suggest_timestep","text":"suggest_timestep(sys, integrator; tol)\n\nSuggests a timestep for the numerical integration of spin dynamics according to a given error tolerance tol. The integrator should be Langevin or ImplicitMidpoint. The suggested dt will be inversely proportional to the magnitude of the effective field dEdğ’ arising from the current spin configuration in sys. The recommended timestep dt scales like âˆštol, which assumes second-order accuracy of the integrator.\n\nThe system sys should be initialized to an equilibrium spin configuration for the target temperature. Alternatively, a reasonably timestep estimate can be obtained from any low-energy spin configuration. For this, one can use randomize_spins! and then minimize_energy!.\n\nLarge damping magnitude or target temperature kT will tighten the timestep bound. If damping exceeds 1, it will rescale the suggested timestep by an approximate the factor 1damping. If kT is the largest energy scale, then the suggested timestep will scale like 1/(damping*kT). Quantification of numerical error for stochastic dynamics is subtle. The stochastic Heun integration scheme is weakly convergent of order-1, such that errors in the estimates of averaged observables may scale like dt. This implies that the tol argument may actually scale like the square of the true numerical error, and should be selected with this in mind.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.symmetry_equivalent_bonds","page":"Library Reference","title":"Sunny.symmetry_equivalent_bonds","text":"symmetry_equivalent_bonds(sys::System, bond::Bond)\n\nGiven a Bond for the original (unreshaped) crystal, return all symmetry equivalent bonds in the System. Each returned bond is represented as a pair of Sites and an offset, which may be used as input to set_exchange_at! or set_pair_coupling_at!. Reverse bonds are not included in the iterator (no double counting).\n\nExample\n\nfor (site1, site2, offset) in symmetry_equivalent_bonds(sys, bond)\n    @assert site1 < site2\n    set_exchange_at!(sys, J, site1, site2; offset)\nend\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.to_inhomogeneous","page":"Library Reference","title":"Sunny.to_inhomogeneous","text":"to_inhomogeneous(sys::System)\n\nReturns a copy of the system that allows for inhomogeneous interactions, which can be set using set_onsite_coupling_at!, set_exchange_at!, and set_vacancy_at!.\n\nInhomogeneous systems do not support symmetry-propagation of interactions or system reshaping.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.to_product_space","page":"Library Reference","title":"Sunny.to_product_space","text":"to_product_space(A, B, ...)\n\nGiven lists of operators acting on local Hilbert spaces individually, return the corresponding operators that act on the tensor product space. In typical usage, the inputs will represent local physical observables and the outputs will be used to define quantum couplings.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.@mix_proposals","page":"Library Reference","title":"Sunny.@mix_proposals","text":"@mix_proposals weight1 propose1 weight2 propose2 ...\n\nMacro to generate a proposal function that randomly selects among the provided functions according to the provided probability weights. For use with LocalSampler.\n\nExample\n\n# A proposal function that proposes a spin flip 40% of the time, and a\n# Gaussian perturbation 60% of the time.\n@mix_proposals 0.4 propose_flip 0.6 propose_delta(0.2)\n\n\n\n\n\n","category":"macro"},{"location":"library.html#Sunny.view_bz","page":"Library Reference","title":"Sunny.view_bz","text":"view_bz(crystal::Crystal, objs...; orthographic=false, compass=true)\n\nExperimental\n\nLaunches a graphical user interface to visualize reciprocal space with respect to the Crystal unit cell. The first Brilliouin zone for the primitive lattice is shown as a convex polyhedron. High-symmetry points and paths between them are inspectable, consistent with the data in print_irreducible_bz_paths. Additional objs may be passed, e.g., to visualize custom paths or grids in reciprocal space.\n\northographic: Use orthographic camera perspective.\ncompass: If true, draw Cartesian axes in bottom left.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.view_crystal","page":"Library Reference","title":"Sunny.view_crystal","text":"view_crystal(crystal::Crystal; refbonds=10, orthographic=false, ghost_radius=nothing, ndims=3, compass=true)\nview_crystal(sys::System; ...)\n\nLaunches a graphical user interface to visualize the Crystal unit cell. If a System is provided, then the 3Ã—3 exchange matrices for each bond will be depicted graphically.\n\nrefbonds: By default, calculate up to 10 reference bonds using the reference_bonds function. An explicit list of reference bonds may also be provided.\northographic: Use orthographic camera perspective.\nghost_radius: Show periodic images up to a given distance. Defaults to the cell size.\nndims: Spatial dimensions of system (1, 2, or 3).\ncompass: If true, draw Cartesian axes in bottom left.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.plot_intensities","page":"Library Reference","title":"Sunny.plot_intensities","text":"plot_intensities(res; colormap=nothing, colorrange=nothing, allpositive=true,\n                 saturation=0.9, units=nothing, into=nothing, ylims=nothing,\n                 title=\"\", interpolate=false)\n\nPlot the intensities data in res, which may be obtained from intensities_bands, intensities, intensities_static, powder_average, or similar.\n\nSee also the mutating variant plot_intensities!, which allows to draw multiple panels into a Makie.Figure, and to further customize the Makie.Axis.\n\nKeyword arguments:\n\ncolormap: Color palette for plotting broadened intensities. See Makie docs for allowed values.\ncolorrange: A lower and upper bound on intensities. For heatmaps, these bounds define the intensity values that saturate the colormap.\nallpositive: Should intensities be all positive, apart from numerical error? If true, the default colors will clip below zero intensity. If false, the default colors will be symmetric about zero intensity.\nsaturation: If colorrange is not explicitly set, this dimensionless parameter defines the upper saturated intensity value as a quantile of maximum intensities taken over wavevectors.\ninterpolate: Should 2D grid data be plotted with an interpolated heatmap? False by default, except when plotting discrete bands.\nunits: A Units instance for labeling axes and performing conversions.\ninto: A symbol for conversion into a new base energy unit (:meV, :K, etc.)\nylims: Limits of the y-axis.\ntitle: An optional title for the plot.\n\nWhen plotting discrete intensities_bands data, an additional argument is:\n\nfwhm: Apply Gaussian broadening with a specific full-width at half-maximum.\n\ntip: Exporting to PDF\nTo export the figure to a PDF file, use the CairoMakie backend and callfig = plot_intensities(..., interpolate=true)\nsave(\"myfile.pdf\", fig)The choice interpolate=true significantly reduces file sizes for plots with 2D heatmap data.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.plot_intensities!","page":"Library Reference","title":"Sunny.plot_intensities!","text":"plot_intensities!(panel, res; opts...)\n\nMutating variant of plot_intensities that allows drawing into a single panel of a Makie figure. Returns a Makie.Axis object to allow for further customization of labels, ticks, legends, etc.\n\nExample\n\nfig = Figure()\nplot_intensities!(fig[1, 1], res1; title=\"Panel 1\")\nplot_intensities!(fig[2, 1], res2; title=\"Panel 2\")\ndisplay(fig)\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.plot_spins","page":"Library Reference","title":"Sunny.plot_spins","text":"plot_spins(sys::System; arrowscale=1.0, color=:red, colorfn=nothing,\n           colormap=:viridis, colorrange=nothing, show_cell=true, orthographic=false,\n           ghost_radius=0, ndims=3, compass=true)\n\nPlot the spin configuration defined by sys. Optional parameters are:\n\narrowscale: Scale all arrows by dimensionless factor.\ncolor: Arrow colors. May be symbolic or numeric. If scalar, will be shared among all sites.\ncolorfn: Function that dynamically maps from a site index to a numeric color value. Useful for animations.\ncolormap, colorrange: Used to populate colors from numbers following Makie conventions.\nshow_cell: Show original crystallographic unit cell.\northographic: Use orthographic camera perspective.\nghost_radius: Show periodic images up to a given distance (length units).\nndims: Spatial dimensions of system (1, 2, or 3).\ncompass: If true, draw Cartesian axes in bottom left.\n\nCalling notify on the return value will animate the figure.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.plot_spins!","page":"Library Reference","title":"Sunny.plot_spins!","text":"plot_spins!(ax, sys::System; opts...)\n\nMutating variant of plot_spins that allows drawing into a single panel of a Makie figure.\n\nExample\n\nfig = Figure()\nplot_spins!(fig[1, 1], sys1)\nplot_spins!(fig[2, 1], sys2)\ndisplay(fig)\n\n\n\n\n\n","category":"function"},{"location":"library.html#Sunny.export_vtk","page":"Library Reference","title":"Sunny.export_vtk","text":"export_vtk(filename,params::BinningParameters,data)\n\nExport a VTK-compatible file to filename (do not include file extension when specifying the file name) which contains the data as VTK Cell Data on a grid parameterized by params.\n\nAt least one axis of the BinningParameters must be integrated over, since VTK does not support 4D data. See integrate_axes!.\n\n\n\n\n\n","category":"function"},{"location":"examples/05_MC_Ising.html","page":"5. Monte Carlo sampling of the Ising model","title":"5. Monte Carlo sampling of the Ising model","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/05_MC_Ising.html#5.-Monte-Carlo-sampling-of-the-Ising-model","page":"5. Monte Carlo sampling of the Ising model","title":"5. Monte Carlo sampling of the Ising model","text":"This tutorial illustrates simulation of the classical 2D Ising model.\n\nusing Sunny, GLMakie\n\nTo model the 2D square lattice, create an elongated tetragonal cell with one atom.\n\nlatvecs = lattice_vectors(1, 1, 10, 90, 90, 90)\ncrystal = Crystal(latvecs, [[0, 0, 0]])\n\nCreate a System of spin dipoles. Following the Ising convention, we will restrict the dipoles to 1 along the global hatz-axis. Select g=-1 so that the Zeeman coupling between external field ğ and spin dipole ğ’ is -ğğ’. The system size is 128Ã—128.\n\nL = 128\nsys = System(crystal, [1 => Moment(s=1, g=-1)], :dipole; dims=(L, L, 1))\npolarize_spins!(sys, (0, 0, 1))\n\nUse set_exchange! to include a ferromagnetic Heisenberg interaction along nearest-neighbor bonds. The Bond below connects two spins displaced by the lattice vector ğšâ‚. This interaction will be propagated to all nearest-neighbors bonds in the system, consistent with the symmetries of the square lattice.\n\nset_exchange!(sys, -1.0, Bond(1, 1, (1, 0, 0)))\n\nIf an external field is desired, it can be set using set_field!.\n\nB = 0\nset_field!(sys, (0, 0, B))\n\nThe critical temperature for the Ising model is known analytically.\n\nTc = 2/log(1+âˆš2)\n\nUse a LocalSampler to perform nsweeps Monte Carlo sweeps. A sweep consists of, on average, one trial update per spin in the system. Each proposed update is accepted or rejected according to the Metropolis acceptance probability. As its name suggests, the propose_flip function will only propose pure spin flips, ğ’ rightarrow -ğ’.\n\nnsweeps = 4000\nsampler = LocalSampler(kT=Tc, propose=propose_flip)\nfor i in 1:nsweeps\n    step!(sys, sampler)\nend\n\nPlot the Ising spins by extracting the z-component of the dipoles\n\nheatmap(reshape([S[3] for S in sys.dipoles], (L, L)))","category":"section"},{"location":"examples/contributed/MgCr2O4-tutorial.html#MgCr2O4-at-Finite-Temperature","page":"MgCr2O4 at Finite Temperature","title":"MgCr2O4 at Finite Temperature","text":"Author: Martin Mourigal\n\nDate: September 9, 2022 (Updated January 21, 2025 using Sunny 0.7.5)\n\nIn this tutorial, we will walk through an example in Sunny and calculate the spin dynamical properties of the Heisenberg pyrochlore antiferromagnet and apply this knowledge to MgCr2O4 and ZnCr2O4, which are known to approximate this model. Relevant publications include:\n\n[1] P. H. Conlon and J. T. Chalker, Phys. Rev. Lett. 102, 237206 (2009)\n\n[2] P. H. Conlon and J. T. Chalker, Phys. Rev. B 81, 224413 (2010)\n\n[3] X. Bai, J. A. M. Paddison, et al. Phys. Rev. Lett. 122, 097201 (2019)","category":"section"},{"location":"examples/contributed/MgCr2O4-tutorial.html#Setting-up-Julia","page":"MgCr2O4 at Finite Temperature","title":"Setting up Julia","text":"To run the examples in the tutorial, you will need a working installation of the Julia programming language and the Sunny package. Some useful references for getting started are:\n\nGetting started with Julia for Sunny\nSunny Docs\n\nWe will begin by loading the relevant packages.\n\nusing Sunny # The main package\nusing GLMakie # Plotting package","category":"section"},{"location":"examples/contributed/MgCr2O4-tutorial.html#Setting-up-the-crystal-structure","page":"MgCr2O4 at Finite Temperature","title":"Setting up the crystal structure","text":"Before specifying the interactions of our system, we first must set up the crystal. We will begin by specifying the pyrochlore lattice (illustrated below) in the manner that is typical of theorists.\n\n(Image: )\n\nPicture Credits: Theory of Quantum Matter Unit, OIST","category":"section"},{"location":"examples/contributed/MgCr2O4-tutorial.html#\"Theorist\"-Method","page":"MgCr2O4 at Finite Temperature","title":"\"Theorist\" Method","text":"In this approach, we directly define the lattice vectors and specify the position of each atom in fractional coordinates.\n\nlatvecs = lattice_vectors(8.3342, 8.3342, 8.3342, 90, 90, 90)\npositions = [[0.875, 0.625, 0.375],\n             [0.625, 0.125, 0.625],\n             [0.875, 0.875, 0.125],\n             [0.625, 0.875, 0.375],\n             [0.875, 0.125, 0.875],\n             [0.625, 0.625, 0.125],\n             [0.875, 0.375, 0.625],\n             [0.625, 0.375, 0.875],\n             [0.375, 0.625, 0.875],\n             [0.125, 0.125, 0.125],\n             [0.375, 0.875, 0.625],\n             [0.125, 0.875, 0.875],\n             [0.375, 0.125, 0.375],\n             [0.125, 0.625, 0.625],\n             [0.375, 0.375, 0.125],\n             [0.125, 0.375, 0.375]];\ntypes = [\"B\" for _ in positions]\nxtal_pyro   = Crystal(latvecs, positions; types) # We will call this crystal the Theoretical Pyrochlore\n\nCrystal\nSpacegroup 'F d -3 m' (227)\nLattice params a=8.334, b=8.334, c=8.334, Î±=90Â°, Î²=90Â°, Î³=90Â°\nCell volume 578.9\nType 'B', Wyckoff 16c (site sym. '.-3m'):\n   1. [7/8, 5/8, 3/8]\n   2. [5/8, 1/8, 5/8]\n   3. [7/8, 7/8, 1/8]\n   4. [5/8, 7/8, 3/8]\n   5. [7/8, 1/8, 7/8]\n   6. [5/8, 5/8, 1/8]\n   7. [7/8, 3/8, 5/8]\n   8. [5/8, 3/8, 7/8]\n   9. [3/8, 5/8, 7/8]\n   10. [1/8, 1/8, 1/8]\n   11. [3/8, 7/8, 5/8]\n   12. [1/8, 7/8, 7/8]\n   13. [3/8, 1/8, 3/8]\n   14. [1/8, 5/8, 5/8]\n   15. [3/8, 3/8, 1/8]\n   16. [1/8, 3/8, 3/8]\n\n\nTo examine the result interactively, we can call view_crystal.\n\nview_crystal(xtal_pyro, 3.2)\n\n(Image: )","category":"section"},{"location":"examples/contributed/MgCr2O4-tutorial.html#\"Experimentalist\"-Method-#1-(Incorrect)","page":"MgCr2O4 at Finite Temperature","title":"\"Experimentalist\" Method #1 (Incorrect)","text":"A real crystal is more complicated than this, however, and we will now construct the system using the actual CIF file of MgCr2O4 from ICSD. This can be done by copying over the data from a CIF file by hand, but this can be dangerous, as shown below.\n\nlatvecs   = lattice_vectors(8.3342, 8.3342, 8.3342, 90, 90, 90)\npositions = [[0.1250, 0.1250, 0.1250],\n             [0.5000, 0.5000, 0.5000],\n             [0.2607, 0.2607, 0.2607]]\ntypes = [\"Mg\",\"Cr\",\"O\"]\nxtal_mgcro_1 = Crystal(latvecs, positions; types)\n\nCrystal\nSpacegroup 'R 3 m' (160)\nLattice params a=8.334, b=8.334, c=8.334, Î±=90Â°, Î²=90Â°, Î³=90Â°\nCell volume 578.9\nType 'Mg', Wyckoff 3a (site sym. '3m'):\n   1. [1/8, 1/8, 1/8]\nType 'Cr', Wyckoff 3a (site sym. '3m'):\n   2. [1/2, 1/2, 1/2]\nType 'O', Wyckoff 3a (site sym. '3m'):\n   3. [0.2607, 0.2607, 0.2607]\n\n\nSunny returned a valid crystal, but it did not get the right space group for MgCr2O4. This can be fixed by modifying the input to include the space group and the setting.","category":"section"},{"location":"examples/contributed/MgCr2O4-tutorial.html#\"Experimentalist\"-Method-#2-(Correct)","page":"MgCr2O4 at Finite Temperature","title":"\"Experimentalist\" Method #2 (Correct)","text":"As above, we will define the crystal structure of MgCr2O4 by copying the info from a CIF file, but we will also specify the space group and setting explicitly.\n\nlatvecs    = lattice_vectors(8.3342, 8.3342, 8.3342, 90, 90, 90)\npositions  = [[0.1250, 0.1250, 0.1250],\n              [0.5000, 0.5000, 0.5000],\n              [0.2607, 0.2607, 0.2607]]\ntypes      = [\"Mg\",\"Cr\",\"O\"]\nspacegroup = 227 # Space Group Number\nsetting    = \"2\" # Space Group setting\nxtal_mgcro_2 = Crystal(latvecs, positions, spacegroup; types, setting)\n\nCrystal\nSpacegroup 'F d -3 m' (227)\nLattice params a=8.334, b=8.334, c=8.334, Î±=90Â°, Î²=90Â°, Î³=90Â°\nCell volume 578.9\nType 'Mg', Wyckoff 8a (site sym. '-43m'):\n   1. [1/8, 1/8, 1/8]\n   2. [5/8, 5/8, 1/8]\n   3. [7/8, 3/8, 3/8]\n   4. [3/8, 7/8, 3/8]\n   5. [5/8, 1/8, 5/8]\n   6. [1/8, 5/8, 5/8]\n   7. [3/8, 3/8, 7/8]\n   8. [7/8, 7/8, 7/8]\nType 'Cr', Wyckoff 16d (site sym. '.-3m'):\n   9. [1/2, 0, 0]\n   10. [3/4, 1/4, 0]\n   11. [0, 1/2, 0]\n   12. [1/4, 3/4, 0]\n   13. [3/4, 0, 1/4]\n   14. [1/2, 1/4, 1/4]\n   15. [1/4, 1/2, 1/4]\n   16. [0, 3/4, 1/4]\n   17. [0, 0, 1/2]\n   18. [1/4, 1/4, 1/2]\n   19. [1/2, 1/2, 1/2]\n   20. [3/4, 3/4, 1/2]\n   21. [1/4, 0, 3/4]\n   22. [0, 1/4, 3/4]\n   23. [3/4, 1/2, 3/4]\n   24. [1/2, 3/4, 3/4]\nType 'O', Wyckoff 32e (site sym. '.3m'):\n   25. [0.7393, 0.01070, 0.01070]\n   26. [0.5107, 0.2393, 0.01070]\n   27. [0.2393, 0.5107, 0.01070]\n   28. [0.01070, 0.7393, 0.01070]\n   29. [0.5107, 0.01070, 0.2393]\n   30. [0.7393, 0.2393, 0.2393]\n   31. [0.01070, 0.5107, 0.2393]\n   32. [0.2393, 0.7393, 0.2393]\n   33. [0.2607, 0.2607, 0.2607]\n   34. [0.4893, 0.4893, 0.2607]\n   35. [0.7607, 0.7607, 0.2607]\n   36. [0.9893, 0.9893, 0.2607]\n   37. [0.4893, 0.2607, 0.4893]\n   38. [0.2607, 0.4893, 0.4893]\n   39. [0.9893, 0.7607, 0.4893]\n   40. [0.7607, 0.9893, 0.4893]\n   41. [0.2393, 0.01070, 0.5107]\n   42. [0.01070, 0.2393, 0.5107]\n   43. [0.7393, 0.5107, 0.5107]\n   44. [0.5107, 0.7393, 0.5107]\n   45. [0.01070, 0.01070, 0.7393]\n   46. [0.2393, 0.2393, 0.7393]\n   47. [0.5107, 0.5107, 0.7393]\n   48. [0.7393, 0.7393, 0.7393]\n   49. [0.7607, 0.2607, 0.7607]\n   50. [0.9893, 0.4893, 0.7607]\n   51. [0.2607, 0.7607, 0.7607]\n   52. [0.4893, 0.9893, 0.7607]\n   53. [0.9893, 0.2607, 0.9893]\n   54. [0.7607, 0.4893, 0.9893]\n   55. [0.4893, 0.7607, 0.9893]\n   56. [0.2607, 0.9893, 0.9893]\n\n\nThis result is correct, but at this point we might as well import the CIF file directly, which we now proceed to do.","category":"section"},{"location":"examples/contributed/MgCr2O4-tutorial.html#\"Experimentalist\"-Method-#3-(Correct-â€“-if-your-CIF-file-is)","page":"MgCr2O4 at Finite Temperature","title":"\"Experimentalist\" Method #3 (Correct â€“ if your CIF file is)","text":"To import a CIF file, simply give the path to Crystal. One may optionally specify a precision parameter to apply to the symmetry analysis.\n\ncif = joinpath(@__DIR__, \"MgCr2O4_160953_2009.cif\")\nxtal_mgcro_3 = Crystal(cif; symprec=0.001)\n\nCrystal\nSpacegroup 'F d -3 m' (227)\nLattice params a=8.333, b=8.333, c=8.333, Î±=90Â°, Î²=90Â°, Î³=90Â°\nCell volume 578.6\nType 'Mg1', Wyckoff 8b (site sym. '-43m'):\n   1. [1/8, 1/8, 1/8]\n   2. [5/8, 5/8, 1/8]\n   3. [7/8, 3/8, 3/8]\n   4. [3/8, 7/8, 3/8]\n   5. [5/8, 1/8, 5/8]\n   6. [1/8, 5/8, 5/8]\n   7. [3/8, 3/8, 7/8]\n   8. [7/8, 7/8, 7/8]\nType 'Cr1', Wyckoff 16c (site sym. '.-3m'):\n   9. [1/2, 0, 0]\n   10. [3/4, 1/4, 0]\n   11. [0, 1/2, 0]\n   12. [1/4, 3/4, 0]\n   13. [3/4, 0, 1/4]\n   14. [1/2, 1/4, 1/4]\n   15. [1/4, 1/2, 1/4]\n   16. [0, 3/4, 1/4]\n   17. [0, 0, 1/2]\n   18. [1/4, 1/4, 1/2]\n   19. [1/2, 1/2, 1/2]\n   20. [3/4, 3/4, 1/2]\n   21. [1/4, 0, 3/4]\n   22. [0, 1/4, 3/4]\n   23. [3/4, 1/2, 3/4]\n   24. [1/2, 3/4, 3/4]\nType 'O1', Wyckoff 32e (site sym. '.3m'):\n   25. [0.7388, 0.01120, 0.01120]\n   26. [0.5112, 0.2388, 0.01120]\n   27. [0.2388, 0.5112, 0.01120]\n   28. [0.01120, 0.7388, 0.01120]\n   29. [0.5112, 0.01120, 0.2388]\n   30. [0.7388, 0.2388, 0.2388]\n   31. [0.01120, 0.5112, 0.2388]\n   32. [0.2388, 0.7388, 0.2388]\n   33. [0.2612, 0.2612, 0.2612]\n   34. [0.4888, 0.4888, 0.2612]\n   35. [0.7612, 0.7612, 0.2612]\n   36. [0.9888, 0.9888, 0.2612]\n   37. [0.4888, 0.2612, 0.4888]\n   38. [0.2612, 0.4888, 0.4888]\n   39. [0.9888, 0.7612, 0.4888]\n   40. [0.7612, 0.9888, 0.4888]\n   41. [0.2388, 0.01120, 0.5112]\n   42. [0.01120, 0.2388, 0.5112]\n   43. [0.7388, 0.5112, 0.5112]\n   44. [0.5112, 0.7388, 0.5112]\n   45. [0.01120, 0.01120, 0.7388]\n   46. [0.2388, 0.2388, 0.7388]\n   47. [0.5112, 0.5112, 0.7388]\n   48. [0.7388, 0.7388, 0.7388]\n   49. [0.7612, 0.2612, 0.7612]\n   50. [0.9888, 0.4888, 0.7612]\n   51. [0.2612, 0.7612, 0.7612]\n   52. [0.4888, 0.9888, 0.7612]\n   53. [0.9888, 0.2612, 0.9888]\n   54. [0.7612, 0.4888, 0.9888]\n   55. [0.4888, 0.7612, 0.9888]\n   56. [0.2612, 0.9888, 0.9888]\n\n\nFinally, we wish to restrict attention to the magnetic atoms in the unit cell while maintaining symmetry information for the full crystal, which is required to determine the correct exchange and g-factor anisotropies. This can be achieved with the subcrystal function.\n\nxtal_mgcro = subcrystal(xtal_mgcro_2, \"Cr\")\n\nCrystal\nSpacegroup 'F d -3 m' (227)\nLattice params a=8.334, b=8.334, c=8.334, Î±=90Â°, Î²=90Â°, Î³=90Â°\nCell volume 578.9\nType 'Cr', Wyckoff 16d (site sym. '.-3m'):\n   1. [1/2, 0, 0]\n   2. [3/4, 1/4, 0]\n   3. [0, 1/2, 0]\n   4. [1/4, 3/4, 0]\n   5. [3/4, 0, 1/4]\n   6. [1/2, 1/4, 1/4]\n   7. [1/4, 1/2, 1/4]\n   8. [0, 3/4, 1/4]\n   9. [0, 0, 1/2]\n   10. [1/4, 1/4, 1/2]\n   11. [1/2, 1/2, 1/2]\n   12. [3/4, 3/4, 1/2]\n   13. [1/4, 0, 3/4]\n   14. [0, 1/4, 3/4]\n   15. [3/4, 1/2, 3/4]\n   16. [1/2, 3/4, 3/4]\n","category":"section"},{"location":"examples/contributed/MgCr2O4-tutorial.html#Making-a-System-and-assigning-interactions","page":"MgCr2O4 at Finite Temperature","title":"Making a System and assigning interactions","text":"","category":"section"},{"location":"examples/contributed/MgCr2O4-tutorial.html#Making-a-System","page":"MgCr2O4 at Finite Temperature","title":"Making a System","text":"Before assigning any interactions, we first have to set up a System using our Crystal.\n\ndims = (6, 6, 6)  # Supercell dimensions\nmomentinfo = [1 => Moment(s=3/2, g=2)]  # Specify local moment information, note that all sites are symmetry equivalent\nsys_pyro = System(xtal_pyro, momentinfo, :dipole; dims)    # Make a system in dipole (Landau-Lifshitz) mode on pyrochlore lattice\nsys_mgcro = System(xtal_mgcro, momentinfo, :dipole; dims); # Same on MgCr2O4 crystal\n\nTo understand what interactions we may assign to this system, we have to understand the the symmetry properties of the crystal, which we turn to next.","category":"section"},{"location":"examples/contributed/MgCr2O4-tutorial.html#Symmetry-analysis-for-exchange-and-single-ion-anisotropies","page":"MgCr2O4 at Finite Temperature","title":"Symmetry analysis for exchange and single-ion anisotropies","text":"print_symmetry_table reports all the exchange interactions, single-site anisotropies, and g-factors allowed on our crystal. It takes a Cyrstal and a distance. We'll look at both the \"theorist's\" pyrochlore lattice,\n\nprint_symmetry_table(xtal_pyro, 5.9)\n\nAtom 1\nType 'B', position [7/8, 5/8, 3/8], Wyckoff 16c\nAllowed g-tensor: [ A B -B\n                    B A  B\n                   -B B  A]\nAllowed anisotropy in Stevens operators:\n    câ‚*(ğ’ª[2,-2]+2ğ’ª[2,-1]-2ğ’ª[2,1]) +\n    câ‚‚*(7ğ’ª[4,-3]+2ğ’ª[4,-2]-ğ’ª[4,-1]+ğ’ª[4,1]+7ğ’ª[4,3]) + câ‚ƒ*(ğ’ª[4,0]+5ğ’ª[4,4]) +\n    câ‚„*(11ğ’ª[6,-6]+8ğ’ª[6,-3]-ğ’ª[6,-2]+8ğ’ª[6,-1]-8ğ’ª[6,1]+8ğ’ª[6,3]) + câ‚…*(-ğ’ª[6,0]+21ğ’ª[6,4]) + câ‚†*(9ğ’ª[6,-6]+24ğ’ª[6,-5]+5ğ’ª[6,-2]+8ğ’ª[6,-1]-8ğ’ª[6,1]-24ğ’ª[6,5])\n\nBond(1, 3, [0, 0, 0])\nDistance 2.946584668, coordination 6\nConnects 'B' at [7/8, 5/8, 3/8] to 'B' at [7/8, 7/8, 1/8]\nAllowed exchange matrix: [ A -D D\n                           D  B C\n                          -D  C B]\nAllowed DM vector: [0 -D -D]\n\nBond(1, 2, [0, 0, 0])\nDistance 5.103634354, coordination 12\nConnects 'B' at [7/8, 5/8, 3/8] to 'B' at [5/8, 1/8, 5/8]\nAllowed exchange matrix: [  A  C-E  D-F\n                          C+E    B -C+E\n                          D+F -C-E    A]\nAllowed DM vector: [E F -E]\n\nBond(2, 6, [0, 0, 0])\nDistance 5.893169336, coordination 6\nConnects 'B' at [5/8, 1/8, 5/8] to 'B' at [5/8, 5/8, 1/8]\nAllowed exchange matrix: [A D D\n                          D B C\n                          D C B]\n\nBond(1, 5, [0, 0, 0])\nDistance 5.893169336, coordination 6\nConnects 'B' at [7/8, 5/8, 3/8] to 'B' at [7/8, 1/8, 7/8]\nAllowed exchange matrix: [ A D -D\n                           D B  C\n                          -D C  B]\n\n\n\nand for the the MgCrO4 crystal,\n\nprint_symmetry_table(xtal_mgcro, 6.0)\n\nAtom 1\nType 'Cr', position [1/2, 0, 0], Wyckoff 16d\nAllowed g-tensor: [A B B\n                   B A B\n                   B B A]\nAllowed anisotropy in Stevens operators:\n    câ‚*(ğ’ª[2,-2]+2ğ’ª[2,-1]+2ğ’ª[2,1]) +\n    câ‚‚*(-7ğ’ª[4,-3]-2ğ’ª[4,-2]+ğ’ª[4,-1]+ğ’ª[4,1]+7ğ’ª[4,3]) + câ‚ƒ*(ğ’ª[4,0]+5ğ’ª[4,4]) +\n    câ‚„*(11ğ’ª[6,-6]+8ğ’ª[6,-3]-ğ’ª[6,-2]+8ğ’ª[6,-1]+8ğ’ª[6,1]-8ğ’ª[6,3]) + câ‚…*(-ğ’ª[6,0]+21ğ’ª[6,4]) + câ‚†*(9ğ’ª[6,-6]+24ğ’ª[6,-5]+5ğ’ª[6,-2]+8ğ’ª[6,-1]+8ğ’ª[6,1]+24ğ’ª[6,5])\n\nBond(1, 2, [0, 0, 0])\nDistance 2.946584668, coordination 6\nConnects 'Cr' at [1/2, 0, 0] to 'Cr' at [3/4, 1/4, 0]\nAllowed exchange matrix: [A C -D\n                          C A -D\n                          D D  B]\nAllowed DM vector: [-D D 0]\n\nBond(1, 7, [0, 0, 0])\nDistance 5.103634354, coordination 12\nConnects 'Cr' at [1/2, 0, 0] to 'Cr' at [1/4, 1/2, 1/4]\nAllowed exchange matrix: [  A  C-E  D-F\n                          C+E    B -C+E\n                          D+F -C-E    A]\nAllowed DM vector: [E F -E]\n\nBond(1, 3, [0, 0, 0])\nDistance 5.893169336, coordination 6\nConnects 'Cr' at [1/2, 0, 0] to 'Cr' at [0, 1/2, 0]\nAllowed exchange matrix: [A D C\n                          D A C\n                          C C B]\n\nBond(1, 3, [1, 0, 0])\nDistance 5.893169336, coordination 6\nConnects 'Cr' at [1/2, 0, 0] to 'Cr' at [1, 1/2, 0]\nAllowed exchange matrix: [A D C\n                          D A C\n                          C C B]\n\n\n\nNote that the exchange anisotropies allowed on the the pyrochlore lattice are slightly different from those on the MgCr2O4 cyrstal due to the role of Mg and O in the bonds. Also note that Sunny has correctly identified the two inequivalent bonds 3a and 3b having the same length. A question may arises to know which bond is J3a and which is J3b, let's plot the structure.\n\nview_crystal(xtal_mgcro, 5.9)\n\n(Image: )\n\nThe crystal viewer shows that the second interaction â€“ cyan color with distance of 5.89Ã… â€“ is in fact the one hopping through a chromium site, meaning it is J3a! We will need to be careful with that later.","category":"section"},{"location":"examples/contributed/MgCr2O4-tutorial.html#Building-the-exchange-interactions-for-our-system","page":"MgCr2O4 at Finite Temperature","title":"Building the exchange interactions for our system","text":"We begin by setting the scale of our exchange interactions on each bond.\n\nJ1      = 3.27  # value of J1 in meV from Bai's PRL paper\nJ_pyro  = [1.00,0.000,0.000,0.000]*J1    # pure nearest neighbor pyrochlore\nJ_mgcro = [1.00,0.0815,0.1050,0.085]*J1; # further neighbor pyrochlore relevant for MgCr2O4\n# val_J_mgcro = [1.00,0.000,0.025,0.025]*val_J1; # this is a funny setting from Conlon-Chalker\n\nThese values are then assigned to their corresponding bonds with set_exchange!.\n\n# === Assign exchange interactions to pyrochlore system ===\nset_exchange!(sys_pyro, J_pyro[1], Bond(1, 3, [0,0,0])) # J1\nset_exchange!(sys_pyro, J_pyro[2], Bond(1, 2, [0,0,0])) # J2\nset_exchange!(sys_pyro, J_pyro[3], Bond(2, 6, [0,0,0])) # J3a\nset_exchange!(sys_pyro, J_pyro[4], Bond(1, 5, [0,0,0])) # J3b\n\n# === Assign exchange interactions to MgCr2O4 system ===\nset_exchange!(sys_mgcro, J_mgcro[1], Bond(1, 2, [0,0,0]))  # J1\nset_exchange!(sys_mgcro, J_mgcro[2], Bond(1, 7, [0,0,0]))  # J2\nset_exchange!(sys_mgcro, J_mgcro[3], Bond(1, 3, [0,0,0]))  # J3a -- Careful here!\nset_exchange!(sys_mgcro, J_mgcro[4], Bond(1, 3, [1,0,0])); # J3b -- And here!\n\nWe will not be assigning any single-ion anisotropies, so we have finished specifying our models. For good measure, we will set both systems to a random (infinite temperature) initial condition.\n\nrandomize_spins!(sys_pyro)\nrandomize_spins!(sys_mgcro);","category":"section"},{"location":"examples/contributed/MgCr2O4-tutorial.html#Cooling-our-System-amd-calculating-the-instantaneous-and-dynamic-structure-factors-at-the-final-temperature","page":"MgCr2O4 at Finite Temperature","title":"Cooling our System amd calculating the instantaneous and dynamic structure factors at the final temperature","text":"We begin by thermalizing our system at a particular temperature. We will accomplish this by running Langevin dynamics. To do this, we must set up a Langevin integrator.\n\ndt = 0.01  # Integration time step in meV^-1\ndamping  = 0.1   # Phenomenological damping parameter\nkT = 1.8   # Desired temperature in meV\nlangevin = Langevin(dt; damping, kT); # Construct integrator\n\nWe can now thermalize our systems by running the integrator.\n\nfor _ in 1:5000\n    step!(sys_pyro, langevin)\n    step!(sys_mgcro, langevin)\nend\n\nAs a sanity check, we'll plot the real-space spin configurations of both systems after themalization. First the pyrochlore,\n\nplot_spins(sys_pyro)\n\n(Image: )\n\nand then the MgCr2O4,\n\nplot_spins(sys_mgcro)\n\n(Image: )","category":"section"},{"location":"examples/contributed/MgCr2O4-tutorial.html#Instantaneous-Structure-Factor","page":"MgCr2O4 at Finite Temperature","title":"Instantaneous Structure Factor","text":"Next we can examine the instantaneous structure factor.\n\nisf_pyro  = SampledCorrelationsStatic(sys_pyro; measure=ssf_perp(sys_pyro))\nisf_mgcro = SampledCorrelationsStatic(sys_mgcro; measure=ssf_perp(sys_mgcro));\n\nThese are currently empty. Let's add spin-spin correlation data from 10 sampled spin configurations at kT = 1.8 meV.\n\nfor _ in 1:10\n    # Run dynamics to decorrelate\n    for _ in 1:500\n        step!(sys_pyro, langevin)\n        step!(sys_mgcro, langevin)\n    end\n    # Add samples\n    add_sample!(isf_pyro, sys_pyro)\n    add_sample!(isf_mgcro, sys_mgcro)\nend\n\nTo retrieve the intensities, we call intensities_static on an array of wave vectors, which we can generate with q_space_grid.\n\nqpts_pyro = q_space_grid(xtal_pyro, [1, 0, 0], range(-4.0, 4.0, 200), [0, 1, 0], (-4, 4))\nqpts_mgcro = q_space_grid(xtal_mgcro, [1, 0, 0], range(-4.0, 4.0, 200), [0, 1, 0], (-4, 4))\n\nSq_pyro  = intensities_static(isf_pyro, qpts_pyro)\nSq_mgcro = intensities_static(isf_mgcro, qpts_mgcro);\n\nFinally, plot the results.\n\nfig = Figure(; size=(1200,500))\nplot_intensities!(fig[1,1], Sq_pyro)\nplot_intensities!(fig[1,2], Sq_mgcro)\nfig\n\n(Image: )","category":"section"},{"location":"examples/contributed/MgCr2O4-tutorial.html#Dynamical-Structure-Factor","page":"MgCr2O4 at Finite Temperature","title":"Dynamical Structure Factor","text":"We can also estimate the dynamical structure factor.\n\nenergies = range(0, 10, 100)\nsc_pyro  = SampledCorrelations(sys_pyro; dt, energies, measure=ssf_perp(sys_pyro))\nsc_mgcro = SampledCorrelations(sys_mgcro; dt, energies, measure=ssf_perp(sys_mgcro));\n\nNext we sample trajectories and calculate the spin-spin correlations of these. Unlike SampledCorrelationsStatic, these samples now include time (energy) information â€“ and take significantly longer to calculate.\n\nfor _ in 1:3\n    # Run dynamics to decorrelate\n    for _ in 1:500\n        step!(sys_pyro, langevin)\n        step!(sys_mgcro, langevin)\n    end\n    # Add samples\n    add_sample!(sc_pyro, sys_pyro)\n    add_sample!(sc_mgcro, sys_mgcro)\nend\n\nWe can now examine the structure factor intensities along a path in momentum space. First examine the pyrochlore model.\n\nfig = Figure(; size=(1200,900))\nqbs = 0.0:0.5:1.5 # Determine q_b for each slice\nfor (i, qb) in enumerate(qbs)\n    qpts_pyro = q_space_path(xtal_pyro, [[-4, qb, 0], [4, qb, 0]], 200)\n    Sqw_pyro = intensities(sc_pyro, qpts_pyro; energies=:available, kT)\n    plot_intensities!(fig[fldmod1(i, 2)...], Sqw_pyro; title=\"q_b = $qb\")\nend\nfig\n\n(Image: )\n\nNext generate the results along the same path for MgCr2O4.\n\nfig = Figure(; size=(1200,900))\nfor (i, qb) in enumerate(qbs)\n    qpts_mgcro = q_space_path(xtal_mgcro, [[-4, qb, 0], [4, qb, 0]], 200)\n    Sqw_mgcro = intensities(sc_mgcro, qpts_mgcro; energies=:available, kT)\n    plot_intensities!(fig[fldmod1(i, 2)...], Sqw_mgcro; title =\"q_b = $qb\")\nend\nfig\n\n(Image: )","category":"section"},{"location":"examples/contributed/MgCr2O4-tutorial.html#Instantaneous-structure-factor-from-a-dynamical-structure-factor","page":"MgCr2O4 at Finite Temperature","title":"Instantaneous structure factor from a dynamical structure factor","text":"Finally, we note that the instant structure factor (what we generated with SampledCorrelationsStatic) can be calculated from the dynamical structure factor (generated with a SampledCorrelations). We simply call instant_static rather than intensities on the SampledCorrelations. This will calculate the instantaneous structure factor from from ğ’®(ğªÏ‰) by integrating out Ï‰ . An advantage of doing this (as opposed to using a SampledCorrelationsStatic) is that Sunny is able to apply a temperature- and energy-dependent intensity rescaling before integrating out the dynamical information. The results of this approach are more suitable for comparison with experimental data.\n\nqpts_pyro = q_space_grid(xtal_pyro, [1, 0, 0], range(-4, 4, 200), [0, 1, 0], (-4, 4))\nqpts_mgcro = q_space_grid(xtal_mgcro, [1, 0, 0], range(-4, 4, 200), [0, 1, 0], (-4, 4))\n\nSq_pyro  = intensities_static(sc_pyro, qpts_pyro; kT)\nSq_mgcro = intensities_static(sc_mgcro, qpts_mgcro; kT);\n\nWe can plot the results below. It is useful to compare these to the plot above generated with an SampledCorrelationsStatic.\n\nfig = Figure(; size=(1200,500))\nax = plot_intensities!(fig[1,1], Sq_pyro; title=\"Pyrochlore\")\nax = plot_intensities!(fig[1,2], Sq_mgcro; title=\"MgCrâ‚‚Oâ‚„\")\nfig\n\n(Image: )","category":"section"},{"location":"examples/spinw/SW18_Distorted_kagome.html","page":"SW18 - Distorted kagome","title":"SW18 - Distorted kagome","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW18_Distorted_kagome.html#SW18-Distorted-kagome","page":"SW18 - Distorted kagome","title":"SW18 - Distorted kagome","text":"This is a Sunny port of SpinW Tutorial 18, originally authored by Goran Nilsen and Sandor Toth. This tutorial illustrates spin wave calculations for KCuâ‚ƒAsâ‚‚Oâ‚‡(OD)â‚ƒ. The Cu ions are arranged in a distorted kagome lattice and exhibit an incommensurate helical magnetic order, as described in G. J. Nilsen, et al., Phys. Rev. B 89, 140412 (2014). The model follows Toth and Lake, J. Phys.: Condens. Matter 27, 166002 (2015).\n\nusing Sunny, GLMakie\n\nBuild the distorted kagome crystal, with spacegroup 12 (\"C 1 2/m 1\" setting).\n\nunits = Units(:meV, :angstrom)\nlatvecs = lattice_vectors(10.2, 5.94, 7.81, 90, 117.7, 90)\npositions = [[0, 0, 0], [1/4, 1/4, 0]]\ntypes = [\"Cu1\", \"Cu2\"]\ncryst = Crystal(latvecs, positions, \"C 1 2/m 1\"; types)\nview_crystal(cryst)\n\nDefine the interactions.\n\nmoments = [1 => Moment(s=1/2, g=2), 3 => Moment(s=1/2, g=2)]\nsys = System(cryst, moments, :dipole)\nJ   = -2\nJp  = -1\nJab = 0.75\nJa  = -J/.66 - Jab\nJip = 0.01\nset_exchange!(sys, J, Bond(1, 3, [0, 0, 0]))\nset_exchange!(sys, Jp, Bond(3, 5, [0, 0, 0]))\nset_exchange!(sys, Ja, Bond(3, 4, [0, 0, 0]))\nset_exchange!(sys, Jab, Bond(1, 2, [0, 0, 0]))\nset_exchange!(sys, Jip, Bond(3, 4, [0, 0, 1]))\n\nUse minimize_spiral_energy! to optimize the generalized spiral order. This determines the propagation wavevector k and fits the spin values within the unit cell. One must provide a fixed axis perpendicular to the polarization plane. For this system, all interactions are rotationally invariant and the axis vector is arbitrary. In other cases, a good axis will frequently be determined from symmetry considerations.\n\naxis = [0, 0, 1]\nrandomize_spins!(sys)\nk = minimize_spiral_energy!(sys, axis; k_guess=randn(3))\nplot_spins(sys; ndims=2)\n\nIf successful, the optimization process will find one two propagation wavevectors, Â±k_ref, with opposite chiralities. In this system, the spiral_energy_per_site is independent of chirality.\n\nk_ref = [0.785902495, 0.0, 0.107048756]\nk_ref_alt = [1, 0, 1] - k_ref\n@assert isapprox(k, k_ref; atol=1e-6) || isapprox(k, k_ref_alt; atol=1e-6)\n@assert spiral_energy_per_site(sys; k, axis) â‰ˆ -0.78338383838\n\nCheck the energy with a real-space calculation using a large magnetic cell. First, we must determine a lattice size for which k becomes approximately commensurate.\n\nsuggest_magnetic_supercell([k_ref]; tol=1e-3)\n\nResize the system as suggested and perform a real-space calculation. Working with a commensurate wavevector increases the energy slightly. The precise value might vary from run-to-run due to trapping in a local energy minimum.\n\nnew_shape = [14 0 1; 0 1 0; 0 0 2]\nsys2 = reshape_supercell(sys, new_shape)\nrandomize_spins!(sys2)\nminimize_energy!(sys2)\nenergy_per_site(sys2)\n\nReturn to the original system (with a single chemical cell) and construct SpinWaveTheorySpiral for calculations on the incommensurate spiral phase.\n\nmeasure = ssf_perp(sys; apply_g=false)\nswt = SpinWaveTheorySpiral(sys; measure, k, axis)\n\nPlot intensities for a path through ğª-space.\n\nqs = [[0,0,0], [1,0,0]]\npath = q_space_path(cryst, qs, 400)\nres = intensities_bands(swt, path)\nplot_intensities(res; units)\n\nPlot the powder-averaged intensities\n\nradii = range(0, 2, 100) # (1/Ã…)\nenergies = range(0, 5, 200)\nkernel = gaussian(fwhm=0.05)\nres = powder_average(cryst, radii, 400) do qs\n    intensities(swt, qs; energies, kernel)\nend\nplot_intensities(res; units)","category":"section"},{"location":"examples/contributed/kappa_tutorial.html#Enforcing-the-quantum-sum-rule-with-moment-renormalization","page":"Enforcing the quantum sum rule with moment renormalization","title":"Enforcing the quantum sum rule with moment renormalization","text":"AUTHOR: David Dahlbom (dahlbomda@ornl.gov), DATE: January 22, 2025 (Sunny 0.7.5)\n\nOne goal of the Sunny project is to extend classical techniques to incorporate a greater number of quantum effects. The generalization of the Landau-Lifshitz (LL) equations from SU(2) to SU(N) coherent states is the cornerstone of this approach [1], but Sunny includes a number of other \"classical-to-quantum\" corrections. For example, in the zero-temperature limit, there is a well-known correspondence between Linear Spin Wave Theory (LSWT) and the quantization of the normal modes of the linearized LL equations. This allows the dynamical spin structure factor (DSSF) that would be calculated with LSWT, mathcalS_mathrmQ(mathbfq omega), to be recovered from a DSSF that has been calculated classically, mathcalS_mathrmcl(mathbfq omega). This is achieved by applying a classical-to-quantum correspondence factor to mathcalS_mathrmcl(mathbfq omega):\n\nmathcalS_mathrmQ(mathbfq omega)=frachbaromegak_mathrmB T left1+ n_mathrmB(omegaT) right mathcalS_mathrmcl(mathbfq omega)\n\nSunny automatically applies this correction when you call intensity_static on a SampledCorrelations and provide a temperature. This will be demonstrated in the code example below.\n\nThe quantum structure factor satisfies a familiar \"zeroth-moment\" sum rule,\n\nintint dmathbfqdomegamathcalS_mathrmQ(mathbfq omega) = N_S S(S+1)\n\nwhere N_S is the number of sites. An immediate consequence of the correspondence is that the \"corrected\" classical structure factor satisfies the same sum rule:\n\nintint dmathbfqdomega frachbaromegak_mathrmB T left1+ n_mathrmB(omegaT) right mathcalS_mathrmcl(mathbfq omega) = N_S S(S+1)\n\nNote, however, that this correspondence depends on a harmonic oscillator approximation and only applies near T=0. This is reflected in the fact that the correction factor,\n\nfrachbaromegak_mathrmB T left1+ n_mathrmB(omegaT) right\n\napproaches unity for all omega whenever T grows large. In particular, this means that the corrected classical mathcalS_mathrmcl(mathbfq omega) will no longer satisfy the quantum sum rule at elevated temperatures. It will instead approach the \"classical sum rule\":\n\nlim_Trightarrowinftyintint dmathbfqdomega frachbaromegak_mathrmB T left1+ n_mathrmB(omegaT) right mathcalS_mathrmcl(mathbfq omega) = N_S S^2\n\n\nA simple approach to maintaining a classical-to-quantum correspondence at elevated temperatures is to renormalize the classical magnetic moments so that the quantum sum rule is satisfied. The renormalization factor can be determinied analytically in the infinite temperature limit [2]. For an arbitrary temperature, however, it must be determined empirically [3]. While determining an appropriate rescaling factor can be computationally expensive, Sunny makes it straightforward to evaluate spectral sums and apply moment renormalization, as shown below. One approach to determining the rescaling factors themselves is demonstrated in the sample code here.","category":"section"},{"location":"examples/contributed/kappa_tutorial.html#Evaluating-spectral-sums-in-Sunny","page":"Enforcing the quantum sum rule with moment renormalization","title":"Evaluating spectral sums in Sunny","text":"We'll begin by building a spin system representing the effective Spin-1 compound FeIâ‚‚. The functions for doing this are imported from kappa_supplementals.jl, available for download here.\n\nusing Sunny, LinearAlgebra\ninclude(joinpath(@__DIR__, \"kappa_supplementals.jl\"))\n\ndims = (8, 8, 4)\nseed = 102\nunits = Units(:meV, :angstrom)\nsys, cryst = FeI2_sys_and_cryst(dims; seed);\n\nWe will next estimate mathcalS_mathrmcl(mathbfq omega) using classical dynamics. (For more details on setting up such a calculation, see the tutorials in the official Sunny documentation.)\n\n# Parameters for generating equilbrium samples.\ndt_therm = 0.004                            # Step size for Langevin integrator\ndur_therm = 10.0                            # Safe thermalization time\ndamping = 0.1                               # Phenomenological coupling to thermal bath\nkT = 0.3 * units.K\nlangevin = Langevin(dt_therm; damping, kT)  # Langevin integrator\n\n# Parameters for sampling correlations.\ndt = 0.025                     # Integrator step size for dissipationless trajectories\nnsamples = 3                   # Number of dynamical trajectories to collect for estimating S(ğª,Ï‰)\nenergies = range(0, 10, 200);  # Energies to resolve, in meV, when calculating the dynamics\n\nSince FeIâ‚‚ is a Spin-1 material, we will use the SU(2S+1=3) formalism and require a set of N^2-1=8 observables to calculate the total spectral weight.\n\nSx, Sy, Sz = spin_matrices(1)  # Spin-1 representation of spin operators\nobservables = [\n\n    # Dipoles\n    Sx,\n    Sy,\n    Sz,\n\n    # Quadrupoles\n    -(Sx*Sz + Sz*Sx),\n    -(Sy*Sz + Sz*Sy),\n    Sx^2 - Sy^2,\n    Sx*Sy + Sy*Sx,\n    âˆš3 * Sz^2 - I*2/âˆš3,\n];\n\nAt the moment, Sunny does not expose a high-level interface for working with custom observables such as these. As a workaround, we will write low-level code that accesses the internal Sunny datastructure Sunny.MeasureSpec. The notation Sunny.* indicates that this functionality is not part of the public interface and is subject to change in future Sunny versions.\n\nBuilding a Sunny.MeasureSpec requires the following:\n\nAn array containing a set of N observables for each site of the system.\nA vector of tuples (n m), with 1 = n m = N. Each tuple specifies a pair of observables. Together these determine which correlations will be calculated.\nA function for reducing these correlation pairs into a final intensity.\nA list of form factors.\n\nThe Sunny.MeasureSpec below sums over the autocorrelations of each observable and disables form factor corrections.\n\nobservable_field = fill(Hermitian(zeros(ComplexF64, 3, 3)), length(observables), size(sys.coherents)...);\nfor site in Sunny.eachsite(sys), Î¼ in axes(observables, 1)\n    observable_field[Î¼, site] = Hermitian(observables[Î¼])\nend\ncorr_pairs = [(i, i) for i in 1:length(observables)]\ncombiner(_, data) = real(sum(data))\nmeasure = Sunny.MeasureSpec(observable_field, corr_pairs, combiner, [one(FormFactor)]);\n\nFinally, we can construct a SampledCorrelations and perform the calculations.\n\nsc = SampledCorrelations(sys; dt, energies, measure)\n\n# Thermalize and add several samples\nfor _ in 1:5_000\n    step!(sys, langevin)\nend\n\nfor _ in 1:nsamples\n    # Decorrelate sample\n    for _ in 1:2_000\n        step!(sys, langevin)\n    end\n    add_sample!(sc, sys)\nend\n\nsc now contains an estimate of mathcalS_mathrmcl(mathbfq omega). We next wish to evaluate the total spectral weight. We are working on a finite lattice and using discretized dynamics, so the integral will reduce to a sum. Since we'll be evaluating this sum repeatedly, we'll define a function to do this. (Note that this function only works on Bravais lattices â€“ To evaluate spectral sums on a decorated lattice, the sum rule needs to be evaluated on each sublattice individually!)\n\nfunction total_spectral_weight(sc::SampledCorrelations; kT = nothing)\n    # Retrieve all available discrete wave vectors in the equivalent of\n    # one Brillouin zone.\n    qs = Sunny.available_wave_vectors(sc)[:]\n\n    # Calculate the intensities. Note that we must include negative energies to\n    # evaluate the total spectral weight.\n    is = intensities(sc, qs; energies=:available_with_negative, kT)\n\n    return sum(is.data * sc.Î”Ï‰)\nend;\n\nNow evaluate the total spectral weight without temperature corrections.\n\ntotal_spectral_weight(sc) / (prod(sys.dims))\n\n1.3333333333333341\n\nThe result is 4/3, which is the expected \"classical\" sum rule. This reference can be established by evaluating sum_alphalangle Zvert T^alpha vert Z rangle^2 for any SU(3) coherent state Z, with T^alpha a complete set of generators of SU(3) â€“ for example, the observables above. However, the quantum sum rule is in fact 16/3, as can be determined by directly calculating sum_alpha(T^alpha)^2.\n\nNow let's try again, this time applying the classical-to-quantum correspondence factor by providing the simulation temperature.\n\ntotal_spectral_weight(sc; kT) / prod(sys.dims)\n\n5.480822137387149\n\nThis is relatively close to 16/3. So, at low temperatures, application of the classical-to-quantum correspondence factor yields results that (approximately) satisfy the quantum sum rule.\n\nThis will no longer hold at higher temperatures. Let's repeat the above experiment with a simulation temperature above T_N=305.\n\nsys, cryst = FeI2_sys_and_cryst(dims; seed)\nkT = 3.5 * units.K\nlangevin = Langevin(dt_therm; damping, kT)\nsc = SampledCorrelations(sys; dt, energies, measure)\n\n# Thermalize\nfor _ in 1:5_000\n    step!(sys, langevin)\nend\n\nfor _ in 1:nsamples\n    # Decorrelate sample\n    for _ in 1:2_000\n        step!(sys, langevin)\n    end\n    add_sample!(sc, sys)\nend\n\nEvaluating the sum without the classical-to-quantum correction factor will again give 4/3, as you can easily verify. Let's examine the result with the correction:\n\ntotal_spectral_weight(sc; kT) / prod(sys.dims)\n\n2.966494528272752\n\nWhile this is larger than the classical value of 4/3, it is still substantially short of the quantum value of 16/3.","category":"section"},{"location":"examples/contributed/kappa_tutorial.html#Implementing-moment-renormalization","page":"Enforcing the quantum sum rule with moment renormalization","title":"Implementing moment renormalization","text":"One way to enforce the quantum sum rule is by simply renormalizing the magnetic moments. In Sunny, this can be achieved by calling set_spin_rescaling!(sys, Îº), where Îº is the desired renormalization. Let's repeat the calculation above at the same temperature, this time setting Îº=125.\n\nsys, cryst = FeI2_sys_and_cryst(dims; seed)\nsc = SampledCorrelations(sys; dt, energies, measure)\nÎº = 1.25\n\n# Thermalize\nfor _ in 1:5_000\n    step!(sys, langevin)\nend\n\nfor _ in 1:nsamples\n    # Generate new equilibrium sample.\n    for _ in 1:2_000\n        step!(sys, langevin)\n    end\n\n    # Renormalize magnetic moments before collecting a time-evolved sample.\n    set_spin_rescaling!(sys, Îº)\n\n    # Generate a trajectory and calculate correlations.\n    add_sample!(sc, sys)\n\n    # Turn off Îº renormalization before generating a new equilibrium sample.\n    set_spin_rescaling!(sys, 1.0)\nend\n\nFinally, we evaluate the sum.\n\ntotal_spectral_weight(sc; kT) / prod(sys.dims)\n\n4.978319471602372\n\nThe result is something slightly greater than 5, substantially closer to the expected quantum sum rule. We can now adjust kappa and iterate until we reach a value sufficiently close to 16/3.  In general, this should be done while collecting substantially more statistics.\n\nNote that kappa (T) needs to be determined empirically for each model. A detailed example, demonstrating the calculations used in [3], is available here.","category":"section"},{"location":"examples/contributed/kappa_tutorial.html#References","page":"Enforcing the quantum sum rule with moment renormalization","title":"References","text":"[1] - H. Zhang, C. D. Batista, \"Classical spin dynamics based on SU(N) coherent states,\" PRB (2021)\n\n[2] - T. Huberman, D. A. Tennant, R. A. Cowley, R. Coldea and C. D. Frost, \"A study of the quantum classical crossover in the spin dynamics of the 2D S = 5/2 antiferromagnet Rb2MnF4: neutron scattering, computer simulations and analytic theories\" (2008)\n\n[3] - D. Dahlbom, D. Brooks, M. S. Wilson, S. Chi, A. I. Kolesnikov, M. B. Stone, H. Cao, Y.-W. Li, K. Barros, M. Mourigal, C. D. Batista, X. Bai, \"Quantum to classical crossover in generalized spin systems,\" arXiv:2310.19905 (2023)","category":"section"},{"location":"renormalization.html#Interaction-Renormalization","page":"Interaction Renormalization","title":"Interaction Renormalization","text":"A unique feature of Sunny is its support for building classical models where quantum spin is represented as an N-level system, rather than just an expected dipole. This generalization can be important when modeling quantum spin Hamiltonians that include, e.g., a single-ion anisotropy, or a biquadratic coupling between sites. Sunny also supports constraining quantum spin to the space of pure dipoles; in this case, Sunny will automatically perform an interaction strength renormalization that enhances accuracy.","category":"section"},{"location":"renormalization.html#Local-operators","page":"Interaction Renormalization","title":"Local operators","text":"A quantum spin-s state has N = 2s + 1 levels. Each local spin operator hatS^xyz is faithfully represented as an NN matrix. These matrices can be accessed using spin_matrices for a given label s. For example, the Pauli matrices are associated with s = 12.\n\nWhen s  12, it is possible to construct multipole moments beyond the spin-dipole. For example,\n\nS = spin_matrices(3/2)\n@assert S[3] â‰ˆ diagm([3/2, 1/2, -1/2, -3/2])\n@assert S[3]^2 â‰ˆ diagm([9/4, 1/4, 1/4, 9/4])\n\nIf the operator -S[3]^2 is passed to set_onsite_coupling!, it would set an easy-axis anisotropy in the hatz direction.\n\nAny Hermitian operator can be expanded in the basis of Stevens operators hatmathcalO_kq up to a constant shift. To see this expansion, use print_stevens_expansion:\n\nprint_stevens_expansion((S[1]^2 + S[2]^2)) # Prints -(1/3)ğ’ªâ‚‚â‚€ + 5/2\n\nAlternatively, the same operator could have been constructed directly from stevens_matrices:\n\nO = stevens_matrices(3/2)\n@assert S[1]^2 + S[2]^2 â‰ˆ -O[2, 0]/3 + (5/2)*I\n\nThe Stevens operators mathcalO_k q are defined below as kth order polynomials of the spin operators.","category":"section"},{"location":"renormalization.html#Renormalization-procedure-for-:dipole-mode","page":"Interaction Renormalization","title":"Renormalization procedure for :dipole mode","text":"Sunny will typically operate in one of two modes: :SUN or :dipole. The former faithfully represents quantum spin as an SU(N) coherent-state which, for our purposes, is an N-component complex vector. In contrast, :dipole mode constrains the coherent-state to the space of pure dipoles. Here, Sunny will automatically renormalize the magnitude of each Stevens expectation value to achieve maximal consistency with :SUN mode. This procedure was derived in D. Dahlbom et al., [arXiv:2304.03874].\n\nBy way of illustration, consider a quantum operator hatmathcalH_mathrmlocal giving a single-ion anisotropy for one site. It can be expanded in Stevens operators,\n\nhatmathcal H_mathrmlocal = sum_k q A_kq hatmathcalO_kq\n\nfor some coefficients A_kq.\n\nIn :SUN mode, Sunny will faithfully represent hatmathcal H_mathrmlocal as an NN matrix. In :dipole mode, the expected energy langle hatmathcal H_mathrmlocal rangle must somehow be approximated using the expected dipole data.\n\nOne approach is to formally take s to infty, and this yields the traditional classical limit of a spin system. In this limit spin operators commute and expectation values of polynomials become polynomials of expectation values. For example, langle hatS^alpha hatS^betarangle to langle hatS^alpha rangle langle hatS^betarangle, because any corrections are damped by the factor s^-1 to 0. The expectation of a Stevens operator langle hatmathcalO_kq rangle would then become a classical Stevens function mathcalO_kq(langlehatmathbfSrangle), i.e., a polynomial of the same form, but now applied to the expected dipole. Classical Stevens functions are constructed as homogeneous polynomials of order k, because lower-order terms would vanish in the limit s to infty.\n\nFor real compounds with finite quantum spin-s, one can obtain a better approximation by avoiding the formal s to infty limit. Corrections can be derived by starting from the full dynamics of SU(N) coherent states and then constraining to the space of pure dipole states boldsymbolOmegarangle. The latter are defined as any states where the expected dipole 3-vector,\n\nboldsymbolOmega  langle boldsymbolOmega hatmathbfS  boldsymbolOmegarangle\n\nhas maximal magnitude boldsymbolOmega = s and arbitrary direction.\n\nFor a pure dipole state, group theory dictates that expectations of the Stevens operators can be expressed as a renormalization of the classical Stevens functions,\n\nlangle boldsymbolOmega hatmathcalO_kq  boldsymbolOmegarangle = c_k mathcalO_kq(boldsymbolOmega)\n\nAt fixed k, the two sides must be proportional because they are both spin-k irreducible representations of SO(3). The renormalization factors can be calculated explicitly:\n\nbeginalign*\nc_1 = 1 \nc_2 = 1-frac12s^-1 \nc_3 = 1-frac32s^-1+frac12s^-2 \nc_4 = 1-3s^-1+frac114s^-2-frac34s^-3 \nc_5 = 1-5s^-1+frac354s^-2-frac254s^-3+frac32s^-4 \nc_6 = 1-frac152s^-1+frac854s^-2-frac2258s^-3+frac1378s^-4-frac154s^-5 \nvdots\nendalign*\n\nConstrained to the space of dipoles, the expected local energy becomes\n\nE_mathrmlocal(boldsymbolOmega) = langle boldsymbolOmega hatmathcal H_mathrmlocal  boldsymbolOmegarangle = sum_k q c_k A_kq mathcalO_kq(boldsymbolOmega)\n\nIt can be shown that SU(N) dynamics reduces to the usual Landau-Lifshitz dynamics of dipoles, but involving E_mathrmlocal(boldsymbolOmega) as the classical Hamiltonian. The renormalization factors c_k can therefore be interpreted as a correction to the traditional large-s classical limit.\n\nRenormalization also applies to the coupling between different sites. In Sunny, couplings will often be expressed as a polynomial of spin operators using set_pair_coupling!, but any such coupling can be decomposed as a sum of tensor products of Stevens operators. Without loss of generality, consider a single coupling between two Stevens operators hatmathcalH_mathrmcoupling = hatmathcalO_kq otimes hatmathcalO_kq along a bond connecting sites i and j. Upon constraining to pure dipole states boldsymbolOmega_irangle and boldsymbolOmega_jrangle, the expected energy takes the form E_mathrmcoupling = c_k c_k mathcalO_kq(boldsymbolOmega_i) mathcalO_kq(boldsymbolOmega_j), which now involves a product of renormalized Stevens functions. ","category":"section"},{"location":"renormalization.html#Use-:dipole_uncorrected-mode-to-disable-renormalization","page":"Interaction Renormalization","title":"Use :dipole_uncorrected mode to disable renormalization","text":"The above renormalization procedure is valid under the assumption that the starting model is the true microscopic quantum Hamiltonian. Sometimes, however, the starting model is instead an effective classical Hamiltonian that has been fitted to experimental data. In this case, the model parameters will already incorporate any appropriate renormalizations, and no further renormalization should be applied. Similarly, renormalization is unneeded for effective models of micromagnets that are far from the quantum regime.\n\nTo specify an effective spin-dipole Hamiltonian with renormalization disabled, construct a System using the mode :dipole_uncorrected instead of :dipole. Formally, :dipole_uncorrected takes the s   limit, such that all local operators become infinite dimensional and commute. A symbolic representation of these operators can be obtained by passing Inf to either spin_matrices or stevens_matrices. Polynomials of such spin operators can be used, e.g., in set_onsite_coupling!.","category":"section"},{"location":"renormalization.html#Definition-of-Stevens-operators","page":"Interaction Renormalization","title":"Definition of Stevens operators","text":"The Stevens operators hatmathcalO_kq are defined as polynomials of angular momentum operators hatS_xyz in some spin-s representation.\n\nUsing\n\nbeginalign*\nX = mathbfhatS cdot mathbfhatS = s (s+1) \nhatS_pm = hatS_x pm i hatS_y \nphi_+ = frac14quad phi_- = frac14 i\nendalign*\n\nthe relevant Stevens operators are defined as,\n\nbeginalign*\nhatmathcalO_00  =1\n\nhatmathcalO_1pm1  =phi_pm(hatS_+pmhatS_-)+mathrmhc\nhatmathcalO_10  =hatS_z\n\nhatmathcalO_2pm2  =phi_pm(hatS_+^2pmhatS_-^2)+mathrmhc\nhatmathcalO_2pm1  =phi_pm(hatS_+pmhatS_-)hatS_z+mathrmhc\nhatmathcalO_20  =3hatS_z^2-X\n\nhatmathcalO_3pm3  =phi_pm(hatS_+^3pmhatS_-^3)+mathrmhc\nhatmathcalO_3pm2  =phi_pm(hatS_+^2pmhatS_-^2)hatS_z+mathrmhc\nhatmathcalO_3pm1  =phi_pm(hatS_+pmhatS_-)(5hatS_z^2-X-12)+mathrmhc\nhatmathcalO_30  =5hatS_z^3-(3X-1)hatS_z\n\nhatmathcalO_4pm4  =phi_pm(hatS_+^4pmhatS_-^4)+mathrmhc\nhatmathcalO_4pm3  =phi_pm(hatS_+^3pmhatS_-^3)hatS_z+mathrmhc\nhatmathcalO_4pm2  =phi_pm(hatS_+^2pmhatS_-^2)(7hatS_z^2-(X+5))+mathrmhc\nhatmathcalO_4pm1  =phi_pm(hatS_+pmhatS_-)(7hatS_z^3-(3X+1)hatS_z)+mathrmhc\nhatmathcalO_40  =35hatS_z^4-(30X-25)hatS_z^2+(3X^2-6X)\n\nhatmathcalO_5pm5  =phi_pm(hatS_+^5pmhatS_-^5)+mathrmhc\nhatmathcalO_5pm4  =phi_pm(hatS_+^4pmhatS_-^4)hatS_z+mathrmhc\nhatmathcalO_5pm3  =phi_pm(hatS_+^3pmhatS_-^3)(9hatS_z^2-(X+332))+mathrmhc\nhatmathcalO_5pm2  =phi_pm(hatS_+^2pmhatS_-^2)(3hatS_z^3-(X+6)hatS_z)+mathrmhc\nhatmathcalO_5pm1  =phi_pm(hatS_+pmhatS_-)(21hatS_z^4-14XhatS_z^2+(X^2-X+32))+mathrmhc\nhatmathcalO_50  =63hatS_z^5-(70X-105)hatS_z^3+(15X^2-50X+12)hatS_z\n\nhatmathcalO_6pm6  =phi_pm(hatS_+^6pmhatS_-^6)+mathrmhc\nhatmathcalO_6pm5  =phi_pm(hatS_+^5pmhatS_-^5)hatS_z+mathrmhc\nhatmathcalO_6pm4  =phi_pm(hatS_+^4pmhatS_-^4)(11hatS_z^2-X-38)+mathrmhc\nhatmathcalO_6pm3  =phi_pm(hatS_+^3pmhatS_-^3)(11hatS_z^3-(3X+59)hatS_z)+mathrmhc\nhatmathcalO_6pm2  =phi_pm(hatS_+^2pmhatS_-^2)(33hatS_z^4-(18X+123)hatS_z^2+X^2+10X+102)+mathrmhc\nhatmathcalO_6pm1  =phi_pm(hatS_+pmhatS_-)(33hatS_z^5-(30X-15)hatS_z^3+(5X^2-10X+12)hatS_z)+mathrmhc\nhatmathcalO_60  =231hatS_z^6-(315X-735)hatS_z^4+(105X^2-525X+294)hatS_z^2-5X^3+40X^2-60X\nendalign*\n\nComputer-generated tables of Stevens operators with k  6 are available from C. Rudowicz and C. Y. Chung, J. Phys.: Condens. Matter 16, 5825 (2004), but these typically do not appear in magnetic simulations.\n\nThe case k=1 gives the dipole operators,\n\n(hatmathcalO_11 hatmathcalO_10 hatmathcalO_1-1) = (hatS_x hatS_z hatS_y)\n\nThe case k=2 gives the quadrupole operators,\n\n(hatmathcalO_22 dots hatmathcalO_2-2) = left(hatS_x^2 - hatS_y^2 frachatS_x hatS_z + hatS_z hatS_x2 2hatS_z^2-hatS_x^2-hatS_y^2 frachatS_y hatS_z + hatS_z hatS_y2 hatS_x hatS_y + hatS_y hatS_xright)\n\nFor each k value, the set of operators hatmathcalO_kq for q = -k dots k form an irreducible representation of the group of rotations O(3). That is, rotation will transform hatmathcalO_kq into a linear combination of hatmathcalO_kq where q varies but k remains fixed. \n\nIn taking the large-s limit, each dipole operator is replaced by its expectation value boldsymbolOmega = langle hatmathbfS rangle, and only leading-order terms are retained. The operator hatmathcalO_kq becomes a homogeneous polynomial O_kq(boldsymbolOmega) of order k in the spin components Omega^alpha. One can see these polynomials by constructing stevens_matrices with the argument s = Inf. Due to the normalization constraint, each dipole can be expressed in polar angles, (theta phi). Then the Stevens functions O_kq(boldsymbolOmega) correspond to the spherical harmonic functions Y_l^m(theta phi) where l=k and m=q; this correspondence is valid up to k and q-dependent rescaling factors.","category":"section"},{"location":"examples/09_Disorder_KPM.html","page":"9. Disordered systems","title":"9. Disordered systems","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/09_Disorder_KPM.html#9.-Disordered-systems","page":"9. Disordered systems","title":"9. Disordered systems","text":"This example uses SpinWaveTheoryKPM to efficiently calculate the neutron scattering spectrum of a disordered triangular antiferromagnet. The model is inspired by YbMgGaO4, as studied in Paddison et al, Nature Phys., 13, 117â€“122 (2017) and Zhu et al, Phys. Rev. Lett. 119, 157201 (2017). Disordered occupancy of non-magnetic Mg/Ga sites can be modeled as a stochastic distribution of exchange constants and g-factors. Including this disorder introduces broadening of the spin wave spectrum.\n\nusing Sunny, GLMakie\n\nSet up minimal triangular lattice system. Include antiferromagnetic exchange interactions between nearest neighbor bonds. An optional seed for random number generation makes the calculations exactly reproducible on a fixed Julia version.\n\nlatvecs = lattice_vectors(1, 1, 10, 90, 90, 120)\ncryst = Crystal(latvecs, [[0, 0, 0]])\nsys = System(cryst, [1 => Moment(s=1/2, g=1)], :dipole; dims=(3, 3, 1), seed=0)\nset_exchange!(sys, +1.0, Bond(1, 1, [1,0,0]))\n\nEnergy minimization yields the magnetic ground state with 120Â° angles between spins in triangular plaquettes.\n\nrandomize_spins!(sys)\nminimize_energy!(sys)\nplot_spins(sys; color=[S[3] for S in sys.dipoles], ndims=2)\n\nSelect a ğª-space path for the spin wave calculations.\n\nqs = [[0, 0, 0], [1/3, 1/3, 0], [1/2, 0, 0], [0, 0, 0]]\nlabels = [\"Î“\", \"K\", \"M\", \"Î“\"]\npath = q_space_path(cryst, qs, 150; labels)\n\nPerform a traditional spin wave calculation. The spectrum shows sharp modes associated with coherent excitations about the K-point ordering wavevector, ğª = 13 13 0.\n\nkernel = lorentzian(fwhm=0.4)\nenergies = range(0.0, 3.0, 150)\nswt = SpinWaveTheory(sys; measure=ssf_perp(sys))\nres = intensities(swt, path; energies, kernel)\nplot_intensities(res)\n\nUse repeat_periodically to enlarge the system by a factor of 10 in each dimension. Use to_inhomogeneous to disable symmetry constraints and allow for the addition of disordered interactions.\n\nsys_inhom = to_inhomogeneous(repeat_periodically(sys, (10, 10, 1)))\n\nIterate over all symmetry_equivalent_bonds for nearest neighbor sites in the inhomogeneous system. Set the AFM exchange to include a noise term that has a standard deviation of 1/3. The newly minimized energy configuration allows for long wavelength modulations on top of the original 120Â° order.\n\nfor (site1, site2, offset) in symmetry_equivalent_bonds(sys_inhom, Bond(1, 1, [1, 0, 0]))\n    noise = randn(sys_inhom.rng)/3\n    set_exchange_at!(sys_inhom, 1.0 + noise, site1, site2; offset)\nend\n\nminimize_energy!(sys_inhom, maxiters=2_000)\nplot_spins(sys_inhom; color=[S[3] for S in sys_inhom.dipoles], ndims=2)\n\nTraditional spin wave theory with exact diagonalization becomes impractical for large system sizes. Using SpinWaveTheoryKPM, the cost of an intensities calculation becomes linear in the system size, with a prefactor that inversely in the width of the line broadening kernel. Good choices for the dimensionless error tolerance are tol=0.05 (more speed) or tol=0.01 (more accuracy).\n\nObserve that disorder in the nearest-neighbor exchange serves to broaden the discrete excitation bands into a continuum.\n\nswt = SpinWaveTheoryKPM(sys_inhom; measure=ssf_perp(sys_inhom), tol=0.05)\nres = intensities(swt, path; energies, kernel)\nplot_intensities(res)\n\nNow apply a magnetic field of magnitude 7.5 (energy units) along the global z axis. This field fully polarizes the spins and opens a gap. The spin wave spectrum shows a sharp mode at the Î“-point (zone center) that broadens into a continuum along the K and M points (zone boundary).\n\nset_field!(sys_inhom, [0, 0, 7.5])\nrandomize_spins!(sys_inhom)\nminimize_energy!(sys_inhom)\n\nenergies = range(0.0, 9.0, 150)\nswt = SpinWaveTheoryKPM(sys_inhom; measure=ssf_perp(sys_inhom), tol=0.05)\nres = intensities(swt, path; energies, kernel)\nplot_intensities(res)\n\nAdd disorder to the z-component of each magnetic moment g-tensor. This further broadens intensities, now across the entire path. Some intensity modulation within the continuum is also apparent. This modulation is a finite-size effect and would be mitigated by enlarging the system beyond 30Ã—30 chemical cells.\n\nfor site in eachsite(sys_inhom)\n    noise = randn(sys_inhom.rng)/6\n    sys_inhom.gs[site] = [1 0 0; 0 1 0; 0 0 1+noise]\nend\nrandomize_spins!(sys_inhom)\nminimize_energy!(sys_inhom)\n\nswt = SpinWaveTheoryKPM(sys_inhom; measure=ssf_perp(sys_inhom), tol=0.05)\nres = intensities(swt, path; energies, kernel)\nplot_intensities(res)\n\nFor reference, the equivalent non-disordered system shows a single coherent mode.\n\nset_field!(sys, [0, 0, 7.5])\nrandomize_spins!(sys)\nminimize_energy!(sys)\nswt = SpinWaveTheory(sys; measure=ssf_perp(sys))\nres = intensities(swt, path; energies, kernel)\nplot_intensities(res)","category":"section"},{"location":"examples/contributed/entangled_units.html#Entangled-Units-Formalism","page":"Entangled Units Formalism","title":"Entangled Units Formalism","text":"AUTHOR David Dahlbom (dahlbomda@ornl.gov), DATE: January 21, 2025, UPDATED: June 30, 2025\n\nTraditional \"large-S\" classical methods start by modeling a spin system as a set of dipoles (equivalently, 2-level quantum systems) on each site of a lattice. This is corresponds to the assumption that the global wave function is a product of two-level states (more precisely, product of SU(2) coherent states). In classical dynamics, these different two-level systems interact with each other, but they are never entangled: the classical dynamics evolves product states into other product states, meaning that one can always think about the state of a system as a set of individual dipoles existing on each site of the lattice for all time.\n\nThe SU(N) formalism extends this picture in a straightforward way. Instead of having a two-level system on each site, one has an N-level system. The product state assumption remains. This allows the local behavior to be richer than that of a simple dipole. These local N-level systems interact with each other in the classical picture, but they are never entangled. The treatment of each individual N-level system is quantum mechanical, however. Thus, if one puts two-spins inside each one of these sites, the entanglement between the two spins will be faithfully represented and evolved in a \"classical\" formalism.\n\nThis tutorial gives a simple illustration of this idea using Sunny's entangled unit formalism. The first model we will consider is the the strong-rung S=1/2 ladder.","category":"section"},{"location":"examples/contributed/entangled_units.html#Making-an-EntangledSystem-for-the-Heisenberg-spin-ladder","page":"Entangled Units Formalism","title":"Making an EntangledSystem for the Heisenberg spin ladder","text":"The approach to modeling systems with localized entangled is to first build a System in the standard way, with an individual spin on each site. Interactions are specified as usual. Note that this system must be built in :SUN mode, even when S=1/2. Another important restriction is that any group of spins which one wishes to entangle must lie entirely within a crystalographic unit cell. This may require reshaping from the conventional unit cell or displacing the atoms from their standard positions within the unit cell. We plan to automate this step in later versions. The spin ladder presents no difficulties in this regard.\n\nSpecify a the crystal.\n\nusing Sunny, LinearAlgebra, GLMakie\n\nlatvecs = lattice_vectors(1, 1, 2, 90, 90, 90)\npositions = [[0, 0, 0], [0, 1/2 - 1e-4, 0]]\ncrystal = Crystal(latvecs, positions)\nview_crystal(crystal)\n\n(Image: )\n\nTo model a quasi-1D system, symmetry must be broken along the b-axis by making bonds 1 -> 2 and 2 -> 1 inequivalent. This was achieved by offsetting the position of the second atom slightly from [0, 0.5, 0].\n\nSpecify a system and the two exchange interactions, J (rungs) and Jâ€² (lengthwise bonds).\n\nJ = 1\nJâ€² = 0.2J\nsys = System(crystal, [1 => Moment(s=1/2, g=2)], :SUN; dims=(2, 1, 1))\nset_exchange!(sys, J, Bond(1, 2, [0, 0, 0]))\nset_exchange!(sys, Jâ€², Bond(1, 1, [1, 0, 0]));\n\nThis completes specification of the model without consideration for entanglement between the sites bonded by rungs. Examine a ground state of this system.\n\nrandomize_spins!(sys)\nminimize_energy!(sys)\nplot_spins(sys)\n\n(Image: )","category":"section"},{"location":"examples/contributed/entangled_units.html#Spin-Wave-Calculations","page":"Entangled Units Formalism","title":"Spin Wave Calculations","text":"The last result is the expected classical ordering, with full-length dipoles arranged antiferromagnetically. This results in a q=(Ï€,Ï€) ordering. Because this model is Heisenberg, the Hamiltonian has an SU(2) symmetry, and any such ground state breaks this symmetry. This will lead to a Goldstone mode, as can readily be seen when we calculate the excitations with spin wave theory.\n\nswt = SpinWaveTheory(sys; measure=ssf_trace(sys))\nqs = q_space_path(crystal, [[0, 1, 0], [1/2, 1, 0], [1, 1, 0]], 200)\nenergies = range(0, 2.5, 200)\nres = intensities(swt, qs; energies, kernel=gaussian(; fwhm=0.2))\nplot_intensities(res)\n\n(Image: )\n\nThis result is incorrect for such a small Jâ€². Instead, the ground state on each bond should be a singlet, i.e. non-magnetic. Correspondingly, the excitations should be gapped singlet-triplet excitations. This can be reproduced using the entangled units formalism. An EntangledSystem is constructed from an ordinary System by providing a list of sites \"to entangle\" within each unit cell.\n\nesys = Sunny.EntangledSystem(sys, [(1, 2)])\nrandomize_spins!(esys)\nminimize_energy!(esys)\nplot_spins(esys)\n\n(Image: )\n\nThe ground state here is a pair of singlets, and the magnitude of the dipoles on each site is zero (up to numerical precision). The ordering wave vector is now q=0, so the system should be reshaped into the magnetic unit cell (one bond) before performing spin wave calculations.\n\nesys = reshape_supercell(esys, I(3))\nplot_spins(esys)\n\n(Image: )\n\nNext create a SpinWaveTheory and calculate intensities just as would be done for an ordinary Sunny System.\n\neswt = SpinWaveTheory(esys; measure=ssf_trace(esys))\nres = intensities(eswt, qs; energies, kernel=gaussian(; fwhm=0.2))\nplot_intensities(res)\n\n(Image: )\n\nThis produces the expected gapped, triplon mode. Note that this mode is only visible when looking at the antisymmetric channel. Since we placed our second atom at a position of 1/2 along the b-axis, the excitations are visible along [H, 1, 0].","category":"section"},{"location":"examples/contributed/entangled_units.html#Finite-T-Classical-Calculations","page":"Entangled Units Formalism","title":"Finite-T Classical Calculations","text":"As with ordinary Systemss, excitations may also be calculated at finite temperature using classical dynamics using the SU(N) generalization of the Landau-Lifshitz equations. Now we need to construct a system with enough sites along the a-axis so that we have sufficient momentum resolution to resolve the dispersion.\n\nesys = repeat_periodically(esys, (20, 1, 1))\n\ndamping = 0.2\nkT = 0.1J\nintegrator = Langevin(; damping, kT)\nsuggest_timestep(esys, integrator; tol=1e-2)\ndt = integrator.dt = 0.13\n\nfor _ in 1:500\n    step!(esys, integrator)\nend;\n\nConsider dt â‰ˆ 0.1307 for this spin configuration at tol = 0.01000.\n\n\nNext construct an SampledCorrelations and collect the correlations of sampled trajectories.\n\nsc = SampledCorrelations(esys; energies, dt, measure=ssf_trace(esys))\n\nfor _ in 1:100\n    for _ in 1:300\n        step!(esys, integrator)\n    end\n    add_sample!(sc, esys)\nend;\n\nFinally we retrieve intensity information along the same path as above. For comparison, also look along the zero-channel, where the intensities will look much different.\n\nqs_0 = q_space_path(crystal, [[0, 0, 0], [1/2, 0, 0], [1, 0, 0]], 200)\nqs_Ï€ = q_space_path(crystal, [[0, 1, 0], [1/2, 1, 0], [1, 1, 0]], 200)\n\nres_0 = intensities(sc, qs_0; energies=:available, kT)\nres_Ï€ = intensities(sc, qs_Ï€; energies=:available, kT)\n\nfig = Figure(size=(800, 400))\nplot_intensities!(fig[1,1], res_0; title=\"Symmetric Channel\")\nplot_intensities!(fig[1,2], res_Ï€; title=\"Anti-symmetric Channel\")\nfig\n\n(Image: )\n\nNote that the classical dynamics reproduces the same dispersion as spin wave theory. We can now easily examine the behavior of the system at much higher temperatures where the classical theory can be expected to be even more accurate.\n\nsc = SampledCorrelations(esys; energies, dt, measure=ssf_trace(esys))\n\nintegrator.kT = 20.0J\nfor _ in 1:500\n    step!(esys, integrator)\nend\n\nfor _ in 1:100\n    for _ in 1:300\n        step!(esys, integrator)\n    end\n    add_sample!(sc, esys)\nend\n\nres_0 = intensities(sc, qs_0; energies=:available, kT)\nres_Ï€ = intensities(sc, qs_Ï€; energies=:available, kT)\n\nfig = Figure(size=(800, 400))\nplot_intensities!(fig[1,1], res_0; title=\"Symmetric Channel\")\nplot_intensities!(fig[1,2], res_Ï€; title=\"Anti-symmetric Channel\")\nfig\n\n(Image: )\n\nA pseudogap persists even well above the ordering temperature, in agreement with exact solutions. This is in contrast with traditional Landau-Lifshitz dynamics, which remains gapless throughout all temperatures.\n\nFor a more complete study of this model, see D. Dahlbom et al., PRB 110 (2024).","category":"section"},{"location":"examples/contributed/entangled_units.html#Material-Example:-BaMnO","page":"Entangled Units Formalism","title":"Material Example: Baâ‚ƒMnâ‚‚Oâ‚ˆ","text":"As a more realistic example, this section briefly demonstrates how to reproduce the zero-field dispersion of Baâ‚ƒMnâ‚‚Oâ‚ˆ. This material consists of triangular lattice of S=1 bilayers in an ABC stacking.\n\nFirst load the crystal and extract the magnetic subcrystal.\n\ncrystal_full = Crystal(joinpath(@__DIR__, \"Ba3Mn2O8.cif\"); symprec=0.01)\ncrystal = subcrystal(crystal_full, \"Mn1\")\nview_crystal(crystal)\n\n(Image: )\n\nEach site hosts a single S=1 spin subject to an easy-axis anisotropy. The spins interact with each other antiferromagnetically through a number of Heisenberg exchange interactions.\n\nsys = System(crystal, [1 => Moment(s=1, g=2)], :SUN)\n\nJ0 = 1.642\nJ1 = 0.118\nJ2 = 0.256\nJ3 = 0.142\nJ4 = 0.037\nset_exchange!(sys, J0, Bond(1, 2, [0, 0, 0]))\nset_exchange!(sys, J1, Bond(2, 3, [0, 0, 0]))\nset_exchange!(sys, J2, Bond(1, 1, [1, 0, 0]))\nset_exchange!(sys, J3, Bond(1, 2, [1, 0, 0]))\nset_exchange!(sys, J4, Bond(4, 5, [0, 1, 0]))\n\nD = -0.032\nset_onsite_coupling!(sys, S -> D*S[3]^2, 1);\n\nThe strong antiferromagnetic exchange on the 1 -> 2, 3 -> 4 and 5 -> 6 bonds results in dimerization and a ground state that is a product of singlets. This physics can be capture by treating each dimer as a single entangled unit.\n\ndimers = [(1, 2), (3, 4), (5, 6)]\nesys = Sunny.EntangledSystem(sys, dimers)\n\nEntangledSystem [SU(9)]\nSupercell (1Ã—1Ã—1)Ã—6\nEnergy per site 4431/1000\n\n\nExamine the ground state.\n\nrandomize_spins!(esys)\nminimize_energy!(esys)\nplot_spins(esys)\n\n(Image: )\n\nObserve that there is effectively no magnetic moment, up to numerical roundoff. This ground state can then be used to perform a spin wave calculation.\n\nformfactors = [1 => FormFactor(\"Mn5\")]\nmeasure = ssf_perp(esys; formfactors)\nswt = SpinWaveTheory(esys; measure)\n\nfwhm = 0.295\npoints = [\n    [0.175, 0.175, 1.5],\n    [0.85, 0.85, 1.5],\n    [0.85, 0.85, 3],\n    [0.0, 0.0, 3],\n    [0.0, 0.0, 8],\n]\nqpts = q_space_path(crystal, points, 400)\nenergies = range(0.0, 4.0, 400)\nres = intensities(swt, qpts; energies, kernel=gaussian(; fwhm))\n\nplot_intensities(res)\n\n(Image: )\n\nCompare the resulting dispersion and intensities with the scattering data reported in Stone et al., PRL 100 (2008).","category":"section"},{"location":"examples/spinw/SW05_Simple_kagome_FM.html","page":"SW05 - Simple kagome ferromagnet","title":"SW05 - Simple kagome ferromagnet","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW05_Simple_kagome_FM.html#SW05-Simple-kagome-ferromagnet","page":"SW05 - Simple kagome ferromagnet","title":"SW05 - Simple kagome ferromagnet","text":"This is a Sunny port of SpinW Tutorial 5, originally authored by Bjorn Fak and Sandor Toth. It calculates the spin wave spectrum of the kagome lattice with a nearest-neighbor ferromagnetic coupling.\n\nLoad Sunny and the GLMakie plotting package.\n\nusing Sunny, GLMakie\n\nDefine the chemical cell. By specifying spacegroup 147 (P-3), Sunny will propagate the position [1/2, 0, 0] to the three symmetry-equivalent sites of the kagome unit cell.\n\nunits = Units(:meV, :angstrom)\nlatvecs = lattice_vectors(6, 6, 5, 90, 90, 120)\npositions = [[1/2, 0, 0]]\ncryst = Crystal(latvecs, positions, 147)\n\nAnother way to construct the kagome lattice is to provide all three site positions of the chemical cell and allow Sunny to infer the largest possible group of symmetry operations. In this case, Sunny infers spacegroup 191 (P6/mmm). Because 191 has more symmetry operations than 147, it will impose more constraints on the allowed 3Ã—3 exchange matrices. Isotropic Heisenberg exchange, however, is always allowed.\n\npositions = [[1/2, 0, 0], [0, 1/2, 0], [1/2, 1/2, 0]]\ncryst2 = Crystal(latvecs, positions)\n\nView the kagome lattice\n\nview_crystal(cryst; ndims=2)\n\nConstruct a spin system with nearest-neighbor ferromagnetic interactions.\n\nsys = System(cryst, [1 => Moment(s=1, g=2)], :dipole)\nJ = -1.0\nset_exchange!(sys, J, Bond(2, 3, [0, 0, 0]))\n\nEnergy minimization yields the expected ferromagnetic order. Each site participates in 4 bonds, which contributes energy 4J/2.\n\nrandomize_spins!(sys)\nminimize_energy!(sys)\nenergy_per_site(sys)\n@assert energy_per_site(sys) â‰ˆ 4J/2\nplot_spins(sys; ndims=2)\n\nCalculate and plot intensities for a path through ğª-space.\n\nswt = SpinWaveTheory(sys; measure=ssf_perp(sys))\nqs = [[-1/2, 0, 0], [0, 0, 0], [1/2, 1/2, 0]]\npath = q_space_path(cryst, qs, 400)\nres = intensities_bands(swt, path)\nplot_intensities(res; units)\n\nCalculate and plot the powder average with two different magnitudes of Gaussian line-broadening. Pick an explicit intensity colorrange (as a density in meV) so that the two color scales are consistent.\n\nradii = range(0, 2.5, 200)\nenergies = range(0, 6.5, 200)\nres1 = powder_average(cryst, radii, 1000) do qs\n    intensities(swt, qs; energies, kernel=gaussian(fwhm=0.02))\nend\nres2 = powder_average(cryst, radii, 1000) do qs\n    intensities(swt, qs; energies, kernel=gaussian(fwhm=0.25))\nend\n\nfig = Figure(size=(768, 800))\nplot_intensities!(fig[1, 1], res1; units, colorrange=(0,10), title=\"FWHM 0.02 meV\")\nplot_intensities!(fig[2, 1], res2; units, colorrange=(0,10), title=\"FWHM 0.25 meV\")\nfig","category":"section"},{"location":"examples/spinw/SW07_k0_kagome_AFM.html","page":"SW07 - k=0 kagome antiferromagnet","title":"SW07 - k=0 kagome antiferromagnet","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW07_k0_kagome_AFM.html#SW07-k0-kagome-antiferromagnet","page":"SW07 - k=0 kagome antiferromagnet","title":"SW07 - k=0 kagome antiferromagnet","text":"This is a Sunny port of SpinW Tutorial 7, originally authored by Bjorn Fak and Sandor Toth. It calculates the spin wave spectrum of the kagome lattice with antiferromagnetic interactions, with ordering wavevector of ğ¤ = 0, and relative rotation 120Â° between sublattices\n\nLoad Sunny and the GLMakie plotting package.\n\nusing Sunny, GLMakie\n\nDefine the chemical cell of a kagome lattice with spacegroup 147 (P-3).\n\nunits = Units(:meV, :angstrom)\nlatvecs = lattice_vectors(6, 6, 8, 90, 90, 120)\ncryst = Crystal(latvecs, [[1/2, 0, 0]], 147)\nview_crystal(cryst; ndims=2)\n\nConstruct a spin system with nearest and next-nearest neighbor antiferromagnetic interactions. Energy minimization determines a ğ¤ = 0 magnetic order with 120Â° rotation between the three sublattices. The overall global rotation in spin-space is arbitrary.\n\nsys = System(cryst, [1 => Moment(s=1, g=2)], :dipole)\nJ1 = 1.0\nJ2 = 0.11\nset_exchange!(sys, J1, Bond(2, 3, [0, 0, 0]))\nset_exchange!(sys, J2, Bond(2, 1, [0, 0, 0]))\nrandomize_spins!(sys)\nminimize_energy!(sys)\nplot_spins(sys; ndims=2)\n\nCalculate and plot intensities for a path through ğª-space.\n\nswt = SpinWaveTheory(sys; measure=ssf_perp(sys))\nqs = [[-1/2,0,0], [0,0,0], [1/2,1/2,0]]\npath = q_space_path(cryst, qs, 400)\nres = intensities_bands(swt, path)\nplot_intensities(res; units)\n\nCalculate and plot the powder averaged spectrum\n\nradii = range(0, 2.5, 200)\nenergies = range(0, 2.5, 200)\nkernel = gaussian(fwhm=0.02)\nres = powder_average(cryst, radii, 1000) do qs\n    intensities(swt, qs; energies, kernel)\nend\nplot_intensities(res; units)","category":"section"},{"location":"examples/spinw/SW09_k0_kagome_AFM_DM.html","page":"SW09 - k=0 kagome AFM and DM","title":"SW09 - k=0 kagome AFM and DM","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW09_k0_kagome_AFM_DM.html#SW09-k0-kagome-AFM-and-DM","page":"SW09 - k=0 kagome AFM and DM","title":"SW09 - k=0 kagome AFM and DM","text":"This is a Sunny port of SpinW Tutorial 9, originally authored by Bjorn Fak and Sandor Toth. It calculates the spin wave spectrum of the kagome lattice with antiferromagnetic and DM interactions, with ordering wavevector of ğ¤ = 0 and relative rotation of 120Â° between sublattices.\n\nLoad Sunny and the GLMakie plotting package.\n\nusing Sunny, GLMakie, LinearAlgebra\n\nDefine the chemical cell of a kagome lattice with spacegroup 147 (P-3).\n\nunits = Units(:meV, :angstrom)\nlatvecs = lattice_vectors(6, 6, 8, 90, 90, 120)\ncryst = Crystal(latvecs, [[1/2, 0, 0]], 147)\nview_crystal(cryst; ndims=2)\n\nConstruct a spin system with antiferromagnetic exchange and a Dzyaloshinskii-Moriya interaction along the first neighbor bond. The symbol I comes from Julia's LinearAlgebra package and is used to promote the scalar exchange strength 1 meV to a 3Ã—3 exchange matrix. The function dmvec promotes the DM interaction vector 0 0 -008 meV to a 3Ã—3 antisymmetric matrix with nonzero (xy) components, defined with respect to the global Cartesian coordinate system.\n\nsys = System(cryst, [1 => Moment(s=1, g=2)], :dipole)\nJ = 1.0*I + dmvec([0, 0, -0.08])\n\nAs in in Tutorial 7, energy minimization determines a ğ¤ = 0 magnetic order with 120Â° rotation between the three sublattices.\n\nset_exchange!(sys, J, Bond(2, 3, [0, 0, 0]))\nrandomize_spins!(sys)\nminimize_energy!(sys)\nplot_spins(sys; ndims=2)\n\nCalculate and plot intensities for a path through ğª-space.\n\nswt = SpinWaveTheory(sys; measure=ssf_perp(sys))\nqs = [[-1/2,0,0], [0,0,0], [1/2,1/2,0]]\npath = q_space_path(cryst, qs, 400)\nres = intensities_bands(swt, path)\nplot_intensities(res; units)\n\nCalculate and plot the powder averaged spectrum.  Because the intensities are dominated by a flat band at about 0.97 meV, select an empirical colorrange that brings the lower-intensity features into focus.\n\nradii = range(0, 2.5, 200)\nenergies = range(0, 2.5, 200)\nkernel = gaussian(fwhm=0.02)\nres = powder_average(cryst, radii, 1000) do qs\n    intensities(swt, qs; energies, kernel)\nend\nplot_intensities(res; units, colorrange=(0,20))","category":"section"},{"location":"examples/spinw/SW15_Ba3NbFe3Si2O14.html","page":"SW15 - Baâ‚ƒNbFeâ‚ƒSiâ‚‚Oâ‚â‚„","title":"SW15 - Baâ‚ƒNbFeâ‚ƒSiâ‚‚Oâ‚â‚„","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW15_Ba3NbFe3Si2O14.html#SW15-BaNbFeSiO","page":"SW15 - Baâ‚ƒNbFeâ‚ƒSiâ‚‚Oâ‚â‚„","title":"SW15 - Baâ‚ƒNbFeâ‚ƒSiâ‚‚Oâ‚â‚„","text":"This is a Sunny port of SpinW Tutorial 15, originally authored by Sandor Toth. It calculates the linear spin wave theory spectrum of Baâ‚ƒNbFeâ‚ƒSiâ‚‚Oâ‚â‚„. The ground state is an incommensurate spiral, which can be directly studied using the functions minimize_spiral_energy! and SpinWaveTheorySpiral.\n\nLoad packages\n\nusing Sunny, GLMakie\n\nSpecify the Baâ‚ƒNbFeâ‚ƒSiâ‚‚Oâ‚â‚„ Crystal cell following Marty et al., Phys. Rev. Lett. 101, 247201 (2008).\n\nunits = Units(:meV, :angstrom)\na = b = 8.539 # (Ã…)\nc = 5.2414\nlatvecs = lattice_vectors(a, b, c, 90, 90, 120)\ntypes = [\"Fe\", \"Nb\", \"Ba\", \"Si\", \"O\", \"O\", \"O\"]\npositions = [[0.24964,0,0.5], [0,0,0], [0.56598,0,0], [2/3,1/3,0.5220],\n             [2/3,1/3,0.2162], [0.5259,0.7024,0.3536], [0.7840,0.9002,0.7760]]\nlangasite = Crystal(latvecs, positions, 150; types)\ncryst = subcrystal(langasite, \"Fe\")\nview_crystal(cryst)\n\nCreate a System and set exchange interactions as parametrized in Loire et al., Phys. Rev. Lett. 106, 207201 (2011).\n\nsys = System(cryst, [1 => Moment(s=5/2, g=2)], :dipole)\nJâ‚ = 0.85\nJâ‚‚ = 0.24\nJâ‚ƒ = 0.053\nJâ‚„ = 0.017\nJâ‚… = 0.24\nset_exchange!(sys, Jâ‚, Bond(3, 2, [1,1,0]))\nset_exchange!(sys, Jâ‚„, Bond(1, 1, [0,0,1]))\nset_exchange!(sys, Jâ‚‚, Bond(1, 3, [0,0,0]))\n\nThe final two exchanges are set according to the desired chirality Ïµ_T of the magnetic structure.\n\nÏµT = -1\nif ÏµT == -1\n    set_exchange!(sys, Jâ‚ƒ, Bond(2, 3, [-1,-1,1]))\n    set_exchange!(sys, Jâ‚…, Bond(3, 2, [1,1,1]))\nelseif ÏµT == 1\n    set_exchange!(sys, Jâ‚…, Bond(2, 3, [-1,-1,1]))\n    set_exchange!(sys, Jâ‚ƒ, Bond(3, 2, [1,1,1]))\nelse\n    error(\"Chirality must be Â±1\")\nend\n\nThis compound is known to have a spiral order with approximate propagation wavevector ğ¤  0 0 17. Search for this magnetic order with minimize_spiral_energy!. Due to reflection symmetry, one of two possible propagation wavevectors may appear, ğ¤ =  0 0 01426. Note that k_z = 01426 is very close to 17 = 01428.\n\naxis = [0, 0, 1]\nrandomize_spins!(sys)\nk = minimize_spiral_energy!(sys, axis)\n\nWe can visualize the full magnetic cell using repeat_periodically_as_spiral, which includes 7 rotated copies of the chemical cell.\n\nsys_enlarged = repeat_periodically_as_spiral(sys, (1, 1, 7); k, axis)\nplot_spins(sys_enlarged; color=[S[1] for S in sys_enlarged.dipoles])\n\nOne could perform a spin wave calculation using either SpinWaveTheory on sys_enlarged, or SpinWaveTheorySpiral on the original sys. The latter has some restrictions on the interactions, but allows for our slightly incommensurate wavevector ğ¤.\n\nmeasure = ssf_perp(sys)\nswt = SpinWaveTheorySpiral(sys; measure, k, axis)\n\nCalculate broadened intensities for a path 0 1 L through reciprocal space\n\nqs = [[0, 1, -1], [0, 1, -1+1], [0, 1, -1+2], [0, 1, -1+3]]\npath = q_space_path(cryst, qs, 400)\nenergies = range(0, 6, 400)\nres = intensities(swt, path; energies, kernel=gaussian(fwhm=0.25))\nplot_intensities(res; units, saturation=0.7, colormap=:jet, title=\"Scattering intensities\")\n\nUse ssf_custom_bm to calculate the imaginary part of mathcalS^2 3(ğª Ï‰) - mathcalS^3 2(ğª Ï‰). In polarized neutron scattering, it is conventional to express the 3Ã—3 structure factor matrix mathcalS^Î± Î²(ğª Ï‰) in the Blume-Maleev polarization axis system. Specify the scattering plane 0 K L via the spanning vectors ğ® = 0 1 0 and ğ¯ = 0 0 1.\n\nmeasure = ssf_custom_bm(sys; u=[0, 1, 0], v=[0, 0, 1]) do q, ssf\n    imag(ssf[2,3] - ssf[3,2])\nend\nswt = SpinWaveTheorySpiral(sys; measure, k, axis)\nres = intensities(swt, path; energies, kernel=gaussian(fwhm=0.25))\nplot_intensities(res; units, saturation=0.8, allpositive=false,\n                 title=\"Im[SÂ²Â³(q, Ï‰) - SÂ³Â²(q, Ï‰)]\")","category":"section"},{"location":"examples/spinw/SW06_Complex_kagome_FM.html","page":"SW06 - Complex kagome ferromagnet","title":"SW06 - Complex kagome ferromagnet","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW06_Complex_kagome_FM.html#SW06-Complex-kagome-ferromagnet","page":"SW06 - Complex kagome ferromagnet","title":"SW06 - Complex kagome ferromagnet","text":"This is a Sunny port of SpinW Tutorial 6, originally authored by Bjorn Fak and Sandor Toth. It calculates the spin wave spectrum of the kagome lattice with multiple competing interactions.\n\nLoad Sunny and the GLMakie plotting package.\n\nusing Sunny, GLMakie\n\nDefine the chemical cell of a kagome lattice with spacegroup 147 (P-3).\n\nunits = Units(:meV, :angstrom)\nlatvecs = lattice_vectors(6, 6, 8, 90, 90, 120)\ncryst = Crystal(latvecs, [[1/2, 0, 0]], 147)\nview_crystal(cryst; ndims=2)\n\nConstruct a spin system with strongly ferromagnetic nearest-neighbor interactions, and two additional interactions. There are two symmetry-inequivalent exchange types at distance 6 â„« (3rd nearest neighbor). The first type, associated with J3a, is a bond from atom 2 to atom 2 that passes over atom 3. The second type, associated with J3b, is a bond from atom 1 to atom 1 that passes through the center of an \"empty\" hexagon of the kagome lattice.\n\nsys = System(cryst, [1 => Moment(s=1, g=2)], :dipole)\nJ1 = -1.0\nJ2 = 0.1\nJ3a = 0.00\nJ3b = 0.17\nset_exchange!(sys, J1, Bond(2, 3, [0, 0, 0]))\nset_exchange!(sys, J2, Bond(2, 1, [0, 0, 0]))\nset_exchange!(sys, J3a, Bond(2, 2, [1, 0, 0]))\nset_exchange!(sys, J3b, Bond(1, 1, [1, 0, 0]))\n\nInteractively visualize the specified interactions. Red (blue) color indicates FM (AFM).\n\nview_crystal(sys; ndims=2)\n\nEnergy minimization favors ferromagnetic order.\n\nrandomize_spins!(sys)\nminimize_energy!(sys)\nplot_spins(sys; ndims=2)\n\nCalculate and plot intensities for a path through ğª-space.\n\nswt = SpinWaveTheory(sys; measure=ssf_perp(sys))\nqs = [[-1/2,0,0], [0,0,0], [1/2,1/2,0]]\npath = q_space_path(cryst, qs, 400)\nres = intensities_bands(swt, path)\nplot_intensities(res; units)\n\nCalculate and plot the powder averaged spectrum. Select an empirical colorrange that brings the lower-intensity features into focus.\n\nradii = range(0, 2.5, 200)\nenergies = range(0, 6.5, 200)\nkernel = gaussian(fwhm=0.02)\nres = powder_average(cryst, radii, 1000) do qs\n    intensities(swt, qs; energies, kernel)\nend\nplot_intensities(res; units, colorrange=(0,10))","category":"section"},{"location":"examples/02_LLD_CoRh2O4.html","page":"2. Landau-Lifshitz dynamics of CoRhâ‚‚Oâ‚„ at finite T","title":"2. Landau-Lifshitz dynamics of CoRhâ‚‚Oâ‚„ at finite T","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/02_LLD_CoRh2O4.html#2.-Landau-Lifshitz-dynamics-of-CoRhO-at-finite-*T*","page":"2. Landau-Lifshitz dynamics of CoRhâ‚‚Oâ‚„ at finite T","title":"2. Landau-Lifshitz dynamics of CoRhâ‚‚Oâ‚„ at finite T","text":"In the previous tutorial, we used spin wave theory to calculate the dynamical spin structure factor of CoRhâ‚‚Oâ‚„. Here, we perform a similar calculation using equilibrium samples from the Boltzmann distribution at finite T. For each sampled spin configuration, we will simulate the classical Landau-Lifshitz spin dynamics and extract dynamical spin-spin correlations. After applying a classical-to-quantum correction factor, the resulting intensities can be compared to inelastic neutron scattering data.\n\nConstruct the CoRhâ‚‚Oâ‚„ antiferromagnet as before. Energy minimization yields the expected NÃ©el order.\n\nusing Sunny, GLMakie\n\nunits = Units(:meV, :angstrom)\na = 8.5031 # (Ã…)\nlatvecs = lattice_vectors(a, a, a, 90, 90, 90)\ncryst = Crystal(latvecs, [[1/8, 1/8, 1/8]], 227)\n\nsys = System(cryst, [1 => Moment(s=3/2, g=2)], :dipole)\nJ = 0.63 # (meV)\nset_exchange!(sys, J, Bond(2, 3, [0, 0, 0]))\nrandomize_spins!(sys)\nminimize_energy!(sys)\nplot_spins(sys; color=[S[3] for S in sys.dipoles])\n\nUse repeat_periodically to extend the system to 10Ã—10Ã—10 chemical unit cells. The ground state NÃ©el order is retained. Increasing the system size further would reduce finite-size artifacts and increase momentum-space resolution, but would also make the simulations slower.\n\nsys = repeat_periodically(sys, (10, 10, 10))\nplot_spins(sys; color=[S[3] for S in sys.dipoles])","category":"section"},{"location":"examples/02_LLD_CoRh2O4.html#Langevin-dynamics-for-sampling","page":"2. Landau-Lifshitz dynamics of CoRhâ‚‚Oâ‚„ at finite T","title":"Langevin dynamics for sampling","text":"We will be using a Langevin spin dynamics to thermalize the system. This dynamics is a variant of the Landau-Lifshitz equation that incorporates noise and dissipation terms, which are linked by a fluctuation-dissipation theorem. The temperature 16 K â‰ˆ 1.38 meV is slightly above ordering for this model. The dimensionless damping magnitude sets a timescale for coupling to the implicit thermal bath; 0.2 is usually a good choice.\n\nlangevin = Langevin(; damping=0.2, kT=16*units.K)\n\nUse suggest_timestep to select an integration timestep. A dimensionless error tolerance of 1e-2 is usually a good choice. The suggested timestep will vary according to the magnetic configuration. It is reasonable to start from an energy-minimized configuration.\n\nsuggest_timestep(sys, langevin; tol=1e-2)\nlangevin.dt = 0.025;\nnothing #hide\n\nNow run a Langevin trajectory to sample spin configurations. Keep track of the energy per site at each time step.\n\nenergies = [energy_per_site(sys)]\nfor _ in 1:1000\n    step!(sys, langevin)\n    push!(energies, energy_per_site(sys))\nend\n\nFrom the relaxed spin configuration, we can learn that dt was a little smaller than necessary; increasing it will make the remaining simulations faster.\n\nsuggest_timestep(sys, langevin; tol=1e-2)\nlangevin.dt = 0.042;\nnothing #hide\n\nPlot energy versus time using the Makie lines function. The plateau suggests that the system has reached thermal equilibrium.\n\nlines(energies, color=:blue, figure=(size=(600,300),), axis=(xlabel=\"Timesteps\", ylabel=\"Energy (meV)\"))\n\nPlot the spins colored by their alignment with a reference spin at the origin. The field sys.dipoles is a 4D array storing the spin dipole data. The first three indices of label the chemical cell, while the fourth index labels an atom within the cell. Note that Julia arrays use 1-based indexing. Thermal fluctuations are apparent in the plot.\n\nS0 = sys.dipoles[1,1,1,1]\nplot_spins(sys; color=[S'*S0 for S in sys.dipoles])","category":"section"},{"location":"examples/02_LLD_CoRh2O4.html#Static-structure-factor","page":"2. Landau-Lifshitz dynamics of CoRhâ‚‚Oâ‚„ at finite T","title":"Static structure factor","text":"Use SampledCorrelationsStatic to estimate spatial correlations for configurations in classical thermal equilibrium. Measure ssf_perp, which is appropriate for unpolarized neutron scattering. Include the FormFactor for Co2âº. Each call to add_sample! will accumulate data for the current spin snapshot.\n\nformfactors = [1 => FormFactor(\"Co2\")]\nmeasure = ssf_perp(sys; formfactors)\nsc = SampledCorrelationsStatic(sys; measure)\nadd_sample!(sc, sys)\n\nCollect 20 additional samples. Perform 100 Langevin time-steps between measurements to approximately decorrelate the sample in thermal equilibrium.\n\nfor _ in 1:20\n    for _ in 1:100\n        step!(sys, langevin)\n    end\n    add_sample!(sc, sys)\nend\n\nUse q_space_grid to define a slice of momentum space H K 0, where H and K each range from -10 to 10 in RLU. This command produces a 200Ã—200 grid of sample points.\n\ngrid = q_space_grid(cryst, [1, 0, 0], range(-10, 10, 200), [0, 1, 0], (-10, 10))\n\nCalculate and plot the instantaneous structure factor on the slice. Selecting saturation=1.0 sets the color saturation point to the maximum intensity value. This is reasonable because we are above the ordering temperature and do not have sharp Bragg peaks.\n\nres = intensities_static(sc, grid)\nplot_intensities(res; saturation=1.0, title=\"Static Intensities at T=16K\")","category":"section"},{"location":"examples/02_LLD_CoRh2O4.html#Dynamical-structure-factor","page":"2. Landau-Lifshitz dynamics of CoRhâ‚‚Oâ‚„ at finite T","title":"Dynamical structure factor","text":"To collect statistics for the dynamical structure factor intensities mathcalS(ğªÏ‰) at finite temperature, use SampledCorrelations. It requires a range of energies to resolve, which will be associated with frequencies of the classical spin dynamics. The integration timestep dt can be somewhat larger than that used by the Langevin dynamics.\n\ndt = 2*langevin.dt\nenergies = range(0, 6, 50)\nsc = SampledCorrelations(sys; dt, energies, measure)\n\nLike before, use Langevin dynamics to sample spin configurations from thermal equilibrium. Now, however, each call to add_sample! will run a classical spin dynamics trajectory and measure dynamical correlations. To make the tutorial run quickly, we average over just 5 trajectories. To make a publication quality figure, this number should be significantly increased for better statistics.\n\nfor _ in 1:5\n    for _ in 1:100\n        step!(sys, langevin)\n    end\n    add_sample!(sc, sys)\nend\n\nSelect points that define a piecewise-linear path through reciprocal space, and a sampling density.\n\nqs = [[3/4, 3/4,   0],\n      [  0,   0,   0],\n      [  0, 1/2, 1/2],\n      [1/2,   1,   0],\n      [  0,   1,   0],\n      [1/4,   1, 1/4],\n      [  0,   1,   0],\n      [  0,  -4,   0]]\npath = q_space_path(cryst, qs, 500)\n\nCalculate and plot the intensities along this path.\n\nres = intensities(sc, path; energies, langevin.kT)\nplot_intensities(res; units, title=\"Intensities at 16 K\")","category":"section"},{"location":"examples/02_LLD_CoRh2O4.html#Powder-averaged-intensity","page":"2. Landau-Lifshitz dynamics of CoRhâ‚‚Oâ‚„ at finite T","title":"Powder averaged intensity","text":"Define spherical shells in reciprocal space via their radii, in absolute units of 1/â„«. For each shell, calculate and average the intensities at 350 ğª-points\n\nradii = range(0, 3.5, 200) # (1/Ã…)\nres = powder_average(cryst, radii, 350) do qs\n    intensities(sc, qs; energies, langevin.kT)\nend\nplot_intensities(res; units, title=\"Powder Average at 16 K\")","category":"section"},{"location":"examples/spinw/SW19_Different_Ions.html","page":"SW19 - Different magnetic ions","title":"SW19 - Different magnetic ions","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW19_Different_Ions.html#SW19-Different-magnetic-ions","page":"SW19 - Different magnetic ions","title":"SW19 - Different magnetic ions","text":"This is a Sunny port of SpinW Tutorial 19, originally authored by Bjorn Fak and Sandor Toth. This tutorial illustrates how to eliminate magnetic contributions from a subset of ions via the special value zero(FormFactor).\n\nusing Sunny, GLMakie\n\nBuild a crystal with CuÂ²âº and FeÂ²âº ions.\n\nunits = Units(:meV, :angstrom)\na = 3.0\nb = 8.0\nc = 4.0\nlatvecs = lattice_vectors(a, b, c, 90, 90, 90)\npositions = [[0, 0, 0], [0, 1/2, 0]]\ntypes = [\"Cu2\", \"Fe2\"]\ncryst = Crystal(latvecs, positions, 1; types)\nview_crystal(cryst)\n\nSet exchange interactions.\n\nJ_Cu_Cu = 1.0\nJ_Fe_Fe = 1.0\nJ_Cu_Fe = -0.1\nmoments = [1 => Moment(s=1/2, g=2), 2 => Moment(s=2, g=2)]\nsys = System(cryst, moments, :dipole; dims=(2, 1, 1))\nset_exchange!(sys, J_Cu_Cu, Bond(1, 1, [-1, 0, 0]))\nset_exchange!(sys, J_Fe_Fe, Bond(2, 2, [-1, 0, 0]))\nset_exchange!(sys, J_Cu_Fe, Bond(2, 1, [0, 1, 0]))\nset_exchange!(sys, J_Cu_Fe, Bond(1, 2, [0, 0, 0]))\n\nFind and plot a minimum energy configuration.\n\nrandomize_spins!(sys)\nminimize_energy!(sys)\nplot_spins(sys)\n\nDefine a path through ğª-space.\n\nqs = [[0,0,0], [1,0,0]]\npath = q_space_path(cryst, qs, 400)\n\nPlot different pair correlation intensities by varying the FormFactor on different atom types. Indices 1 and 2 refer to atoms in the original chemical, and are propagated by symmetry. The special \"zero\" form factor effectively removes the spin moment from the calculation.\n\nfig = Figure(size=(768,600))\n\nformfactors = [1 => FormFactor(\"Cu2\"), 2 => FormFactor(\"Fe2\")]\nswt = SpinWaveTheory(sys; measure=ssf_trace(sys; formfactors))\nres = intensities_bands(swt, path)\nplot_intensities!(fig[1, 1], res; units, title=\"All correlations\")\n\nformfactors = [1 => FormFactor(\"Cu2\"), 2 => zero(FormFactor)]\nswt = SpinWaveTheory(sys; measure=ssf_trace(sys; formfactors))\nres = intensities_bands(swt, path)\nplot_intensities!(fig[1, 2], res; units, title=\"Cu-Cu correlations\")\n\nformfactors = [1 => zero(FormFactor), 2 => FormFactor(\"Fe2\")]\nswt = SpinWaveTheory(sys; measure=ssf_trace(sys; formfactors))\nres = intensities_bands(swt, path)\nplot_intensities!(fig[2, 2], res; units, title=\"Fe-Fe correlations\")\n\nfig\n\nCalculate quantum corrections Î´S to spin magnitude, which arise from the zero-point energy of the spin waves. The outputs are ordered following the Site indexing scheme for the system sys: (cell1, cell2, cell3, sublattice), with left-most indices fastest. The two corrections Î´S  -0137 and Î´S  -0578 apply to the Cu and Fe ions, respectively. The larger correction on Fe is due to the relatively weak interchain coupling.\n\nSunny.magnetization_lswt_correction_dipole(swt; atol=1e-4)","category":"section"},{"location":"why.html#Why-Choose-Sunny?","page":"Why Choose Sunny?","title":"Why Choose Sunny?","text":"","category":"section"},{"location":"why.html#Powerful-and-easy-to-use","page":"Why Choose Sunny?","title":"Powerful and easy to use","text":"Feature highlights include:\n\nAbility to specify a crystal from a CIF file, from its spacegroup number and Wyckoffs, or from a full chemical cell with automatically inferred symmetry operations. Magnetic structures can be read from mCIF files.\nInteractive visualization of 3D crystals and magnetic structures.\nSymmetry analysis to determine allowed anisotropies and interaction terms, and to propagate them by symmetry equivalence.\nSingle-ion anisotropy can be specified using either Stevens operators or spin polynomials. Arbitrary coupling between spin multipoles is also supported. Classical-to-quantum renormalization factors enhance fidelity.\nFast optimization of magnetic structures using supercells or the propagation vector formalism.\nStatistical sampling of spins in thermal equilibrium using Langevin dynamics or local Monte Carlo updates. Advanced Monte Carlo methods, such as parallel tempering, for simulations of classical spin liquids and frustrated magnetism.\nClassical dynamics of spin dipoles and its generalization to SU(N) coherent states. One can sample dynamical correlations at finite temperature. The CPÂ² skyrmion example illustrates a highly non-equilibrium quench process that depends crucially on spin quadrupole degrees of freedom.\nGeneralized linear spin wave theory (LSWT) for low-temperature spin dynamics. Special support is provided for efficient calculations on incommensurate spiral phases and on very large magnetic cells. The FeIâ‚‚ example showcases LSWT with multi-flavor bosons. The disordered system example demonstrates acceleration for large system sizes.\nDipole-dipole interactions with full Ewald summation, as illustrated in the pyrochlore LSWT example. Dipole-dipole interactions in classical dynamics are accelerated with the fast Fourier transform (FFT).\nTools for comparing to experimental data: form factors, custom spin contractions, averaging over powder and domain orientations, etc.\nProgrammatic interface in the Julia language for full flexibility and performance.\n\nBut still evolving:\n\nSunny does not yet have GPU acceleration of classical spin dynamics. An alternative here might be Vampire.","category":"section"},{"location":"why.html#Advanced-theory-made-accessible","page":"Why Choose Sunny?","title":"Advanced theory made accessible","text":"Sunny is also a platform for disseminating foundational advances in quantum magnetism and computational methods. The theory of SU(N) coherent states offers a group theoretic framework to formulate alternative classical limits of a microscopic quantum model. New algorithms enable highly efficient simulation of spin-multipoles and beyond. For reasons not fully understood, such classical limits can be remarkably accurate at finite temperatures when used in conjunction with appropriate renormalization schemes. The SU(N) picture also suggests new geometric interpretations of quantum spin. This leads to a deeper understanding of existing renormalization schemes for traditional spin wave theory, and suggests an enlarged space to search for novel topological states. Ongoing Sunny research aims to incorporate more quantum entanglement into the classical picture. Local units of strongly entangled spins will soon be supported and show great promise for cases like dimerized ladders. Longer term, Sunny also aims to include perturbative corrections beyond linear spin wave theory, as well as a non-perturbative treatment of quantum bound states.","category":"section"},{"location":"examples/07_Dipole_Dipole.html","page":"7. Long-range dipole interactions","title":"7. Long-range dipole interactions","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/07_Dipole_Dipole.html#7.-Long-range-dipole-interactions","page":"7. Long-range dipole interactions","title":"7. Long-range dipole interactions","text":"This example demonstrates long-range dipole-dipole interactions in the context of a spin wave calculation. These interactions can be included two ways: with infinite-range Ewald summation or with a real-space distance cutoff. The study follows Del Maestro and Gingras, J. Phys.: Cond. Matter, 16, 3339 (2004).\n\nusing Sunny, GLMakie\n\nCreate a pyrochlore crystal from Wyckoff 16c for spacegroup 227.\n\nunits = Units(:K, :angstrom)\nlatvecs = lattice_vectors(10.19, 10.19, 10.19, 90, 90, 90)\npositions = [[0, 0, 0]]\ncryst = Crystal(latvecs, positions, 227)\nview_crystal(cryst)\n\nCreate a System with a random number seed that was empirically selected to produce the desired type of spontaneous symmetry breaking. Reshape to the primitive cell, which contains four atoms. Add antiferromagnetic nearest neighbor exchange interactions.\n\nsys = System(cryst, [1 => Moment(s=7/2, g=2)], :dipole; seed=0)\nsys = reshape_supercell(sys, primitive_cell(cryst))\nJ1 = 0.304 # (K)\nset_exchange!(sys, J1, Bond(1, 2, [0,0,0]))\n\nCreate a copy of the system and enable long-range dipole-dipole interactions using Ewald summation.\n\nsys_lr = clone_system(sys)\nenable_dipole_dipole!(sys_lr, units.vacuum_permeability)\n\nCreate a copy of the system and add long-range dipole-dipole interactions up to a 5 â„« cutoff distance.\n\nsys_lr_cut = clone_system(sys)\nmodify_exchange_with_truncated_dipole_dipole!(sys_lr_cut, 5.0, units.vacuum_permeability)\n\nFind an energy minimizing spin configuration accounting for the long-range dipole-dipole interactions. This will arbitrarily select from a discrete set of possible ground states based on the system seed.\n\nrandomize_spins!(sys_lr)\nminimize_energy!(sys_lr)\nplot_spins(sys_lr; ghost_radius=8, color=[:red, :blue, :yellow, :purple])\n\nCopy this configuration to the other two systems. Note that the original sys has a continuum of degenerate ground states.\n\nsys.dipoles .= sys_lr.dipoles\nsys_lr_cut.dipoles .= sys_lr.dipoles;\nnothing #hide\n\nCalculate dispersions for the three systems. The high-symmetry ğª-points are specified in reciprocal lattice units with respect to the conventional cubic cell.\n\nqs = [[0,0,0], [0,1,0], [1,1/2,0], [1/2,1/2,1/2], [3/4,3/4,0], [0,0,0]]\nlabels = [\"Î“\", \"X\", \"W\", \"L\", \"K\", \"Î“\"]\npath = q_space_path(cryst, qs, 500; labels)\n\nmeasure = ssf_trace(sys)\nswt = SpinWaveTheory(sys; measure)\nres1 = intensities_bands(swt, path)\n\nswt = SpinWaveTheory(sys_lr; measure)\nres2 = intensities_bands(swt, path)\n\nswt = SpinWaveTheory(sys_lr_cut; measure)\nres3 = intensities_bands(swt, path);\nnothing #hide\n\nCreate a panel corresponding to Fig. 2 of Del Maestro and Gingras. Dashed lines show the effect of truncating dipole-dipole interactions at 5 â„«. The Del Maestro and Gingras paper underreported the energy scale by a factor of two.\n\nfig = Figure(size=(768, 300))\nplot_intensities!(fig[1, 1], res1; units, ylims=(0, 4), title=\"Without long-range dipole\")\nax = plot_intensities!(fig[1, 2], res2; units, ylims=(0, 6), title=\"With long-range dipole\")\nfor c in eachrow(res3.disp)\n    lines!(ax, eachindex(c), c; linestyle=:dash, color=:black)\nend\nfig","category":"section"},{"location":"examples/spinw/SW01_FM_Heseinberg_chain.html","page":"SW01 - FM Heisenberg chain","title":"SW01 - FM Heisenberg chain","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW01_FM_Heseinberg_chain.html#SW01-FM-Heisenberg-chain","page":"SW01 - FM Heisenberg chain","title":"SW01 - FM Heisenberg chain","text":"This is a Sunny port of SpinW Tutorial 1, originally authored by Goran Nilsen and Sandor Toth. It calculates the spin wave spectrum of the ferromagnetic Heisenberg nearest-neighbor spin chain.\n\nLoad Sunny and the GLMakie plotting package.\n\nusing Sunny, GLMakie\n\nDefine a chemical cell for the spin chain lattice.  It is tetrahedral, with a short dimension of 3 â„« and two long dimensions of 8 â„«. Observe that Sunny infers the spacegroup 'P 4/m m m' (123).\n\nunits = Units(:meV, :angstrom)\na = 3.0\nb = 8.0\nc = 8.0\nlatvecs = lattice_vectors(a, b, c, 90, 90, 90)\npositions = [[0, 0, 0]]\ncryst = Crystal(latvecs, positions)\n\nView the crystal in 2D. The nearest neighbor bond along the chain is visible, and labeled Bond(1, 1, [1, 0, 0]). The first two atom indices must be 1, because there is only a single atom in the chemical cell. The vector [1, 0, 0] indicates that the bond includes a displacement of 1 ğš_1 + 0 ğš_2 + 0 ğš_3 between chemical cells.\n\nview_crystal(cryst; ndims=2, ghost_radius=8)\n\nSunny will always perform symmetry analysis based on the provided crystallographic information. For example, one can see that there are three different symmetry-equivalent classes of bonds up to a distance of 8 â„«, and the symmetry-allowed exchange matrices are strongly constrained.\n\nprint_symmetry_table(cryst, 8)\n\nUse the chemical cell to create a spin System with spin s = 1 and a magnetic form factor for CuÂ¹âº. In this case, it is only necessary to simulate a single chemical cell. The option :dipole indicates that, following traditional spin wave theory, we are modeling quantum spins using only their expected dipole moments.\n\nsys = System(cryst, [1 => Moment(s=1, g=2)], :dipole)\n\nSet a nearest neighbor exchange interaction of J = -1 meV between neighboring atoms. That is, the total energy along each bond is J S_i S_i+1. The exchange interaction will be propagated to all symmetry equivalent bonds in the system.\n\nJ = -1\nset_exchange!(sys, J, Bond(1, 1, [1, 0, 0]))\n\nFind the energy minimum, which is ferromagnetic. The energy per site is -J for this unfrustrated FM order.\n\nrandomize_spins!(sys)\nminimize_energy!(sys)\nenergy_per_site(sys)\n\nBecause the interaction is Heisenberg (isotropic), the minimization procedure selects an arbitrary direction in spin-space.\n\nplot_spins(sys; ndims=2, ghost_radius=8)\n\nBuild a SpinWaveTheory object to measure the dynamical spin-spin structure factor (SSF). Select ssf_perp to project intensities onto the space perpendicular to the momentum transfer ğª, which is appropriate for an unpolarized neutron beam.\n\nswt = SpinWaveTheory(sys; measure=ssf_perp(sys))\n\nDefine a path from 000 to 100 in reciprocal lattice units (RLU) containing 400 sampled ğª-points.\n\nqs = [[0,0,0], [1,0,0]]\npath = q_space_path(cryst, qs, 400)\n\nCalculate and plot the intensities along this path.\n\nres = intensities_bands(swt, path)\nplot_intensities(res; units)\n\nPerform a powder average over the intensities for 200 radii between 0 and 2.5 inverse â„«. Each radial distance defines a spherical shell in recripocal space, which will be sampled approximately uniformly, involving 1000 sample points. Measure intensities for 200 energy values between 0 and 5 meV. Gaussian line-broadening is applied with a full-width at half-maximum (FWHM) of 0.1 meV. With the above parameters, this calculation takes about a second on a modern laptop. To decrease stochastic error, one can increase the number of sample points on each spherical shell.\n\nradii = range(0, 2.5, 200) # 1/Ã…\nenergies = range(0, 4.5, 200) # meV\nkernel = gaussian(fwhm=0.1)\nres = powder_average(cryst, radii, 1000) do qs\n    intensities(swt, qs; energies, kernel)\nend\nplot_intensities(res; units)","category":"section"},{"location":"examples/spinw/SW03_Frustrated_chain.html","page":"SW03 - Frustrated J1-J2 chain","title":"SW03 - Frustrated J1-J2 chain","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW03_Frustrated_chain.html#SW03-Frustrated-J1-J2-chain","page":"SW03 - Frustrated J1-J2 chain","title":"SW03 - Frustrated J1-J2 chain","text":"This is a Sunny port of SpinW Tutorial 3, originally authored by Bjorn Fak and Sandor Toth. It calculates the spin wave spectrum of the frustrated J1-J2 chain.\n\nLoad Sunny and the GLMakie plotting package.\n\nusing Sunny, GLMakie\n\nDefine the chemical cell for a 1D chain following the SW01 tutorial.\n\nunits = Units(:meV, :angstrom)\nlatvecs = lattice_vectors(3, 8, 8, 90, 90, 90)\ncryst = Crystal(latvecs, [[0, 0, 0]])\nview_crystal(cryst; ndims=2, ghost_radius=8)\n\nConstruct a spin system with competing nearest-neighbor (FM) and next-nearest-neighbor (AFM) interactions.\n\nsys = System(cryst, [1 => Moment(s=1, g=2)], :dipole)\nJ1 = -1\nJ2 = +2 * abs(J1)\nset_exchange!(sys, J1, Bond(1, 1, [1, 0, 0]))\nset_exchange!(sys, J2, Bond(1, 1, [2, 0, 0]))\n\nAssuming a spiral order, optimize the propagation wavevector ğ¤ starting from a random initial guess. Because all interactions are isotropic in spin space, the polarization axis is arbitrary.\n\naxis = [0, 0, 1]\nrandomize_spins!(sys)\nk = minimize_spiral_energy!(sys, axis; k_guess=randn(3))\n\nThe first component of the order wavevector ğ¤ has a unique value up to reflection symmetry, ğ¤  -ğ¤. The second and third components of ğ¤ are arbitrary for this 1D chain system. In all cases, the minimized energy has a precise value of -33/16 in units of Jâ‚.\n\n@assert k[1] â‰ˆ 0.2300534561 || k[1] â‰ˆ 1 - 0.2300534561\n@assert spiral_energy_per_site(sys; k, axis) â‰ˆ -33/16 * abs(J1)\n\nTo view part of the incommensurate spiral spin structure, one can construct an enlarged system with repeat_periodically_as_spiral.\n\nsys_enlarged = repeat_periodically_as_spiral(sys, (8, 1, 1); k, axis)\nplot_spins(sys_enlarged; ndims=2)\n\nUse SpinWaveTheorySpiral on the original sys to calculate the dispersion and intensities for the incommensurate ordering wavevector.\n\nswt = SpinWaveTheorySpiral(sys; measure=ssf_perp(sys), k, axis)\nqs = [[0,0,0], [1,0,0]]\npath = q_space_path(cryst, qs, 401)\nres = intensities_bands(swt, path)\nplot_intensities(res; units)","category":"section"},{"location":"versions.html#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"versions.html#v0.8.0","page":"Release Notes","title":"v0.8.0","text":"(In development)\n\nBreaking changes in this release.\n\nSignificant enhancements to crystal construction and symmetry analysis, which may reorder certain atom and site indices (#405). Crystal lattice vectors and positions are now idealized according to spacegroup data. In rare cases, this will cause re-indexing of atoms in the crystal. Site indexing conventions for certain reshaped systems may also change; use position_to_site for robust indexing of reshaped systems. Loading an mCIF as a chemical cell now employs a standardized Cartesian coordinate system, as would be obtained from lattice_vectors. Attempting to perform symmetry analysis on a crystal with a larger-than-standard chemical cell will error rather than give a wrong result.\nWhen loading a CIF or mCIF, the precision parameter symprec becomes optional (#413).\nVarious enhancements to minimize_energy!. The return value becomes a struct that stores optimization statistics (#430). A small perturbation to the initial spin state breaks accidental symmetries (#442). Convergence to the local minimum becomes faster and more robust (#453).\nFixes to load_nxs (#420).\nAdd interpolate option to plot_intensities. Selecting interpolate=true will significantly reduce file sizes of PDF exports containing 2D heatmap data (#411).\nset_spin_rescaling! now expects a scaling factor for each symmetry-distinct sublattice (#444).\nIntroduce set_spin_s_at! to set the local quantum spin-s (#454).\nAdd missing 3D support for q_space_grid (#457).\nIf user-provided lattice vectors do not match crystallographic conventions, suggest the use of standardize (#461).\nFixes to SpinWaveTheoryKPM (#462).","category":"section"},{"location":"versions.html#v0.7.8","page":"Release Notes","title":"v0.7.8","text":"(Jul 1, 2025)\n\nCompatibility with Makie v0.24 (#393).","category":"section"},{"location":"versions.html#v0.7.7","page":"Release Notes","title":"v0.7.7","text":"(Jun 25, 2025)\n\nAdd set_spin_rescaling_for_static_sum_rule! which sets the classical dipole magnitude to sqrts (s + 1) for each quantum spin-s moment.\nAdd module SCGA for calculating intensities_static within the self-consistent Gaussian approximation (#355).\nExtend enable_dipole_dipole! to accept a demagnetization factor or tensor demag. The new default is isotropic demagnetization, demag = 1/3, appropriate for a spherical sample in vacuum. Set demag = 0 to disable demagnetization (#380).\nFix heatmaps in plot_intensities for very large grids (#379).\nMake energy minimization more reliable (#397).","category":"section"},{"location":"versions.html#v0.7.6","page":"Release Notes","title":"v0.7.6","text":"(May 1, 2025)\n\nExtend powder_average to support static intensities.\nVacancies defined by set_vacancy_at! are supported in linear spin wave theory. Empty sites are modeled using bosons that do not excite.\nThe default implementation of SpinWaveTheoryKPM now uses Lanczos for higher accuracy.\nFix correctness of suggest_magnetic_supercell when multiple wavevectors are provided.\nFix atom indexing when setting interactions for a reshaped system (#359).\nNormalize axis argument to SpinWaveTheorySpiral for correctness.\nFix thermal prefactor kT in spin wave theory (#370).\nIn :dipole or :SUN mode, functions set_onsite_coupling! and set_pair_coupling! throw an error when used with quantum spin 1/2. Construct System using mode :dipole_uncorrected for such models (#376).","category":"section"},{"location":"versions.html#v0.7.5","page":"Release Notes","title":"v0.7.5","text":"(Jan 20, 2025)\n\nview_crystal shows allowed quadratic anisotropy. print_site accepts an optional reference atom i_ref, with default of i. The optional reference bond b_ref of print_bond now defaults to b.\nThe regularization parameter in SpinWaveTheory is reduced by half, and now corresponds to an effective energy shift. This may affect intensities, especially at small excitation energies.\nUpdate dependencies and in particular fix color compile error.","category":"section"},{"location":"versions.html#v0.7.4","page":"Release Notes","title":"v0.7.4","text":"(Dec 6, 2024)\n\nHigher-precision convergence in minimize_energy!.\nMake minimize_energy! compatible with set_vacancy_at!.\nThe System constructor now seeds its internal random number generator using Julia's task-local random number generator.\nAdd print_irreducible_bz_paths, which builds on Brillouin.jl and SeeK-path.\nAdd function view_bz for visualizing reciprocal-space objects in the context of the first Brillouin zone.\nFix load_nxs for compatibility with recent JLD2.\nFix Makie precompiles for faster time-to-first-plot in Julia 1.11 (#329).","category":"section"},{"location":"versions.html#v0.7.3","page":"Release Notes","title":"v0.7.3","text":"(Nov 12, 2024)\n\nFix error in print_symmetry_table for slightly-distorted crystal cells (#317).\nStabilize SpinWaveTheoryKPM. It now automatically selects the polynomial order according to an error tolerance.\nRename mode :dipole_large_S to :dipole_uncorrected to emphasize that corrections are missing.\nThe Crystal constructor, by default, interprets a spacegroup number in its ITA standard setting, e.g., as used by the Bilbao crystallographic server. The keyword argument setting becomes choice, and can typically be omitted.\nRename primitive_cell_shape to primitive_cell.","category":"section"},{"location":"versions.html#v0.7.2","page":"Release Notes","title":"v0.7.2","text":"(Sep 11, 2024)\n\nFix error in SampledCorrelations with a coarse ğª-grid. (#314).\nFix colorbar in plot_intensities! when all data is uniform (#315).\nAn explicit colorrange can be used for plotting intensities_bands.","category":"section"},{"location":"versions.html#v0.7.1","page":"Release Notes","title":"v0.7.1","text":"(Sep 3, 2024)\n\nCorrectness fix for scalar biquadratic interactions specified with option biquad to set_exchange!.\nPrototype implementation of entangled units.","category":"section"},{"location":"versions.html#v0.7.0","page":"Release Notes","title":"v0.7.0","text":"(Aug 30, 2024)\n\nBreaking changes in this release.\n\nThe interface for calculating intensities has been revised to unify functionality across backends. The functions intensities_bands, intensities, and intensities_static no longer expect a \"formula\", and instead take keyword arguments directly. Pair correlations are now specified using ssf_perp and related functions. The constructors SampledCorrelations and SampledCorrelationsStatic replace dynamic_correlations and static_correlations, respectively.\nNew function plot_intensities enables convenient plotting for many types of intensities plots. Mutating variant plot_intensities! enables multi-panel plots.\nOne should now specify a range of ğª-points with q_space_path or q_space_grid.\nSpinWaveTheorySpiral is available to perform calculations on generalized spiral structures, which may be incommensurate.\nrepeat_periodically_as_spiral replaces set_spiral_order_on_sublattice! and set_spiral_order!.\nNew convenience functions powder_average and domain_average, which wrap intensities.\nSystem now expects supercell dimensions as a dims keyword argument. Moment replaces SpinInfo. Lower-case s now labels quantum spin.\nIn view_crystal and plot_spins use ndims instead of dims for the number of spatial dimensions.\nBinning features have been removed. Some functionality may be added back in a future release.\nExperimental SpinWaveTheoryKPM feature implements a new algorithm to enable intensities calculations at a computational cost that scales linearly in system size.","category":"section"},{"location":"versions.html#v0.6.1","page":"Release Notes","title":"v0.6.1","text":"(Aug 2, 2024)\n\nBreaking changes: magnetic_moment is now reported in units of the Bohr magneton, Î¼_B. For model systems where the Zeeman coupling aligns spin dipole with field (e.g., the Ising model convention), create a SpinInfo with g=-1 (#284).\nMore flexible Units system. set_external_field! is deprecated in favor of set_field!, which now expects a field in energy units. enable_dipole_dipole! now expects a scale parameter Î¼_0 Î¼_B^2 that can be obtained from units.vacuum_permeability.","category":"section"},{"location":"versions.html#v0.6.0","page":"Release Notes","title":"v0.6.0","text":"(Jun 18, 2024)\n\nVarious correctness fixes. The magnetic moment is now anti-aligned with the spin dipole (#190), and the wavevector ğª in structure factor intensities mathcalS(ğªÏ‰) now consistently represents momentum transfer to the sample (#270). The new Example 8 demonstrates a model system where momentum transfers ğª are inequivalent.\nDynamical structure factor intensities now have a precisely defined scale, independent of the calculator (#264). Consequently, color ranges in plots may need to be rescaled.\nCrystal can now infer a chemical unit cell from an mCIF file. System now supports set_dipoles_from_mcif!. Through spglib, one can now standardize any Crystal, with an option to idealize site positions.","category":"section"},{"location":"versions.html#v0.5.11","page":"Release Notes","title":"v0.5.11","text":"(Jun 2, 2024)\n\nFixes for Makie 0.21.","category":"section"},{"location":"versions.html#v0.5.10","page":"Release Notes","title":"v0.5.10","text":"(May 27, 2024)\n\nview_crystal called on a System now shows interactions, and optionally the spin or magnetic dipoles.\nInteractions for enable_dipole_dipole! are now supported in linear spin wave theory, with proper Ewald summation. For a faster alternative, the experimental function modify_exchange_with_truncated_dipole_dipole! will accept a real-space cutoff.\nIntensities calculated with dynamic_correlations now avoid \"bleeding artifacts\" at low-energy (long-timescale) modes. See #246 for details. This eliminates the need for process_trajectory=:symmetrize.\nWhen passed to intensity_formula, the special value zero(FormFactor) can now be used to disable contributions from a given site. For an example, see the ported SpinW tutorial 19.\nBroadening kernels gaussian and lorentzian now expect a full width at half maximum (fwhm) keyword argument.\nExperimental support for calculations on generalized spiral phases. For an example, see the ported SpinW tutorial 18.\nCorrectness fix for the case where spin-S varies between sites in dipole-mode. In SU(N) mode, however, there is still no support for varying the Hilbert space dimension N between sites.\nCorrectness fix in long-range dipole-dipole interactions for systems with multiple cells.\nCorrectness fix in general biquadratic interactions (beyond scalar) for spin wave theory in dipole-mode.\nCorrectness fix for reading Mantid .nxs files.","category":"section"},{"location":"versions.html#v0.5.9","page":"Release Notes","title":"v0.5.9","text":"(Mar 25, 2024)\n\nCorrectness fixes: Structure factor conventions are now uniform across modes and precisely specified. The g-tensor is applied by default (disable with apply_g = false). The intensity is additive with increasing number of magnetic ions in the chemical cell, consistent with SpinW (#235).\nEnhancements to view_crystal. If a bond allows a DM interaction, its orientation will be shown visually. If a System argument is supplied, its exchange interactions will be shown.\nNew function suggest_timestep to assist in performing accurate and efficient simulation of classical spin dynamics (#149).\nScalar biquadratic interactions can again be set in :dipole_large_S mode via the keyword argument biquad of set_exchange!.\nSignificantly speed up dynamic_correlations for crystals with many atoms in the unit cell (#204).\nRenamings: dt replaces Î”t and damping replaces Î». This affects Langevin, [ImplicitMidpoint], and dynamic_correlations functions.","category":"section"},{"location":"versions.html#v0.5.8","page":"Release Notes","title":"v0.5.8","text":"(Jan 4, 2024)\n\nMany bugs in the WGLMakie backend have become apparent, and are being tracked at #211. Emit a warning if WGLMakie is detected, suggesting that GLMakie is preferred.\nVarious improvements to view_crystal. A distance parameter is no longer expected. Cartesian axes now appear as \"compass\" in bottom-left. Custom list of reference bonds can be passed. Toggle to view non-magnetic atoms in root crystal. Atoms now colored using CPK/JMol conventions.","category":"section"},{"location":"versions.html#v0.5.7","page":"Release Notes","title":"v0.5.7","text":"(Nov 26, 2023)\n\nUpdate form factor coefficients, which now include Mn5.\nFix merge_correlations and the Parallelizing Calculations tutorial.\nRemove internal functions *_primitive_crystal. Instead, it is recommended to use the conventional unit cell, and later call reshape_supercell.\nRequire Makie 0.20. An important new feature is resolution-independent scaling of font sizes. New figures expect size instead of resolution, and no longer accept rescale.","category":"section"},{"location":"versions.html#v0.5.6","page":"Release Notes","title":"v0.5.6","text":"(Nov 8, 2023)\n\nThis release initiates some major enhancements to the user interface in support of generalized SU(N) spin models. See this documentation page for an illustration of the new features. Most existing Sunny 0.5 models will continue to work with deprecation warnings, but these will become hard errors Sunny v0.6.\n\nGeneral pair couplings are now supported in set_pair_coupling! and set_pair_coupling_at!. :SUN mode supports interactions of any order, but :dipole mode is limited to bilinear and biquadratic coupling of the spin.\nTo perform a calculation with dipoles in the large-S limit, use the new mode :dipole_large_S when constructing a System.\nDeprecate the option biquad to set_exchange!. Use instead set_pair_coupling!, which generalizes beyond the scalar biquadratic.\nDeprecate spin_operators, stevens_operators, large_S_spin_operators and large_S_stevens_operators. Use instead spin_matrices and stevens_matrices, which require a specific spin-S label. To infer this, one can use spin_label.\nRemove unused option energy_tol in SpinWaveTheory.\nAnimated spin dynamics is now possible. Call notify on the result of plot_spins to trigger redrawing of the frame. The argument colorfn to plot_spins supports animation of colors. See example usage for a Heisenberg ferromagnet.\nAdd set_spin_rescaling! feature, which supports improved spectral measurements at finite-T. This follows the method proposed in Dahlbom et al., [arXiv:2310.19905].","category":"section"},{"location":"versions.html#v0.5.5","page":"Release Notes","title":"v0.5.5","text":"(Sep 29, 2023)\n\nreshape_supercell now allows reshaping to multiples of the primitive unit cell, which can speed up certain calculations. This is illustrated in the CoRhâ‚‚Oâ‚„ powder averaging tutorial.\nresize_supercell now allows all resizings.\nAdded energy_per_site.\nset_spiral_order_on_sublattice! cannot work on reshaped systems.\nVarious bug fixes. In particular, an intensity_formula with :full will now uniformly calculate a 3x3 matrix of complex numbers.","category":"section"},{"location":"versions.html#v0.5.4","page":"Release Notes","title":"v0.5.4","text":"(Sep 11, 2023)\n\nVarious enhancements to view_crystal. Atoms are now labeled by index, and bonds support interactive inspection (GLMakie only). Font sizes work correctly on Makie v0.20-beta. If using Makie v0.19 on a high-resolution display, pass rescale=1.5 to enlarge font sizes.\nThe function suggest_magnetic_supercell now requires only a list of wavevectors, and will return a 33 matrix that can be programmatically passed to reshape_supercell. The new tolerance parameter tol allows suggest_magnetic_supercell to approximate incommensurate wavevectors with nearby commensurate ones.\nNew functions set_spiral_order! and set_spiral_order_on_sublattice! can be used to initialize a spiral, single-Q order.\nSunny now retains all constant energy shifts that have been introduced by anisotropy operators.\nFix export_vtk functionality.","category":"section"},{"location":"versions.html#v0.5.3","page":"Release Notes","title":"v0.5.3","text":"(Sep 8, 2023)\n\nAdd large_S_spin_operators and large_S_stevens_operators to support single-ion anisotropies in dipole mode without renormalization. Set large_S=true in set_exchange! to avoid renormalization of biquadratics.\nview_crystal has been rewritten in Makie.\nplot_spins now expects ghost_radius in physical length units.\nSpinWaveTheory will (currently) error if provided a system with enable_dipole_dipole!.","category":"section"},{"location":"versions.html#v0.5.2","page":"Release Notes","title":"v0.5.2","text":"(Aug 30, 2023)\n\nForm factors for 5d transition ions.\nDownload links for notebooks and scripts on each doc example\nVarious bug fixes.","category":"section"},{"location":"versions.html#v0.5.1","page":"Release Notes","title":"v0.5.1","text":"(Aug 23, 2023)\n\nFix binning edge cases.\nplot_spins accepts resolution argument.","category":"section"},{"location":"versions.html#v0.5.0","page":"Release Notes","title":"v0.5.0","text":"(Aug 21, 2023)\n\nNew features.\n\nSupport for Linear Spin Wave Theory in :dipole and :SUN modes. (Thanks Hao Zhang!)\n\nNew function minimize_energy! to efficiently find an optimal configuration of spin dipoles or SU(N) coherent states.\n\nMajor refactors and enhancements to intensity calculations. This new interface allows unification between LSWT and classical spin dynamics calculations. This interface allows: Custom observables as local quantum operators, better support for linebroadening, and automatic binning to facilitate comparison with experimental data. See intensity_formula for documentation. Use load_nxs to load experimental neutron scattering data.\n\nBreaking changes.\n\nRequire Julia 1.9.\n\nReplace set_anisotropy! with a new function set_onsite_coupling! (and similarly set_onsite_coupling_at!). The latter expects an explicit matrix representation for the local Hamiltonian. This can be constructed, e.g., as a linear combination of stevens_operators, or as a polynomial of spin_operators. To understand the mapping between these two, the new function print_stevens_expansion acts on an arbitrary local operator.\n\nRemove set_biquadratic!. Instead, use an optional keyword argument biquad to set_exchange!.\n\nRename DynamicStructureFactor to dynamic_correlations. Similarly, replace InstantStructureFactor with instant_correlations. The return type has been renamed SampledCorrelations to emphasize that the object may be holding thermodynamic samples, which are collected using add_sample!. Upon construction, the SampledCorrelations object will be empty (no initial sample).\n\nRemove intensities function. Instead, use one of intensities_interpolated or intensities_binned. These will require an intensity_formula, which defines a calculator (e.g., LSWT).\n\nRename connected_path to reciprocal_space_path, which now returns an xticks object that can be used in plotting. Replace spherical_shell with reciprocal_space_shell that functions similarly.\n\nRename polarize_spin! to set_dipole! for consistency with set_coherent!. The behavior of the former function is unchanged: the spin at a given site will still be polarized along the provided direction.\n\nRename all_sites to eachsite consistent with Julia convention for iterators.\n\nRename reshape_geometry to reshape_supercell, which is the fundamental reshaping function. Rename resize_periodically to resize_supercell.\n\nThe constructor SpinInfo now requires a g-factor or tensor as a named argument.\n\nThe constructor FormFactor no longer accepts an atom index. Instead, the form factors are associated with site-symmetry classes in order of appearance.","category":"section"},{"location":"versions.html#v0.4.3","page":"Release Notes","title":"v0.4.3","text":"(Jun 23, 2023)\n\nExperimental support for linear SpinWaveTheory, implemented in SU(N) mode. This module may evolve rapidly.\n\nImplement renormalization of single-ion anisotropy and biquadratic interactions when in :dipole mode. This makes the model more faithful to the quantum mechanical Hamiltonian, but is also a breaking change.\n\nVarious improvements and bugfixes for to_inhomogeneous. Setting inhomogeneous interactions via set_exchange_at! should now infer the correct bond offset direction, or will report an ambiguity error. Ambiguities can be resolved by passing an explicit offset.\n\nThe function remove_periodicity! disables periodicity along specified dimensions.\n\nRename StaticStructureFactor to InstantStructureFactor.","category":"section"},{"location":"versions.html#v0.4.2","page":"Release Notes","title":"v0.4.2","text":"(Feb 27, 2023)\n\nIntroduce LocalSampler, a framework for MCMC sampling with local spin updates.\n\nRename print_dominant_wavevectors to print_wrapped_intensities to reduce confusion with the physical instantaneous intensities.\n\nThe function spherical_shell now takes a radius in physical units of inverse Ã….\n\nNew exported functions global_position, magnetic_moment, all_sites.\n\nRemove all uses of Base.deepcopy which resolves crashes (#65).","category":"section"},{"location":"versions.html#v0.4.1","page":"Release Notes","title":"v0.4.1","text":"(Feb 13, 2023)\n\nThe function to_inhomogeneous creates a system that supports inhomogeneous interactions, which can be set using set_exchange_at!, etc.\n\nset_biquadratic! replaces set_exchange_with_biquadratic!.","category":"section"},{"location":"versions.html#v0.4.0","page":"Release Notes","title":"v0.4.0","text":"(Feb 10, 2023)\n\nThis update includes many breaking changes, and is missing some features of 0.3.0.","category":"section"},{"location":"versions.html#Creating-a-spin-System","page":"Release Notes","title":"Creating a spin System","text":"Rename SpinSystem to System. Its constructor now has the form,\n\nSystem(crystal, dims, infos, mode)\n\nThe parameter infos is now a list of SpinInfo objects. Each defines spin angular momentum S = frac12 1 frac32 , and an optional g-factor or tensor.\n\nThe parameter mode is one of :SUN or :dipole.","category":"section"},{"location":"versions.html#Setting-interactions","page":"Release Notes","title":"Setting interactions","text":"Interactions are now added mutably to an existing System using the following functions: set_external_field!, set_exchange!, set_onsite_coupling!, enable_dipole_dipole!.\n\nAs a convenience, one can use dmvec(D) to convert a DM vector to a 33 antisymmetric exchange matrix.\n\nFully general single-ion anisotropy is now possible. The function set_onsite_coupling! expects the single ion anisotropy to be expressed as a polynomial in symbolic spin operators ğ’®, or as a linear combination of symbolic Stevens operators ğ’ª. For example, an easy axis anisotropy in the direction n may be written D*(ğ’®â‹…n)^2.\n\nStevens operators ğ’ª[k,q] admit polynomial expression in spin operators ğ’®[Î±]. Conversely, a polynomial of spin operators can be expressed as a linear combination of Stevens operators. To see this expansion use print_anisotropy_as_stevens.","category":"section"},{"location":"versions.html#Inhomogeneous-field","page":"Release Notes","title":"Inhomogeneous field","text":"An external field can be applied to a single site with set_external_field_at!. ","category":"section"},{"location":"versions.html#Structure-factor-rewrite","page":"Release Notes","title":"Structure factor rewrite","text":"The calculation of structure factors has been completely rewritten. For the new interface see the documentation tutorials.","category":"section"},{"location":"versions.html#Various","page":"Release Notes","title":"Various","text":"The \"Sampler\" interface is in flux. Langevin replaces both LangevinHeunP and LangevinSampler. Local spin-flip Monte Carlo sampling methods are temporarily broken.\nrepeat_periodically replaces extend_periodically.\n\nAdditional related functions include resize_periodically and reshape_geometry, the latter being fundamental.\n\nprint_symmetry_table replaces print_bond_table().\n\nThe new function includes the list of symmetry-allowed single ion anisotropies in addition to exchange interactions.\n\nWhen reading CIF files, the field _atom_site_label is now used in place of the field _atom_site_type_symbol.\n\nThis is required for correctness. The field _atom_site_label is guaranteed to be present, and is guaranteed to be a distinct label for each symmetry-inequivalent site. Code that explicitly referred to site labels (e.g. in calls to subcrystal) will need to be updated to use the new label.","category":"section"},{"location":"examples/spinw/SW14_YVO3.html","page":"SW14 - YVOâ‚ƒ","title":"SW14 - YVOâ‚ƒ","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW14_YVO3.html#SW14-YVO","page":"SW14 - YVOâ‚ƒ","title":"SW14 - YVOâ‚ƒ","text":"This is a Sunny port of SpinW Tutorial 14, originally authored by Sandor Toth. It calculates the spin wave spectrum of YVOâ‚ƒ.\n\nLoad packages\n\nusing Sunny, GLMakie\n\nBuild an orthorhombic lattice and populate the V atoms according to the pseudocubic unit cell, doubled along the c-axis. The listed spacegroup of the YVOâ‚ƒ chemical cell is international number 62. It has been observed, however, that the exchange interactions break this symmetry. For this reason, disable all symmetry analysis by selecting spacegroup 1 (P1).\n\nunits = Units(:meV, :angstrom)\na = 5.2821 / sqrt(2)\nb = 5.6144 / sqrt(2)\nc = 7.5283\nlatvecs = lattice_vectors(a, b, c, 90, 90, 90)\npositions = [[0, 0, 0], [0, 0, 1/2]]\ntypes = [\"V\", \"V\"]\ncryst = Crystal(latvecs, positions, 1; types)\n\nCreate a system following the model of C. Ulrich, et al. Phys. Rev. Lett. 91, 257202 (2003). The mode :dipole_uncorrected avoids a classical-to-quantum rescaling factor of anisotropy strengths, as needed for consistency with the original fits.\n\nmoments = [1 => Moment(s=1/2, g=2), 2 => Moment(s=1/2, g=2)]\nsys = System(cryst, moments, :dipole_uncorrected; dims=(2,2,1))\nJab = 2.6\nJc  = 3.1\nÎ´   = 0.35\nK1  = 0.90\nK2  = 0.97\nd   = 1.15\nJc1 = [-Jc*(1+Î´)+K2 0 -d; 0 -Jc*(1+Î´) 0; +d 0 -Jc*(1+Î´)]\nJc2 = [-Jc*(1-Î´)+K2 0 +d; 0 -Jc*(1-Î´) 0; -d 0 -Jc*(1-Î´)]\nset_exchange!(sys, Jab, Bond(1, 1, [1, 0, 0]))\nset_exchange!(sys, Jab, Bond(2, 2, [1, 0, 0]))\nset_exchange!(sys, Jc1, Bond(1, 2, [0, 0, 0]))\nset_exchange!(sys, Jc2, Bond(2, 1, [0, 0, 1]))\nset_exchange!(sys, Jab, Bond(1, 1, [0, 1, 0]))\nset_exchange!(sys, Jab, Bond(2, 2, [0, 1, 0]))\nset_onsite_coupling!(sys, S -> -K1*S[1]^2, 1)\nset_onsite_coupling!(sys, S -> -K1*S[1]^2, 2)\n\nWhen using spacegroup P1, there is no symmetry-propagation of interactions because all bonds are considered inequivalent. One can visualize the interactions in the system by clicking the toggles in the view_crystal GUI.\n\nview_crystal(sys)\n\nEnergy minimization yields a NÃ©el order with canting\n\nrandomize_spins!(sys)\nminimize_energy!(sys)\nplot_spins(sys)\n\nPlot the spin wave spectrum along a path\n\nswt = SpinWaveTheory(sys; measure=ssf_perp(sys))\nqs = [[0.75, 0.75, 0], [0.5, 0.5, 0], [0.5, 0.5, 1]]\npath = q_space_path(cryst, qs, 400)\nres = intensities_bands(swt, path)\nplot_intensities(res; units)","category":"section"},{"location":"index.html#Welcome","page":"Welcome","title":"Welcome","text":"Sunny provides powerful tools to simulate equilibrium and non-equilibrium magnetic phenomena from microscopic models. It also facilitates calculation of the dynamical spin structure factor mathcalS(ğªÏ‰) for direct comparison to experimental scattering data.\n\nFeature highlights include symmetry-guided modeling, interactive visualization, and more accurate approximations to quantum spin dynamics.\n\nBrowse the tutorials to get started. See also SpinW ports for traditional spin wave theory.\n\nLibrary Reference lists all functions and their doc-strings.\n\nWe want to interact with you! Please join our Slack community and say hello. If you encounter a problem, please ask on the Slack #helpdesk channel. If you use Sunny in a paper, please add it to our Literature Wiki.","category":"section"},{"location":"examples/spinw/SW12_Triangular_easy_plane.html","page":"SW12 - Triangular lattice with easy plane","title":"SW12 - Triangular lattice with easy plane","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW12_Triangular_easy_plane.html#SW12-Triangular-lattice-with-easy-plane","page":"SW12 - Triangular lattice with easy plane","title":"SW12 - Triangular lattice with easy plane","text":"This is a Sunny port of SpinW Tutorial 12, originally authored by Sandor Toth. It calculates the spin wave dispersion of a triangular lattice model with antiferromagnetic interactions and easy-plane single-ion anisotropy.\n\nLoad packages\n\nusing Sunny, GLMakie\n\nBuild a triangular lattice with arbitrary lattice constant of 3 â„«.\n\nlatvecs = lattice_vectors(3, 3, 4, 90, 90, 120)\ncryst = Crystal(latvecs, [[0, 0, 0]])\n\nBuild a system with exchange +1 meV along nearest neighbor bonds. Set the lattice size in anticipation of a magnetic ordering with 3Ã—3 cells.\n\ns = 3/2\nJ1 = +1.0\nsys = System(cryst, [1 => Moment(; s, g=2)], :dipole; dims=(3, 3, 1))\nset_exchange!(sys, J1, Bond(1, 1, [1, 0, 0]))\n\nSet an easy-axis anisotropy operator +D S_z^2 using set_onsite_coupling!. Important note: When introducing a single-ion anisotropy in :dipole mode, Sunny will automatically include a classical-to-quantum correction factor, as described in the document Interaction Renormalization. For an anisotropy operator that is quadratic in the spin operators, Sunny will automatically renormalize the interaction strength as D  (1 - 12s) D. We must \"undo\" Sunny's classical-to-quantum rescaling factor to reproduce the SpinW calculation. Alternatively, renormalization can be disabled by selecting the system mode :dipole_uncorrected instead of :dipole.\n\nundo_classical_to_quantum_rescaling = 1 / (1 - 1/2s)\nD = 0.2 * undo_classical_to_quantum_rescaling\nset_onsite_coupling!(sys, S -> D*S[3]^2, 1)\nrandomize_spins!(sys)\nminimize_energy!(sys)\nplot_spins(sys; ndims=2)\n\nPlot the spin wave spectrum for a path through ğª-space.\n\nqs = [[0, 0, 0], [1, 1, 0]]\npath = q_space_path(cryst, qs, 400)\nswt = SpinWaveTheory(sys; measure=ssf_perp(sys))\nres = intensities_bands(swt, path)\nplot_intensities(res)\n\nTo select a specific linear combination of spin structure factor (SSF) components in global Cartesian coordinates, one can use ssf_custom. Here we calculate and plot the real part of mathcalS^zz(ğª Ï‰).\n\nmeasure = ssf_custom(sys) do q, ssf\n    return real(ssf[3, 3])\nend\nswt = SpinWaveTheory(sys; measure)\nres = intensities_bands(swt, path)\nplot_intensities(res)\n\nIt's also possible to get data for the full 3Ã—3 SSF. For example, this is the SSF for the 7th energy band, at the 10th ğª-point along the path.\n\nmeasure = ssf_custom((q, ssf) -> ssf, sys)\nswt = SpinWaveTheory(sys; measure)\nres = intensities_bands(swt, path)\nres.data[7, 10]","category":"section"},{"location":"examples/spinw/SW04_Frustrated_square.html","page":"SW04 - Frustrated square lattice","title":"SW04 - Frustrated square lattice","text":"Download this example as Julia file or Jupyter notebook.\n\nimport Random; Random.seed!(0); #hide\nnothing #hide","category":"section"},{"location":"examples/spinw/SW04_Frustrated_square.html#SW04-Frustrated-square-lattice","page":"SW04 - Frustrated square lattice","title":"SW04 - Frustrated square lattice","text":"This is a Sunny port of SpinW Tutorial 4, originally authored by Bjorn Fak and Sandor Toth. It calculates the spin wave spectrum of the frustrated square lattice.\n\nLoad Sunny and the GLMakie plotting package.\n\nusing Sunny, GLMakie\n\nTo model the 2D square lattice, create an elongated tetragonal cell with one atom.\n\nunits = Units(:meV, :angstrom)\nlatvecs = lattice_vectors(3.0, 3.0, 6.0, 90, 90, 90)\ncryst = Crystal(latvecs, [[0, 0, 0]])\nview_crystal(cryst; ndims=2)\n\nConstruct a spin system with competing nearest-neighbor (AFM) and next-nearest-neighbor (FM) interactions. The NÃ©el magnetic order requires a supercell of 2Ã—2 chemical cells.\n\nsys = System(cryst, [1 => Moment(s=1, g=2)], :dipole; dims=(2, 2, 1))\nJ1 = 1.0\nJ2 = -0.1\nset_exchange!(sys, J1, Bond(1, 1, [1, 0, 0]))\nset_exchange!(sys, J2, Bond(1, 1, [1, 1, 0]))\nrandomize_spins!(sys)\nminimize_energy!(sys)\nplot_spins(sys)\n\nCalculate and plot intensities for a path through ğª-space.\n\nswt = SpinWaveTheory(sys; measure=ssf_perp(sys))\nqs = [[0, 0, 0], [1/2, 0, 0], [1/2, 1/2, 0], [0, 0, 0]]\npath = q_space_path(cryst, qs, 400)\nres = intensities_bands(swt, path)\nplot_intensities(res; units)","category":"section"}]
}
