struct StructureFactor{N, NumCorr, NBasis}
    # ð’®^{Î±Î²}(q,Ï‰) data and metadata
    data         :: Array{ComplexF64, 7}                  # Raw SF data for 1st BZ (numcorrelations x nbasis x nbasis x latsize x energy)
    crystal      :: Crystal                               # Crystal for interpretation of axes
    Î”Ï‰           :: Float64                               # Energy step size

    # Correlation info (Î±Î² indices of ð’®^{Î±Î²}(q,Ï‰))
    dipoledata   :: Bool                                  # Whether correlations from dipoles 
    ops          :: Array{ComplexF64, 3}                  # Operators corresponding to observables
    idxinfo      :: SortedDict{CartesianIndex{2}, Int64}  # (Î±, Î²) to save from ð’®^{Î±Î²}(q, Ï‰)

    # Specs for sample generation and accumulation
    samplebuf    :: Array{ComplexF64, 6}                  # New sample buffer
    measperiod   :: Int                                   # Steps to skip between saving observables (downsampling for dynamical calcs)
    apply_g      :: Bool                                  # Whether to apply the g-factor
    integrator   :: ImplicitMidpoint                      # Integrator for dissipationless trajectories (will likely move to add_sample!)
    nsamples     :: Array{Int64, 1}                       # Number of accumulated samples (array so mutable)
    processtraj! :: Function                              # Function to perform post-processing on sample trajectories
end

"""
    StructureFactor(sys::System; nÏ‰, Î”t = 0.1, Ï‰max = nothing,
                        apply_g = true, ops = nothing, matrix_elems = nothing,
                        process_trajectory=:none)

`StructureFactor` is the basic type for calculating ``ð’®^{Î±Î²}(q,Ï‰)``, storing
the results, and retrieving intensity information. 

Most users should use [`calculate_structure_factor`](@ref) to generate a
structure factor. However, one may also directly create a structure factor by
providing a `System` to `StructureFactor`. Then, to manually generate a sample,
the user must ensure that the spins of their system are drawn from an
appropriate equilibrium distribution and call [`add_trajectory!`](@ref)
function. This process may be repeated as necessary to generate a sufficient
statistics. 

The keywords specify all the parameters used in subsequent calculations and must
be determined at the time that the `StructureFactor` is initiated. Specifically:
- `nÏ‰`: Required keyword argument that determines how many energy bins to
    resolve between 0 and `Ï‰max`. If set to 1, Sunny will calculate a static
    structure factor.
- `Î”t`: Sets the step size of the integrator used to calculate trajectories.
- `Ï‰max`: Determines the maximum resolved energy.
- `apply_g`: Determines whether to apply the g-factor when calculating
    trajectories.
- `ops`: Enables an advanced feature for SU(_N_) mode, allowing the user to
    specify custom observables other than the three components of the dipole. To
    use this features, `ops` must be given an `NÃ—NÃ—numops` array, where the
    final index is used to retrieve each `NÃ—N` operator.
- `matrix_elems`: Allows the user to specify which correlation functions are
    calculated. This is specified with a vector of tuples. By default Sunny
    records all auto- and cross-correlations generated by the x, y, and z
    dipolar components. To retain only the xx and xy correlations, one would set
    `matrix_elems=[(1,1), (1,2)]`.

If you wish to calculate a dynamical structure factor, the keyword `nÏ‰` must set
to an integer greater than 1.
"""
function StructureFactor(sys::System{N}; nÏ‰, Î”t = 0.1, Ï‰max = nothing,
                            apply_g = true, ops = nothing, matrix_elems = nothing,
                            process_trajectory = :none) where N

    nÏ‰ = Int64(nÏ‰)

    # Establish parameters for either static or dynamic sample generation
    if nÏ‰ == 1  # Static structure factor
        measperiod = 1
        Î”Ï‰ = 0.0  
    else  # Dynamic structure factor 
        measperiod = if isnothing(Ï‰max) 
            1
        else
            @assert Ï€/Î”t > Ï‰max "Maximum Ï‰ with chosen step size is $(Ï€/Î”t). Choose smaller Î”t or change Ï‰_max."
            measperiod = floor(Int, Ï€/(Î”t * Ï‰max))
        end
        nÏ‰ = 2nÏ‰-1 # Make nÏ‰ correspond to number of non-negative frequencies
        Î”Ï‰ = 2Ï€ / (Î”t*measperiod*nÏ‰)
    end

    # Set up correlation functions
    default_observables = false
    default_correlations = false
    if isnothing(ops)
        ops = zeros(ComplexF64, 0, 0, 3)  # ops are empty in this case
        default_observables = true
    else
        (N == 0) && error("Structure Factor Error: Cannot provide matrices for observables when using dipolar `System`")
    end
    nops = size(ops, 3)
    if isnothing(matrix_elems)
        matrix_elems = []
        for i in 1:nops, j in i:nops
            push!(matrix_elems, (i, j))
        end
        default_correlations = true
    end
    dipoledata = default_observables && default_correlations

    # Construct look-up table for matrix elements
    count = 1
    pairs = []
    for elem in matrix_elems
        Î±, Î² = elem
        Î±, Î² = Î± < Î² ? (Î±, Î²) : (Î², Î±)  # Because SF is symmetric, only save diagonal and upper triangular
        push!(pairs, (Î±, Î²) => count)
        count += 1
    end
    pairs = map(i -> CartesianIndex(i.first) => i.second, pairs) # Convert to CartesianIndices
    idxinfo = SortedDict{CartesianIndex{2}, Int64}(pairs) # CartesianIndices sort to fastest order


    # Preallocation
    nb = nbasis(sys.crystal)
    ncorr = length(pairs)
    samplebuf = zeros(ComplexF64, nops, size(sys.dipoles)..., nÏ‰) 
    data = zeros(ComplexF64, length(matrix_elems), nb, nb, sys.latsize..., nÏ‰)
    nsamples = Int64[0]
    integrator = ImplicitMidpoint(Î”t)


    # Set up trajectory processing function (e.g., symmetrize)
    processtraj! = if process_trajectory == :none 
        no_processing
    elseif process_trajectory == :symmetrize
        symmetrize!
    elseif process_trajectory == :subtractmean
        subtract_mean!
    else
        error("Unknown argument for `process_trajectory`")
    end


    # Make Structure factor and add an initial sample
    sf = StructureFactor{N, ncorr, nb}(data, sys.crystal, Î”Ï‰, dipoledata, ops, idxinfo, samplebuf, 
                            measperiod, apply_g, integrator, nsamples, processtraj!)
    add_sample!(sf, sys; processtraj!)

    return sf
end

DynamicStructureFactor(sys::System; kwargs...) = StructureFactor(sys; kwargs...)
StaticStructureFactor(sys::System; kwargs...) = StructureFactor(sys; nÏ‰=1, kwargs...)