struct SFData{NumCorr} 
    data        :: Array{ComplexF64, 7}                    # Raw SF data for 1st BZ 
    crystal     :: Crystal           
    Î”Ï‰          :: Float64                                 # Energy step size
    idxinfo     :: SortedDict{CartesianIndex{2}, Int64}    # (Î±, Î²) to save from ð’®^{Î±Î²}(q, Ï‰)
end

struct SFTrajectory{N}
    sys         :: System{N}             # Clone system so original System unaltered by trajectory calculation
    traj        :: Array{ComplexF64, 6}  # Trajectory buffer
    ops         :: Array{ComplexF64, 3}  # Operators corresponding to observables
    measperiod  :: Int                   # Steps to skip between saving observables (downsampling)
    gfactor     :: Bool                  # Whether to apply the g-factor to recorded trajectories
    dipolemode  :: Bool                  # Whether considering only dipoles
    integrator  :: ImplicitMidpoint 
end

mutable struct StructureFactor{N, NumCorr}
    sfdata      :: SFData{NumCorr}
    sftraj      :: SFTrajectory{N}
    nsamples    :: Int64
end

"""
    StructureFactor(sys::System; Î”t = 0.1, numÏ‰ = 100, Ï‰max = nothing,
                        gfactor = true, ops = nothing, matrix_elems = nothing)

`StructureFactor` is the basic type for calculating ð’®^{Î±Î²}(q,Ï‰), storing the
results, and retrieving intensity information. 

Most users should use [`calculate_structure_factor`](@ref) to generate a structure
factor. However, one may also directly create a structure factor by
providing a `System` to `StructureFactor`. Then, to "manually" generate a sample, 
the user must ensure that the spins of their system are drawn from
an appropriate equilibrium distribution and call [`add_trajectory!`](@ref) function.
This process may be repeated as necessary to generate a sufficient statistics. 

The keywords specify all the parameters used in subsequent calculations and must be
determined at the time that the `StructureFactor` is initiated. Specifically:
- `Î”t`: Sets the step size of the integrator used to calculate trajectories.
- `Ï‰max`: Determines the maximum resolved energy.
- `numÏ‰`: Determines how many energy bins to resolve between 0 and `Ï‰max`.
- `gfactor`: Determines whether to apply the g-factor when calculating trajectories.
- `ops`: Enables an advanced feature for SU(_N_) mode, allowing the user to
    specify custom observables other than the three components of the dipole. To
    use this features, `ops` must be given an `NÃ—NÃ—numops` array, where the final
    index is used to retrieve each `NÃ—N` operator.
- `matrix_elems` allows the user to specify which correlation functions are 
    calculated. This is specified with a vector of tuples. By default Sunny records
    all auto- and cross-correlations generated by the x, y, and z dipolar components.
    To retain only the xx and xy correlations, one would set
    `matrix_elems=[(1,1), (1,2)]`.
"""
function StructureFactor(sys::System; Î”t = 0.1, numÏ‰ = 100, Ï‰max = nothing,
                            gfactor = true, ops = nothing, matrix_elems = nothing)
    sftraj = SFTrajectory(sys; Î”t, numÏ‰, Ï‰max, ops, gfactor)
    sfdata = SFData(sys, sftraj; ops, matrix_elems)
    numsamps = 0

    return StructureFactor(sfdata, sftraj, numsamps)
end

# SFTrajectory is an internal type which specifies and stores a dynamical measurement,
# i.e., a trajectory. By default, SFTrajectory stores the x, y, and z dipolar components.
# In SU(_N_) mode, the user may optionally specify custom observables to record.
function SFTrajectory(sys::System{N}; 
    Î”t = 0.1, numÏ‰ = 100, Ï‰max = nothing, ops = nothing, gfactor = true,
) where N
    # Default to dipole expectation values if no observables have been given
    dipolemode = false 
    if isnothing(ops)
        dipolemode = true
        ops = zeros(ComplexF64, 0, 0, 3) # Placeholder with necessary information for consistent behavior later 
    else
        if N == 0 
            error("Structure Factor Error: Cannot provide matrices for observables when using dipolar `System`")
        end
    end

    # Determine meas_period (downsampling factor)
    if isnothing(Ï‰max)
        measperiod = 1
    else
        @assert Ï€/Î”t > Ï‰max "Maximum Ï‰ with chosen step size is $(Ï€/Î”t). Choose smaller Î”t or change Ï‰_max."
        measperiod = floor(Int, Ï€/(Î”t * Ï‰max))
    end

    # Preallocation
    nops = size(ops, 3)
    traj = zeros(ComplexF64, nops, size(sys.dipoles)..., 2numÏ‰-1) # Double numÏ‰ (since want numÏ‰ _positive_ energies)
    integrator = ImplicitMidpoint(Î”t)

    # Create a shallow copy of the spin system
    sys_new = System(sys.mode, sys.crystal, sys.latsize, sys.interactions,
        copy(sys.dipoles), copy(sys.coherents), sys.Îºs, sys.gs,
        sys.dipole_buffers, sys.coherent_buffers, sys.units, sys.rng)

    return SFTrajectory(sys_new, traj, ops, measperiod, gfactor, dipolemode, integrator)
end

function SFData(sys::System, sftraj::SFTrajectory; 
    ops = nothing, matrix_elems = nothing,
)
    nops =  isnothing(ops) ? 3 : size(ops, 3) # Assume three observables (spin operators) if none are explicitly given
    numÏ‰ = size(sftraj.traj, 6)

    # Save all matrix elements if subset isn't given
    if isnothing(matrix_elems)
        matrix_elems = []
        for i in 1:nops, j in i:nops
            push!(matrix_elems, (i, j))
        end
    end

    # Construct look-up table for matrix elements
    count = 1
    pairs = []
    for elem in matrix_elems
        Î±, Î² = elem
        Î±, Î² = Î± < Î² ? (Î±, Î²) : (Î², Î±)  # Because SF is symmetric, only save diagonal and upper triangular
        push!(pairs, (Î±, Î²) => count)
        count += 1
    end
    pairs = map(i -> CartesianIndex(i.first) => i.second, pairs) # Convert to CartesianIndices
    idxinfo = SortedDict{CartesianIndex{2}, Int64}(pairs)

    qa, qb, qc, ns = size(sys.dipoles)
    data = zeros(ComplexF64, length(matrix_elems), ns, ns, qa, qb, qc, numÏ‰)
    Î”Ï‰ = 2Ï€ / (sftraj.integrator.Î”t*sftraj.measperiod*numÏ‰)

    return SFData{length(pairs)}(data, sys.crystal, Î”Ï‰, idxinfo)
end

"""
    calculate_structure_factor(sys::System, sampler::LangevinSampler;
                                   Ï‰max=10.0, numÏ‰=100, numsamps=10, gfactor=true,
                                   Î”t = nothing, ops = nothing, matrix_elems = nothing)

Calculates a structure factor with a single function call. Must be given a
[`System`](@ref) and a [`LangevinSampler`](@ref). This functions expects that the spin
state contained in the `System` to already be a good equilibrium sample. It will use
this state to generate an initial trajectory. After generating this first trajectory,
it will call `sampler` before generating subsequent trajectories. In total, the
function will calculate `numsamps` trajectories and accumulate them into a
`StructureFactor` which is returned to the user.

The remaining keyword arguments are shared with [`StructureFactor`](@ref). 
"""
function calculate_structure_factor(sys::System, sampler::LangevinSampler;
                                        Ï‰max=10.0, numÏ‰=100, numsamps=10, gfactor=true,
                                        Î”t = nothing, ops = nothing, matrix_elems = nothing)
    # Take a step size twice as large as the sampler step size if none explicitly given
    isnothing(Î”t) && (Î”t = 2sampler.integrator.Î”t)
    sf = StructureFactor(sys; Î”t, numÏ‰, Ï‰max, gfactor, ops, matrix_elems)
    for _ âˆˆ 1:numsamps
        sample!(sys, sampler)
        add_trajectory!(sf, sys)
    end
    return sf
end