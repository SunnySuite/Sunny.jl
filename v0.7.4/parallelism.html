<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallelizing Calculations · Documentation</title><meta name="title" content="Parallelizing Calculations · Documentation"/><meta property="og:title" content="Parallelizing Calculations · Documentation"/><meta property="twitter:title" content="Parallelizing Calculations · Documentation"/><meta name="description" content="Documentation for Documentation."/><meta property="og:description" content="Documentation for Documentation."/><meta property="twitter:description" content="Documentation for Documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img class="docs-light-only" src="assets/logo.svg" alt="Documentation logo"/><img class="docs-dark-only" src="assets/logo-dark.svg" alt="Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Welcome</a></li><li><a class="tocitem" href="why.html">Why Choose Sunny?</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/01_LSWT_CoRh2O4.html">1. Spin wave simulations of CoRh₂O₄</a></li><li><a class="tocitem" href="examples/02_LLD_CoRh2O4.html">2. Landau-Lifshitz dynamics of CoRh₂O₄ at finite <em>T</em></a></li><li><a class="tocitem" href="examples/03_LSWT_SU3_FeI2.html">3. Multi-flavor spin wave simulations of FeI₂</a></li><li><a class="tocitem" href="examples/04_GSD_FeI2.html">4. Generalized spin dynamics of FeI₂ at finite <em>T</em></a></li><li><a class="tocitem" href="examples/05_MC_Ising.html">5. Monte Carlo sampling of the Ising model</a></li><li><a class="tocitem" href="examples/06_CP2_Skyrmions.html">6. Dynamical quench into CP² skyrmion liquid</a></li><li><a class="tocitem" href="examples/07_Dipole_Dipole.html">7. Long-range dipole interactions</a></li><li><a class="tocitem" href="examples/08_Momentum_Conventions.html">8. Momentum transfer conventions</a></li><li><a class="tocitem" href="examples/09_Disorder_KPM.html">9. Disordered system with KPM</a></li><li><input class="collapse-toggle" id="menuitem-3-10" type="checkbox"/><label class="tocitem" for="menuitem-3-10"><span class="docs-label">SpinW ports</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="examples/spinw/SW01_FM_Heseinberg_chain.html">SW01 - FM Heisenberg chain</a></li><li><a class="tocitem" href="examples/spinw/SW02_AFM_Heisenberg_chain.html">SW02 - AFM Heisenberg chain</a></li><li><a class="tocitem" href="examples/spinw/SW03_Frustrated_chain.html">SW03 - Frustrated J1-J2 chain</a></li><li><a class="tocitem" href="examples/spinw/SW04_Frustrated_square.html">SW04 - Frustrated square lattice</a></li><li><a class="tocitem" href="examples/spinw/SW05_Simple_kagome_FM.html">SW05 - Simple kagome ferromagnet</a></li><li><a class="tocitem" href="examples/spinw/SW06_Complex_kagome_FM.html">SW06 - Complex kagome ferromagnet</a></li><li><a class="tocitem" href="examples/spinw/SW07_k0_kagome_AFM.html">SW07 - k=0 kagome antiferromagnet</a></li><li><a class="tocitem" href="examples/spinw/SW08_sqrt3_kagome_AFM.html">SW08 - √3×√3 kagome antiferromagnet</a></li><li><a class="tocitem" href="examples/spinw/SW09_k0_kagome_AFM_DM.html">SW09 - k=0 kagome AFM and DM</a></li><li><a class="tocitem" href="examples/spinw/SW10_Energy_cut.html">SW10 - Energy cut on square lattice</a></li><li><a class="tocitem" href="examples/spinw/SW11_La2CuO4.html">SW11 - La₂CuO₄</a></li><li><a class="tocitem" href="examples/spinw/SW12_Triangular_easy_plane.html">SW12 - Triangular lattice with easy plane</a></li><li><a class="tocitem" href="examples/spinw/SW13_LiNiPO4.html">SW13 - LiNiPO₄</a></li><li><a class="tocitem" href="examples/spinw/SW14_YVO3.html">SW14 - YVO₃</a></li><li><a class="tocitem" href="examples/spinw/SW15_Ba3NbFe3Si2O14.html">SW15 - Ba₃NbFe₃Si₂O₁₄</a></li><li><a class="tocitem" href="examples/spinw/SW18_Distorted_kagome.html">SW18 - Distorted kagome</a></li><li><a class="tocitem" href="examples/spinw/SW19_Different_Ions.html">SW19 - Different magnetic ions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-11" type="checkbox"/><label class="tocitem" for="menuitem-3-11"><span class="docs-label">Contributed</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="examples/contributed/MgCr2O4-tutorial.html">MgCr2O4 at Finite Temperature</a></li><li><a class="tocitem" href="examples/contributed/kappa_tutorial.html">Enforcing the quantum sum rule with moment renormalization</a></li></ul></li></ul></li><li><a class="tocitem" href="library.html">Library Reference</a></li><li><span class="tocitem">Notes and Details</span><ul><li><a class="tocitem" href="structure-factor.html">Structure Factor Conventions</a></li><li><a class="tocitem" href="renormalization.html">Interaction Renormalization</a></li><li class="is-active"><a class="tocitem" href="parallelism.html">Parallelizing Calculations</a><ul class="internal"><li><a class="tocitem" href="#Review-of-the-serial-workflow"><span>Review of the serial workflow</span></a></li><li><a class="tocitem" href="#Multithreading-approach"><span>Multithreading approach</span></a></li><li><a class="tocitem" href="#Using-Distributed"><span>Using <code>Distributed</code></span></a></li></ul></li></ul></li><li><a class="tocitem" href="versions.html">Version History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Notes and Details</a></li><li class="is-active"><a href="parallelism.html">Parallelizing Calculations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="parallelism.html">Parallelizing Calculations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SunnySuite/Sunny.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SunnySuite/Sunny.jl/blob/main/docs/src/parallelism.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Parallelizing-Calculations"><a class="docs-heading-anchor" href="#Parallelizing-Calculations">Parallelizing Calculations</a><a id="Parallelizing-Calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelizing-Calculations" title="Permalink"></a></h1><p>Calculating structure factors with classical dynamics is computationally expensive, and Sunny does not currently parallelize these calculations at a fine-grained level. However, Julia provides facilities that allow users to run multiple simulations in parallel with only a little extra effort. We will look at two approaches to doing this: <a href="https://docs.julialang.org/en/v1/manual/multi-threading/">multithreading</a> and Julia&#39;s <a href="https://docs.julialang.org/en/v1/manual/distributed-computing/"><code>Distributed</code></a> package. We&#39;ll present these approaches in a series of code snippets that can be copied and pasted into your preferred Julia development environment.</p><h2 id="Review-of-the-serial-workflow"><a class="docs-heading-anchor" href="#Review-of-the-serial-workflow">Review of the serial workflow</a><a id="Review-of-the-serial-workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Review-of-the-serial-workflow" title="Permalink"></a></h2><p>The serial approach to calculating a structure factor, covered in the <a href="examples/04_GSD_FeI2.html#4.-Generalized-spin-dynamics-of-FeI-at-finite-*T*">FeI₂ tutorial</a>, involves thermalizing a spin <a href="library.html#Sunny.System"><code>System</code></a> and then calling <a href="library.html#Sunny.add_sample!"><code>add_sample!</code></a>. <code>add_sample!</code> uses the state of the <code>System</code> as an initial condition for the calculation of a dynamical trajectory. The correlations of the trajectory are calculated and accumulated into a running average of the <span>$\mathcal{S}(𝐪,ω)$</span>. This sequence is repeated to generate additional samples.</p><p>To illustrate, we&#39;ll set up a a simple model: a spin-1 antiferromagnet on a BCC crystal. Constructing the <code>System</code> with a specific random number <code>seed</code> ensures full reproducibility of the simulation.</p><pre><code class="language-julia hljs">using Sunny, GLMakie

function make_system(seed)
    latvecs = lattice_vectors(1, 1, 1, 90, 90, 90)
    positions = [[0, 0, 0]/2, [1, 1, 1]/2]
    cryst = Crystal(latvecs, positions)
    sys = System(cryst, [1 =&gt; Moment(s=1, g=2)], :dipole; dims=(10, 10, 2), seed)
    set_exchange!(sys, 1.0, Bond(1, 1, [1, 0, 0]))
    return sys
end

sys = make_system(0)</code></pre><p>A serial calculation of <a href="library.html#Sunny.SampledCorrelations"><code>SampledCorrelations</code></a> involving the <a href="library.html#Sunny.Langevin"><code>Langevin</code></a> sampling method can now be performed as follows:</p><pre><code class="language-julia hljs"># Thermalize the system
dt = 0.05
integrator = Langevin(dt; damping=0.2, kT=0.5)
for _ in 1:5000
    step!(sys, integrator)
end

# Accumulator for S(q,ω) samples

energies = range(0.0, 10.0, 100)
measure = ssf_perp(sys)
sc = SampledCorrelations(sys; dt=0.1, energies, measure)

# Collect 10 samples
for _ in 1:10
    for _ in 1:1000
        step!(sys, integrator)
    end
    add_sample!(sc, sys)
end</code></pre><p>This will take a second or two on a modern workstation, resulting in a single <code>SampledCorrelations</code> that contains 10 samples.</p><h2 id="Multithreading-approach"><a class="docs-heading-anchor" href="#Multithreading-approach">Multithreading approach</a><a id="Multithreading-approach-1"></a><a class="docs-heading-anchor-permalink" href="#Multithreading-approach" title="Permalink"></a></h2><p>To use threads in Julia, you must launch your Julia environment appropriately.</p><ul><li>From the <strong>command line</strong>, launch Julia with <code>julia --threads=auto</code>. With this option, Julia will automatically use an optimal number of threads.</li><li><strong>Jupyter notebook</strong> users will need to to set up a multithreaded Julia kernel and restart into this kernel. The kernel can be created inside Julia with the command <code>IJulia.installkernel(&quot;Julia Multithreaded&quot;, env=Dict(&quot;JULIA_NUM_THREADS&quot; =&gt; &quot;auto&quot;))</code>.</li><li><strong>VSCode</strong> users should open their settings and search for <code>Julia: Additional Args</code>. There will be link called <code>Edit in settings.json</code>. Click on this, add <code>&quot;--threads=auto&quot;</code> to the list <code>julia.additionalArgs</code>, and start a new REPL.</li></ul><p>Before going further, make sure that <code>Threads.nthreads()</code> returns a number greater than 1.</p><p>We will use multithreading in a very simple way, essentially employing a distributed memory approach to avoid conflicts around memory access. First preallocate a number of systems and correlations. The integer <code>id</code> of each system is used as its random number seed.</p><pre><code class="language-julia hljs">npar = Threads.nthreads()
systems = [make_system(id) for id in 1:npar]
scs = [SampledCorrelations(sys; dt=0.1, energies, measure) for _ in 1:npar]</code></pre><div class="admonition is-warning"><header class="admonition-header">Dealing with memory constraints</header><div class="admonition-body"><p>If many threads are available and the system sizes are large, there may not be enough computer memory available to store the dynamical correlation data. In this case, consider reducing the number of parallel threads, <code>npar</code>.</p></div></div><p>When the <code>Threads.@threads</code> macro is applied before a <code>for</code> loop, the iterations of the loop will execute in parallel using the available threads. We will put the entire thermalization and sampling process inside the loop, with each thread acting on a unique <code>System</code> and <code>SampledCorrelations</code>.</p><pre><code class="language-julia hljs">Threads.@threads for id in 1:npar
    integrator = Langevin(dt; damping=0.2, kT=0.5)
    for _ in 1:5000
        step!(systems[id], integrator)
    end
    for _ in 1:10
        for _ in 1:1000
            step!(systems[id], integrator)
        end
        add_sample!(scs[id], systems[id])
    end
end</code></pre><p>You may find this takes a little bit longer than the serial example, but, at the end of it, you will have generated <code>npar</code> correlation objects, each with 10 samples. We can merge these into a summary <code>SampledCorrelations</code> with <code>10*npar</code> samples with <a href="library.html#Sunny.merge_correlations"><code>merge_correlations</code></a>:</p><pre><code class="language-julia hljs">sc = merge_correlations(scs)</code></pre><h2 id="Using-Distributed"><a class="docs-heading-anchor" href="#Using-Distributed">Using <code>Distributed</code></a><a id="Using-Distributed-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Distributed" title="Permalink"></a></h2><p>Julia also provides a distributed memory approach to parallelism through the standard library package <code>Distributed</code>. This works by launching independent Julia environments on different &quot;processes.&quot; An advantage of this approach is that it scales naturally to clusters since the processes are easily distributed across many different compute nodes. A disadvantage, especially when working on a single computer, is the increased memory overhead associated with launching all these environments.</p><p>We begin by importing the package,</p><pre><code class="language-julia hljs">using Distributed</code></pre><p>and launching some new processes. It is often sensible to create as many processes as there are cores.</p><pre><code class="language-julia hljs">ncores = length(Sys.cpu_info())
addprocs(ncores)</code></pre><p>You can think of each process as a separate computer running a fresh Julia environment, so we&#39;ll need to import Sunny and define functions in each of these environments. This is easily achieved with the <code>@everywhere</code> macro.</p><pre><code class="language-julia hljs">@everywhere using Sunny

@everywhere function make_system(seed)
    latvecs = lattice_vectors(1, 1, 1, 90, 90, 90)
    positions = [[0, 0, 0]/2, [1, 1, 1]/2]
    cryst = Crystal(latvecs, positions)
    sys = System(cryst, [1 =&gt; Moment(s=1, g=2)], :dipole; seed)
    sys = resize_supercell(sys, (10, 10, 2))
    set_exchange!(sys, 1.0, Bond(1, 1, [1, 0, 0]))
    return sys
end</code></pre><p>A simple way to perform work on these processes is to use the parallel map function, <code>pmap</code>. This will apply a function to each element of some iterable, such as a list of numbers, and return a list of the results. It is a <em>parallel</em> map because these function calls may occur at the same time on different Julia processes. The <code>pmap</code> function takes care of distributing the work among the different processes and retrieving the results.</p><p>In the example below, we give <code>pmap</code> a list of RNG seeds to iterate over, and we define the function that will be applied to each of these seeds in a <code>do</code> block. The contents of this block are essentially the same as what we put inside our parallel <code>for</code> loop in the multithreading example. The main difference is that the <code>System</code>s and <code>SampledCorrelations</code> are not created in advance of the parallelization but are instead created inside each Julia process. The <code>do</code> block returns a <code>SampledCorrelations</code>, and the output of all the parallel computations are collected into list of <code>SampledCorrelations</code> called <code>scs</code>.</p><pre><code class="language-julia hljs">scs = pmap(1:ncores) do id
    sys = make_system(id)
    sc = SampledCorrelations(sys; dt=0.1, energies, measure)
    integrator = Langevin(0.05; damping=0.2, kT=0.5)

    for _ in 1:5000
        step!(sys, integrator)
    end
    for _ in 1:10
        for _ in 1:1000 
            step!(sys, integrator)
        end
        add_sample!(sc, sys)
    end

    return sc
end</code></pre><p>Finally, merge the results into a summary <code>SampledCorrelations</code>.</p><pre><code class="language-julia hljs">sc = merge_correlations(scs)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="renormalization.html">« Interaction Renormalization</a><a class="docs-footer-nextpage" href="versions.html">Version History »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 6 December 2024 22:31">Friday 6 December 2024</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
