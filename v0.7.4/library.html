<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Reference · Documentation</title><meta name="title" content="Library Reference · Documentation"/><meta property="og:title" content="Library Reference · Documentation"/><meta property="twitter:title" content="Library Reference · Documentation"/><meta name="description" content="Documentation for Documentation."/><meta property="og:description" content="Documentation for Documentation."/><meta property="twitter:description" content="Documentation for Documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img class="docs-light-only" src="assets/logo.svg" alt="Documentation logo"/><img class="docs-dark-only" src="assets/logo-dark.svg" alt="Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Welcome</a></li><li><a class="tocitem" href="why.html">Why Choose Sunny?</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/01_LSWT_CoRh2O4.html">1. Spin wave simulations of CoRh₂O₄</a></li><li><a class="tocitem" href="examples/02_LLD_CoRh2O4.html">2. Landau-Lifshitz dynamics of CoRh₂O₄ at finite <em>T</em></a></li><li><a class="tocitem" href="examples/03_LSWT_SU3_FeI2.html">3. Multi-flavor spin wave simulations of FeI₂</a></li><li><a class="tocitem" href="examples/04_GSD_FeI2.html">4. Generalized spin dynamics of FeI₂ at finite <em>T</em></a></li><li><a class="tocitem" href="examples/05_MC_Ising.html">5. Monte Carlo sampling of the Ising model</a></li><li><a class="tocitem" href="examples/06_CP2_Skyrmions.html">6. Dynamical quench into CP² skyrmion liquid</a></li><li><a class="tocitem" href="examples/07_Dipole_Dipole.html">7. Long-range dipole interactions</a></li><li><a class="tocitem" href="examples/08_Momentum_Conventions.html">8. Momentum transfer conventions</a></li><li><a class="tocitem" href="examples/09_Disorder_KPM.html">9. Disordered system with KPM</a></li><li><input class="collapse-toggle" id="menuitem-3-10" type="checkbox"/><label class="tocitem" for="menuitem-3-10"><span class="docs-label">SpinW ports</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="examples/spinw/SW01_FM_Heseinberg_chain.html">SW01 - FM Heisenberg chain</a></li><li><a class="tocitem" href="examples/spinw/SW02_AFM_Heisenberg_chain.html">SW02 - AFM Heisenberg chain</a></li><li><a class="tocitem" href="examples/spinw/SW03_Frustrated_chain.html">SW03 - Frustrated J1-J2 chain</a></li><li><a class="tocitem" href="examples/spinw/SW04_Frustrated_square.html">SW04 - Frustrated square lattice</a></li><li><a class="tocitem" href="examples/spinw/SW05_Simple_kagome_FM.html">SW05 - Simple kagome ferromagnet</a></li><li><a class="tocitem" href="examples/spinw/SW06_Complex_kagome_FM.html">SW06 - Complex kagome ferromagnet</a></li><li><a class="tocitem" href="examples/spinw/SW07_k0_kagome_AFM.html">SW07 - k=0 kagome antiferromagnet</a></li><li><a class="tocitem" href="examples/spinw/SW08_sqrt3_kagome_AFM.html">SW08 - √3×√3 kagome antiferromagnet</a></li><li><a class="tocitem" href="examples/spinw/SW09_k0_kagome_AFM_DM.html">SW09 - k=0 kagome AFM and DM</a></li><li><a class="tocitem" href="examples/spinw/SW10_Energy_cut.html">SW10 - Energy cut on square lattice</a></li><li><a class="tocitem" href="examples/spinw/SW11_La2CuO4.html">SW11 - La₂CuO₄</a></li><li><a class="tocitem" href="examples/spinw/SW12_Triangular_easy_plane.html">SW12 - Triangular lattice with easy plane</a></li><li><a class="tocitem" href="examples/spinw/SW13_LiNiPO4.html">SW13 - LiNiPO₄</a></li><li><a class="tocitem" href="examples/spinw/SW14_YVO3.html">SW14 - YVO₃</a></li><li><a class="tocitem" href="examples/spinw/SW15_Ba3NbFe3Si2O14.html">SW15 - Ba₃NbFe₃Si₂O₁₄</a></li><li><a class="tocitem" href="examples/spinw/SW18_Distorted_kagome.html">SW18 - Distorted kagome</a></li><li><a class="tocitem" href="examples/spinw/SW19_Different_Ions.html">SW19 - Different magnetic ions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-11" type="checkbox"/><label class="tocitem" for="menuitem-3-11"><span class="docs-label">Contributed</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="examples/contributed/MgCr2O4-tutorial.html">MgCr2O4 at Finite Temperature</a></li><li><a class="tocitem" href="examples/contributed/kappa_tutorial.html">Enforcing the quantum sum rule with moment renormalization</a></li></ul></li></ul></li><li class="is-active"><a class="tocitem" href="library.html">Library Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Core-Sunny-functions"><span>Core Sunny functions</span></a></li><li><a class="tocitem" href="#Optional-Makie-extensions"><span>Optional Makie extensions</span></a></li><li><a class="tocitem" href="#Optional-WriteVTK-extensions"><span>Optional WriteVTK extensions</span></a></li></ul></li><li><span class="tocitem">Notes and Details</span><ul><li><a class="tocitem" href="structure-factor.html">Structure Factor Conventions</a></li><li><a class="tocitem" href="renormalization.html">Interaction Renormalization</a></li><li><a class="tocitem" href="parallelism.html">Parallelizing Calculations</a></li></ul></li><li><a class="tocitem" href="versions.html">Version History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="library.html">Library Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="library.html">Library Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SunnySuite/Sunny.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SunnySuite/Sunny.jl/blob/main/docs/src/library.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><p>This page describes the public types and functions exported by Sunny. This documentation can be also be accessed using the Julia help system (enter <code>?</code> at the Julia command prompt).</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="library.html#Sunny.BinningParameters"><code>Sunny.BinningParameters</code></a></li><li><a href="library.html#Sunny.Bond"><code>Sunny.Bond</code></a></li><li><a href="library.html#Sunny.Crystal"><code>Sunny.Crystal</code></a></li><li><a href="library.html#Sunny.FormFactor"><code>Sunny.FormFactor</code></a></li><li><a href="library.html#Sunny.ImplicitMidpoint"><code>Sunny.ImplicitMidpoint</code></a></li><li><a href="library.html#Sunny.Langevin"><code>Sunny.Langevin</code></a></li><li><a href="library.html#Sunny.LocalSampler"><code>Sunny.LocalSampler</code></a></li><li><a href="library.html#Sunny.Moment"><code>Sunny.Moment</code></a></li><li><a href="library.html#Sunny.SampledCorrelations"><code>Sunny.SampledCorrelations</code></a></li><li><a href="library.html#Sunny.SampledCorrelationsStatic"><code>Sunny.SampledCorrelationsStatic</code></a></li><li><a href="library.html#Sunny.Site"><code>Sunny.Site</code></a></li><li><a href="library.html#Sunny.SpinWaveTheory"><code>Sunny.SpinWaveTheory</code></a></li><li><a href="library.html#Sunny.SpinWaveTheoryKPM"><code>Sunny.SpinWaveTheoryKPM</code></a></li><li><a href="library.html#Sunny.SpinWaveTheorySpiral"><code>Sunny.SpinWaveTheorySpiral</code></a></li><li><a href="library.html#Sunny.System"><code>Sunny.System</code></a></li><li><a href="library.html#Sunny.Units"><code>Sunny.Units</code></a></li><li><a href="library.html#Sunny.add_sample!"><code>Sunny.add_sample!</code></a></li><li><a href="library.html#Sunny.clone_correlations"><code>Sunny.clone_correlations</code></a></li><li><a href="library.html#Sunny.clone_system"><code>Sunny.clone_system</code></a></li><li><a href="library.html#Sunny.dispersion"><code>Sunny.dispersion</code></a></li><li><a href="library.html#Sunny.dmvec"><code>Sunny.dmvec</code></a></li><li><a href="library.html#Sunny.domain_average"><code>Sunny.domain_average</code></a></li><li><a href="library.html#Sunny.eachsite"><code>Sunny.eachsite</code></a></li><li><a href="library.html#Sunny.enable_dipole_dipole!"><code>Sunny.enable_dipole_dipole!</code></a></li><li><a href="library.html#Sunny.energy"><code>Sunny.energy</code></a></li><li><a href="library.html#Sunny.energy_per_site"><code>Sunny.energy_per_site</code></a></li><li><a href="library.html#Sunny.excitations"><code>Sunny.excitations</code></a></li><li><a href="library.html#Sunny.excitations!"><code>Sunny.excitations!</code></a></li><li><a href="library.html#Sunny.export_vtk"><code>Sunny.export_vtk</code></a></li><li><a href="library.html#Sunny.gaussian"><code>Sunny.gaussian</code></a></li><li><a href="library.html#Sunny.global_position"><code>Sunny.global_position</code></a></li><li><a href="library.html#Sunny.intensities"><code>Sunny.intensities</code></a></li><li><a href="library.html#Sunny.intensities_bands"><code>Sunny.intensities_bands</code></a></li><li><a href="library.html#Sunny.intensities_static"><code>Sunny.intensities_static</code></a></li><li><a href="library.html#Sunny.lattice_params"><code>Sunny.lattice_params</code></a></li><li><a href="library.html#Sunny.lattice_vectors"><code>Sunny.lattice_vectors</code></a></li><li><a href="library.html#Sunny.load_nxs"><code>Sunny.load_nxs</code></a></li><li><a href="library.html#Sunny.lorentzian"><code>Sunny.lorentzian</code></a></li><li><a href="library.html#Sunny.magnetic_moment"><code>Sunny.magnetic_moment</code></a></li><li><a href="library.html#Sunny.merge_correlations"><code>Sunny.merge_correlations</code></a></li><li><a href="library.html#Sunny.minimize_energy!"><code>Sunny.minimize_energy!</code></a></li><li><a href="library.html#Sunny.minimize_spiral_energy!"><code>Sunny.minimize_spiral_energy!</code></a></li><li><a href="library.html#Sunny.modify_exchange_with_truncated_dipole_dipole!"><code>Sunny.modify_exchange_with_truncated_dipole_dipole!</code></a></li><li><a href="library.html#Sunny.plot_intensities"><code>Sunny.plot_intensities</code></a></li><li><a href="library.html#Sunny.plot_intensities!"><code>Sunny.plot_intensities!</code></a></li><li><a href="library.html#Sunny.plot_spins"><code>Sunny.plot_spins</code></a></li><li><a href="library.html#Sunny.plot_spins!"><code>Sunny.plot_spins!</code></a></li><li><a href="library.html#Sunny.polarize_spins!"><code>Sunny.polarize_spins!</code></a></li><li><a href="library.html#Sunny.position_to_site"><code>Sunny.position_to_site</code></a></li><li><a href="library.html#Sunny.powder_average"><code>Sunny.powder_average</code></a></li><li><a href="library.html#Sunny.primitive_cell"><code>Sunny.primitive_cell</code></a></li><li><a href="library.html#Sunny.print_bond"><code>Sunny.print_bond</code></a></li><li><a href="library.html#Sunny.print_irreducible_bz_paths"><code>Sunny.print_irreducible_bz_paths</code></a></li><li><a href="library.html#Sunny.print_site"><code>Sunny.print_site</code></a></li><li><a href="library.html#Sunny.print_stevens_expansion"><code>Sunny.print_stevens_expansion</code></a></li><li><a href="library.html#Sunny.print_suggested_frame"><code>Sunny.print_suggested_frame</code></a></li><li><a href="library.html#Sunny.print_symmetry_table"><code>Sunny.print_symmetry_table</code></a></li><li><a href="library.html#Sunny.print_wrapped_intensities"><code>Sunny.print_wrapped_intensities</code></a></li><li><a href="library.html#Sunny.propose_delta"><code>Sunny.propose_delta</code></a></li><li><a href="library.html#Sunny.propose_flip"><code>Sunny.propose_flip</code></a></li><li><a href="library.html#Sunny.propose_uniform"><code>Sunny.propose_uniform</code></a></li><li><a href="library.html#Sunny.q_space_grid"><code>Sunny.q_space_grid</code></a></li><li><a href="library.html#Sunny.q_space_path"><code>Sunny.q_space_path</code></a></li><li><a href="library.html#Sunny.randomize_spins!"><code>Sunny.randomize_spins!</code></a></li><li><a href="library.html#Sunny.reference_bonds"><code>Sunny.reference_bonds</code></a></li><li><a href="library.html#Sunny.remove_periodicity!"><code>Sunny.remove_periodicity!</code></a></li><li><a href="library.html#Sunny.repeat_periodically"><code>Sunny.repeat_periodically</code></a></li><li><a href="library.html#Sunny.repeat_periodically_as_spiral"><code>Sunny.repeat_periodically_as_spiral</code></a></li><li><a href="library.html#Sunny.reshape_supercell"><code>Sunny.reshape_supercell</code></a></li><li><a href="library.html#Sunny.resize_supercell"><code>Sunny.resize_supercell</code></a></li><li><a href="library.html#Sunny.rotate_operator"><code>Sunny.rotate_operator</code></a></li><li><a href="library.html#Sunny.set_coherent!"><code>Sunny.set_coherent!</code></a></li><li><a href="library.html#Sunny.set_dipole!"><code>Sunny.set_dipole!</code></a></li><li><a href="library.html#Sunny.set_dipoles_from_mcif!"><code>Sunny.set_dipoles_from_mcif!</code></a></li><li><a href="library.html#Sunny.set_exchange!"><code>Sunny.set_exchange!</code></a></li><li><a href="library.html#Sunny.set_exchange_at!"><code>Sunny.set_exchange_at!</code></a></li><li><a href="library.html#Sunny.set_field!"><code>Sunny.set_field!</code></a></li><li><a href="library.html#Sunny.set_field_at!"><code>Sunny.set_field_at!</code></a></li><li><a href="library.html#Sunny.set_onsite_coupling!"><code>Sunny.set_onsite_coupling!</code></a></li><li><a href="library.html#Sunny.set_onsite_coupling_at!"><code>Sunny.set_onsite_coupling_at!</code></a></li><li><a href="library.html#Sunny.set_pair_coupling!"><code>Sunny.set_pair_coupling!</code></a></li><li><a href="library.html#Sunny.set_pair_coupling_at!"><code>Sunny.set_pair_coupling_at!</code></a></li><li><a href="library.html#Sunny.set_spin_rescaling!"><code>Sunny.set_spin_rescaling!</code></a></li><li><a href="library.html#Sunny.set_vacancy_at!"><code>Sunny.set_vacancy_at!</code></a></li><li><a href="library.html#Sunny.spin_label"><code>Sunny.spin_label</code></a></li><li><a href="library.html#Sunny.spin_matrices"><code>Sunny.spin_matrices</code></a></li><li><a href="library.html#Sunny.spiral_energy"><code>Sunny.spiral_energy</code></a></li><li><a href="library.html#Sunny.spiral_energy_per_site"><code>Sunny.spiral_energy_per_site</code></a></li><li><a href="library.html#Sunny.ssf_custom"><code>Sunny.ssf_custom</code></a></li><li><a href="library.html#Sunny.ssf_custom_bm"><code>Sunny.ssf_custom_bm</code></a></li><li><a href="library.html#Sunny.ssf_perp"><code>Sunny.ssf_perp</code></a></li><li><a href="library.html#Sunny.ssf_trace"><code>Sunny.ssf_trace</code></a></li><li><a href="library.html#Sunny.standardize"><code>Sunny.standardize</code></a></li><li><a href="library.html#Sunny.step!"><code>Sunny.step!</code></a></li><li><a href="library.html#Sunny.stevens_matrices"><code>Sunny.stevens_matrices</code></a></li><li><a href="library.html#Sunny.subcrystal"><code>Sunny.subcrystal</code></a></li><li><a href="library.html#Sunny.suggest_magnetic_supercell"><code>Sunny.suggest_magnetic_supercell</code></a></li><li><a href="library.html#Sunny.suggest_timestep"><code>Sunny.suggest_timestep</code></a></li><li><a href="library.html#Sunny.symmetry_equivalent_bonds"><code>Sunny.symmetry_equivalent_bonds</code></a></li><li><a href="library.html#Sunny.to_inhomogeneous"><code>Sunny.to_inhomogeneous</code></a></li><li><a href="library.html#Sunny.to_product_space"><code>Sunny.to_product_space</code></a></li><li><a href="library.html#Sunny.view_bz"><code>Sunny.view_bz</code></a></li><li><a href="library.html#Sunny.view_crystal"><code>Sunny.view_crystal</code></a></li><li><a href="library.html#Sunny.@mix_proposals"><code>Sunny.@mix_proposals</code></a></li></ul><h2 id="Core-Sunny-functions"><a class="docs-heading-anchor" href="#Core-Sunny-functions">Core Sunny functions</a><a id="Core-Sunny-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Sunny-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.BinningParameters" href="#Sunny.BinningParameters"><code>Sunny.BinningParameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BinningParameters(binstart, binend, binwidth; covectors=I(4))
BinningParameters(binstart, binend; numbins, covectors=I(4))</code></pre><p>Describes a 4D parallelepided histogram in a format compatible with experimental Inelasitic Neutron Scattering data. See <code>generate_mantid_script_from_binning_parameters</code> to convert <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> to a format understandable by the <a href="https://www.mantidproject.org/">Mantid software</a>, or <a href="library.html#Sunny.load_nxs"><code>load_nxs</code></a> to load <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> from a Mantid <code>.nxs</code> file.</p><p>The coordinates of the histogram axes are specified by multiplication of <code>(q,ω)</code> with each row of the <code>covectors</code> matrix, with <code>q</code> given in [R.L.U.]. Since the default <code>covectors</code> matrix is the identity matrix, the default axes are <code>(qx, qy, qz, ω)</code> in absolute units.</p><p>The convention for the binning scheme is that:</p><ul><li>The left edge of the first bin starts at <code>binstart</code></li><li>The bin width is <code>binwidth</code></li><li>The last bin contains <code>binend</code></li><li>There are no &quot;partial bins;&quot; the last bin may contain values greater than <code>binend</code>.</li></ul><p>A <code>value</code> can be binned by computing its bin index:</p><pre><code class="language-jl hljs">    coords = covectors * value
    bin_ix = 1 .+ floor.(Int64, (coords .- binstart) ./ binwidth)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Binning/Binning.jl#L3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Bond" href="#Sunny.Bond"><code>Sunny.Bond</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bond(i, j, n)</code></pre><p>Represents a bond between atom indices <code>i</code> and <code>j</code>. <code>n</code> is a vector of three integers specifying unit cell displacement in terms of lattice vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Symmetry/Bond.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Crystal" href="#Sunny.Crystal"><code>Sunny.Crystal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An object describing a crystallographic unit cell and its space group symmetry. Constructors are as follows:</p><pre><code class="nohighlight hljs">Crystal(filename; override_symmetry=false, symprec=nothing)</code></pre><p>Reads the crystal from a <code>.cif</code> file located at the path <code>filename</code>. If <code>override_symmetry=true</code>, the spacegroup will be inferred based on atom positions and the returned unit cell may be reduced in size. For an mCIF file, the return value is the magnetic supercell, unless <code>override_symmetry=true</code>. If a precision for spacegroup symmetries cannot be inferred from the CIF file, it must be specified with <code>symprec</code>. The <code>latvecs</code> field of the returned <code>Crystal</code> will be in units of angstrom.</p><pre><code class="nohighlight hljs">Crystal(latvecs, positions; types=nothing, symprec=1e-5)</code></pre><p>Constructs a crystal from the complete list of atom positions <code>positions</code>, with coordinates (between 0 and 1) in units of lattice vectors <code>latvecs</code>. Spacegroup symmetry information is automatically inferred using the <a href="https://github.com/spglib/spglib">Spglib package</a> [1]. The optional parameter <code>types</code> is a list of strings, one for each atom, and can be used to break symmetry-equivalence between atoms.</p><pre><code class="nohighlight hljs">Crystal(latvecs, positions, spacegroup; types=nothing, choice=nothing, symprec=1e-5)</code></pre><p>Builds a crystal using the symmetries of a <code>spacegroup</code>. One representative atom must be specified for each occupied Wyckoff. The <code>spacegroup</code> may be specified as a number 1..230 or as a string, e.g., Hermann–Mauguin or Hall symbol. If only a spacegroup number is provided, the ITA standard setting [2] will be employed, consistent with conventions from the <a href="https://www.cryst.ehu.es">Bilbao crystallographic server</a>. If a spacegroup symbol is provided that allows for multiple ITA settings, the possible disambiguations will be included in an error message, and may involve a <code>choice</code> string.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Read a Crystal from a .cif file
Crystal(&quot;filename.cif&quot;)

# Build a BCC crystal in the conventional cubic unit cell by specifying both
# atoms. The spacegroup 229 is inferred.
latvecs = lattice_vectors(1, 1, 1, 90, 90, 90)
positions = [[0, 0, 0], [1/2, 1/2, 1/2]]
Crystal(latvecs, positions)

# Build a CsCl crystal (two simple cubic sublattices). Because of the distinct
# atom types, the spacegroup number 221 is now inferred.
types = [&quot;Na&quot;, &quot;Cl&quot;]
cryst = Crystal(latvecs, positions; types)

# Build a diamond cubic crystal from its spacegroup number 227 and a single
# atom position belonging to Wyckoff 8a.
positions = [[1/8, 1/8, 1/8]]
cryst = Crystal(latvecs, positions, 227)

# Build an equivalent crystal using a different origin choice.
positions = [[0, 0, 0]]
cryst = Crystal(latvecs, positions, 227; choice=&quot;1&quot;)</code></pre><p>See also <a href="library.html#Sunny.lattice_vectors"><code>lattice_vectors</code></a>.</p><p><strong>References</strong></p><ol><li><a href="https://arxiv.org/abs/1808.01590">A. Togo, K. Shinohara, I. Tanaka, <em>Spglib: a software library for crystal symmetry search</em> (2018) [arXiv:1808.01590]</a>.</li><li><a href="https://doi.org/10.1107/97809553602060000114">International Tables of Crystallography, Volume A (2016)</a>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Symmetry/Crystal.jl#L2-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.FormFactor" href="#Sunny.FormFactor"><code>Sunny.FormFactor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FormFactor(ion::String; g_lande=2)</code></pre><p>The magnetic form factor for a given magnetic ion and charge state. When passed to <a href="library.html#Sunny.intensities"><code>intensities</code></a>, it rescales structure factor intensities based on the magnitude of the scattering vector, <span>$|𝐪|$</span>.</p><p>The parameter <code>ion</code> must be one of the following strings:</p><pre><code class="nohighlight hljs">Am2, Am3, Am4, Am5, Am6, Am7, Au1, Au2, Au3, Au4, Au5, Ce2, Co0, Co1, Co2, Co3,
Co4, Cr0, Cr1, Cr2, Cr3, Cr4, Cu0, Cu1, Cu2, Cu3, Cu4, Dy2, Dy3, Er2, Er3, Eu2,
Eu3, Fe0, Fe1, Fe2, Fe3, Fe4, Gd2, Gd3, Hf2, Hf3, Ho2, Ho3, Ir0a, Ir0b, Ir0c,
Ir1a, Ir1b, Ir2, Ir3, Ir4, Ir5, Ir6, Mn0, Mn1, Mn2, Mn3, Mn4, Mn5, Mo0, Mo1, Nb0,
Nb1, Nd2, Nd3, Ni0, Ni1, Ni2, Ni3, Ni4, Np3, Np4, Np5, Np6, Os0a, Os0b, Os0c,
Os1a, Os1b, Os2, Os3, Os4, Os5, Os6, Os7, Pd0, Pd1, Pr3, Pt1, Pt2, Pt3, Pt4,
Pt5, Pt6, Pu3, Pu4, Pu5, Pu6, Re0a, Re0b, Re0c, Re1a, Re1b, Re2, Re3, Re4, Re5,
Re6, Rh0, Rh1, Ru0, Ru1, Sc0, Sc1, Sc2, Sm2, Sm3, Ta2, Ta3, Ta4, Tb2, Tb3, Tc0,
Tc1, Ti0, Ti1, Ti2, Ti3, Tm2, Tm3, U3, U4, U5, V0, V1, V2, V3, V4, W0a, W0b,
W0c, W1a, W1b, W2c, W3, W4, W5, Y0, Yb2, Yb3, Zr0, Zr1</code></pre><p>The trailing number denotes ionization state. For example, <code>&quot;Fe0&quot;</code> denotes a neutral iron atom, while <code>&quot;Fe2&quot;</code> denotes <code>Fe²⁺</code>. If multiple electronic configurations are possible, they will be distinguished by a trailing letter (<code>a</code>, <code>b</code>, ...). Omitting this letter will print an informative error,</p><pre><code class="nohighlight hljs">FormFactor(&quot;Ir0&quot;)

ERROR: Disambiguate form factor according to electronic configuration:
    &quot;Ir0a&quot; -- 6s⁰5d⁹
    &quot;Ir0b&quot; -- 6s¹5d⁸
    &quot;Ir0c&quot; -- 6s²5d⁷</code></pre><p>In the dipolar approximation (small <span>$|𝐪|$</span>) the form factor is</p><p><span>$F(s) = ⟨j_0(s)⟩ + [(2-g)/g] ⟨j_2(s)⟩$</span>,</p><p>involving <span>$s = |𝐪|/4π$</span> and the Landé <span>$g$</span>-factor. The <span>$⟨j_l(s)⟩$</span> are radial averages of the <span>$l$</span>th spherical Bessel function of the magnetic dipole. More details are provided in Ref. [1].</p><p>The standard approximation tables involve expansion in Gaussians,</p><p class="math-container">\[⟨j_0(s)⟩ = A e^{-as^2} + B e^{-bs^2} + C e^{-cs^2} + D e^{-ds^2} + E\]</p><p>and</p><p class="math-container">\[⟨j_2(s)⟩ = (A e^{-as^2} + B e^{-bs^2} + C e^{-cs^2} + D e^{-ds^2} + E) s^2.\]</p><p>For 3d, 4d, rare earth, and actinide ions, Sunny uses the revised tables of P. J. Brown, as documented in the McPhase package [2]. For 5d ions, Sunny uses the tables of Kobayashi, Nagao, Ito [3].</p><p>Two special, <span>$𝐪$</span>-independent form factor values are available: <code>one(FormFactor)</code> and <code>zero(FormFactor)</code>. The first idealizes the magnetic ion as a perfect point particle, while the second zeros all contributions from the magnetic ion.</p><p><strong>References</strong></p><ol><li><a href="https://www.ill.eu/sites/ccsl/ffacts/ffachtml.html">P. J. Brown, The Neutron Data Booklet, 2nd ed., Sec. 2.5 <em>Magnetic Form Factors</em> (2003)</a>.</li><li>Coefficient tables in <a href="https://www2.cpfs.mpg.de/~rotter/homepage_mcphase/manual/node137.html">McPhase documentation</a>.</li><li><a href="https://doi.org/10.1107/S010876731102633X">K. Kobayashi, T. Nagao, M. Ito, <em>Radial integrals for the magnetic form factor of 5d transition elements</em>, Acta Cryst. A, <strong>67</strong>, 473–480 (2011)</a>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/FormFactor.jl#L36-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.ImplicitMidpoint" href="#Sunny.ImplicitMidpoint"><code>Sunny.ImplicitMidpoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ImplicitMidpoint(dt::Float64; atol=1e-12) where N</code></pre><p>The implicit midpoint method for integrating the Landau-Lifshitz spin dynamics or its generalization to SU(<em>N</em>) coherent states [1]. One call to the <a href="library.html#Sunny.step!"><code>step!</code></a> function will advance a <a href="library.html#Sunny.System"><code>System</code></a> by <code>dt</code> units of time. This integration scheme is exactly symplectic and eliminates energy drift over arbitrarily long simulation trajectories.</p><p><strong>References</strong></p><ol><li><a href="https://doi.org/10.1103/PhysRevB.104.104409">H. Zhang and C. D. Batista, <em>Classical spin dynamics based on SU(N) coherent states</em>, Phys. Rev. B <strong>104</strong>, 104409 (2021)</a>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Integrators.jl#L94-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Langevin" href="#Sunny.Langevin"><code>Sunny.Langevin</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Langevin(dt::Float64; damping::Float64, kT::Float64)</code></pre><p>An integrator for Langevin spin dynamics using the explicit Heun method. The <code>damping</code> parameter controls the coupling to an implicit thermal bath. One call to the <a href="library.html#Sunny.step!"><code>step!</code></a> function will advance a <a href="library.html#Sunny.System"><code>System</code></a> by <code>dt</code> units of time. Can be used to sample from the Boltzmann distribution at temperature <code>kT</code>. An alternative approach to sampling states from thermal equilibrium is <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>, which proposes local Monte Carlo moves. For example, use <code>LocalSampler</code> instead of <code>Langevin</code> to sample Ising-like spins.</p><p>Setting <code>damping = 0</code> disables coupling to the thermal bath, yielding an energy-conserving spin dynamics. The <code>Langevin</code> integrator uses an explicit numerical integrator which cannot prevent energy drift. Alternatively, the <a href="library.html#Sunny.ImplicitMidpoint"><code>ImplicitMidpoint</code></a> method can be used, which is more expensive but prevents energy drift through exact conservation of the symplectic 2-form.</p><p>If the <a href="library.html#Sunny.System"><code>System</code></a> has <code>mode = :dipole</code>, then the dynamics is the stochastic Landau-Lifshitz equation,</p><p class="math-container">\[    d𝐒/dt = -𝐒 × (ξ - 𝐁 + λ 𝐒 × 𝐁),\]</p><p>where <span>$𝐁 = -dE/d𝐒$</span> is the effective field felt by the expected spin dipole <span>$𝐒$</span>. The components of <span>$ξ$</span> are Gaussian white noise, with magnitude <span>$√(2 k_B T λ)$</span> set by a fluctuation-dissipation theorem. The parameter <code>damping</code> sets the phenomenological coupling <span>$λ$</span> to the thermal bath. </p><p>If the <code>System</code> has <code>mode = :SUN</code>, then this dynamics generalizes [1] to a stochastic nonlinear Schrödinger equation for SU(<em>N</em>) coherent states <span>$𝐙$</span>,</p><p class="math-container">\[    d𝐙/dt = -i P [ζ + (1 - i λ̃) ℋ 𝐙].\]</p><p>Here, <span>$P$</span> projects onto the space orthogonal to <span>$𝐙$</span>, and <span>$ζ$</span> denotes complex Gaussian white noise with magnitude <span>$√(2 k_B T λ̃)$</span>. The local-Hamiltonian <span>$ℋ$</span> embeds the energy gradient into the 𝔰𝔲(<em>N</em>) Lie algebra, and generates evolution of spin dipoles, quadrupoles, etc. The parameter <code>damping</code> here sets <span>$λ̃$</span>, which is analogous to <span>$λ$</span> above.</p><p>When applied to SU(2) coherent states, the generalized spin dynamics reduces exactly to the stochastic Landau-Lifshitz equation. The mapping is as follows. Normalized coherent states <span>$𝐙$</span> map to dipole expectation values <span>$𝐒 = 𝐙^{†} Ŝ 𝐙$</span>, where spin operators <span>$Ŝ$</span> are a spin-<span>$|𝐒|$</span> representation of SU(2). The local effective Hamiltonian <span>$ℋ = -𝐁 ⋅ Ŝ$</span> generates rotation of the dipole in analogy to the vector cross product <span>$S × 𝐁$</span>. The coupling to the thermal bath maps as <span>$λ̃ = |𝐒| λ$</span>. Note, therefore, that the scaling of the <code>damping</code> parameter varies subtly between <code>:dipole</code> and <code>:SUN</code> modes.</p><p><strong>References</strong></p><ol><li><a href="https://doi.org/10.1103/PhysRevB.106.235154">D. Dahlbom et al., <em>Langevin dynamics of generalized spins as SU(N) coherent states</em>, Phys. Rev. B <strong>106</strong>, 235154 (2022)</a>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Integrators.jl#L1-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.LocalSampler" href="#Sunny.LocalSampler"><code>Sunny.LocalSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocalSampler(; kT, nsweeps=1.0, propose=propose_uniform)</code></pre><p>Monte Carlo simulation involving Metropolis updates to individual spins. One call to the <a href="library.html#Sunny.step!"><code>step!</code></a> function will perform <code>nsweeps</code> of MCMC sampling for a provided <a href="library.html#Sunny.System"><code>System</code></a>. The default value of <code>1.0</code> means that <code>step!</code> performs, on average, one trial update per spin.</p><p>Assuming ergodicity, the <code>LocalSampler</code> will sample from thermal equilibrium for the target temperature <code>kT</code>. </p><p>The trial spin updates are sampled using the <code>propose</code> function. Options include <a href="library.html#Sunny.propose_uniform"><code>propose_uniform</code></a>, <a href="library.html#Sunny.propose_flip"><code>propose_flip</code></a>, and <a href="library.html#Sunny.propose_delta"><code>propose_delta</code></a>. Multiple proposals can be mixed with the macro <a href="library.html#Sunny.@mix_proposals"><code>@mix_proposals</code></a>.</p><p>The returned object stores fields <code>ΔE</code> and <code>ΔS</code>, which represent the cumulative change to the net energy and dipole, respectively.</p><div class="admonition is-warning"><header class="admonition-header">Efficiency considerations</header><div class="admonition-body"><p>Prefer <a href="library.html#Sunny.Langevin"><code>Langevin</code></a> sampling in most cases. Langevin dynamics will usually be much more efficient for sampling Heisenberg-like spins that vary continuously. <code>LocalSampler</code> is most useful for sampling from discrete spin states. In particular, <a href="library.html#Sunny.propose_flip"><code>propose_flip</code></a> may be required for sampling Ising-like spins that arise due to a strong easy-axis anisotropy. For strong but finite single-ion anisotropy, consider alternating between <code>Langevin</code> and <code>LocalSampler</code> update steps.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/MonteCarlo/Samplers.jl#L103-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Moment" href="#Sunny.Moment"><code>Sunny.Moment</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Moment(; s, g)</code></pre><p>Characterizes a effective spin magnetic moment on an atom. Quantum spin-<code>s</code> is a multiple of 1/2 in units of ħ. The <code>g</code>-factor or tensor defines the <a href="library.html#Sunny.magnetic_moment"><code>magnetic_moment</code></a> <span>$μ = - g 𝐒$</span> in units of the Bohr magneton.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Moment(s=3/2, g=2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/Moment.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.SampledCorrelations" href="#Sunny.SampledCorrelations"><code>Sunny.SampledCorrelations</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SampledCorrelations(sys::System; measure, energies, dt)</code></pre><p>An object to accumulate samples of dynamical pair correlations. The <code>measure</code> argument specifies a pair correlation type, e.g. <a href="library.html#Sunny.ssf_perp"><code>ssf_perp</code></a>. The <code>energies</code> must be evenly-spaced and starting from 0, e.g. <code>energies = range(0, 3, 100)</code>. Select the integration time-step <code>dt</code> according to accuracy and speed considerations. <a href="library.html#Sunny.suggest_timestep"><code>suggest_timestep</code></a> can help in selecting an appropriate value.</p><p>Dynamical correlations will be accumulated through calls to <a href="library.html#Sunny.add_sample!"><code>add_sample!</code></a>, which expects a spin configuration in thermal equilibrium. A classical spin dynamics trajectory will be simulated of sufficient length to achieve the target energy resolution. The resulting data can can then be extracted as pair-correlation <a href="library.html#Sunny.intensities"><code>intensities</code></a> with appropriate classical-to-quantum correction factors. See also <a href="library.html#Sunny.intensities_static"><code>intensities_static</code></a>, which integrates over energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/SampledCorrelations/SampledCorrelations.jl#L118-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.SampledCorrelationsStatic" href="#Sunny.SampledCorrelationsStatic"><code>Sunny.SampledCorrelationsStatic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SampledCorrelationsStatic(sys::System; measure)</code></pre><p>An object to accumulate samples of static pair correlations. It is similar to <a href="library.html#Sunny.SampledCorrelations"><code>SampledCorrelations</code></a>, but no time-integration will be performed on calls to <a href="library.html#Sunny.add_sample!"><code>add_sample!</code></a>. The resulting object can be used with <a href="library.html#Sunny.intensities_static"><code>intensities_static</code></a> to calculate statistics from the classical Boltzmann distribution. Dynamical <a href="library.html#Sunny.intensities"><code>intensities</code></a> data, however, will be unavailable. Similarly, classical-to-quantum corrections that rely on the excitation spectrum cannot be performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/SampledCorrelations/SampledCorrelations.jl#L205-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Site" href="#Sunny.Site"><code>Sunny.Site</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(cell1, cell2, cell3, i) :: Site</code></pre><p>Four indices identifying a single site in a <a href="library.html#Sunny.System"><code>System</code></a>. The first three indices select the unit cell and the last index selects the sublattice, i.e., the <span>$i$</span>th atom within the unit cell.</p><p>This object can be used to index <code>dipoles</code> and <code>coherents</code> fields of a <code>System</code>. A <code>Site</code> is also required to specify inhomogeneous interactions via functions such as <a href="library.html#Sunny.set_field_at!"><code>set_field_at!</code></a> or <a href="library.html#Sunny.set_exchange_at!"><code>set_exchange_at!</code></a>.</p><p>Note that the definition of a cell may change when a system is reshaped. In this case, it is convenient to construct the <code>Site</code> using <a href="library.html#Sunny.position_to_site"><code>position_to_site</code></a>, which always takes a position in fractional coordinates of the original lattice vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/System.jl#L172-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.SpinWaveTheory" href="#Sunny.SpinWaveTheory"><code>Sunny.SpinWaveTheory</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpinWaveTheory(sys::System; measure, regularization=1e-8)</code></pre><p>Constructs an object to perform linear spin wave theory. The system must be in an energy minimizing configuration. Enables calculation of <a href="library.html#Sunny.dispersion"><code>dispersion</code></a> bands. If pair correlations are specified with <code>correspec</code>, one can also calculate <a href="library.html#Sunny.intensities_bands"><code>intensities_bands</code></a> and broadened <a href="library.html#Sunny.intensities"><code>intensities</code></a>.</p><p>The spins in system must be energy-minimized, otherwise the Cholesky step of the Bogoliubov diagonalization procedure will fail. The parameter <code>regularization</code> adds a small positive shift to the diagonal of the dynamical matrix to avoid numerical issues with quasi-particle modes of vanishing energy. Physically, this shift can be interpreted as application of an inhomogeneous field aligned with the magnetic ordering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/SpinWaveTheory/SpinWaveTheory.jl#L17-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.SpinWaveTheoryKPM" href="#Sunny.SpinWaveTheoryKPM"><code>Sunny.SpinWaveTheoryKPM</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpinWaveTheoryKPM(sys::System; measure, regularization=1e-8, tol)</code></pre><p>A variant of <a href="library.html#Sunny.SpinWaveTheory"><code>SpinWaveTheory</code></a> that uses the kernel polynomial method (KPM) to perform <a href="library.html#Sunny.intensities"><code>intensities</code></a> calculations [1]. Instead of explicitly diagonalizing the dynamical matrix, KPM approximates intensities using polynomial expansion truncated at order <span>$M$</span>. The reduces the computational cost from <span>$𝒪(N^3)$</span> to <span>$𝒪(N M)$</span>, which is favorable for large system sizes <span>$N$</span>.</p><p>The polynomial order <span>$M$</span> will be determined from the line broadening kernel and the specified error tolerance <code>tol</code>. Specifically, for each wavevector, <span>$M$</span> scales like the spectral bandwidth of excitations, divided by the energy resolution of the broadening kernel, times the negative logarithm of <code>tol</code>.</p><p>The error tolerance <code>tol</code> should be tuned empirically for each calculation. Reasonable starting points are <code>1e-1</code> (more speed) or <code>1e-2</code> (more accuracy).</p><div class="admonition is-warning"><header class="admonition-header">Missing intensity at small quasi-particle energy</header><div class="admonition-body"><p>The KPM-calculated intensities are unreliable at small energies <span>$ω$</span>. In particular, KPM may mask intensities that arise near the Goldstone modes of an ordered state with continuous symmetry.</p></div></div><p><strong>References</strong></p><ol><li><a href="https://arxiv.org/abs/2312.08349">H. Lane et al., <em>Kernel Polynomial Method for Linear Spin Wave Theory</em> (2023) [arXiv:2312.08349]</a>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/KPM/SpinWaveTheoryKPM.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.SpinWaveTheorySpiral" href="#Sunny.SpinWaveTheorySpiral"><code>Sunny.SpinWaveTheorySpiral</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpinWaveTheorySpiral(sys::System; k, axis, measure, regularization=1e-8)</code></pre><p>Analogous to <a href="library.html#Sunny.SpinWaveTheory"><code>SpinWaveTheory</code></a>, but interprets the provided system as having a generalized spiral order. This order is described by a single propagation wavevector <code>k</code>, which may be incommensurate. The <code>axis</code> vector defines the polarization plane via its surface normal. Typically the spin configuration in <code>sys</code> and the propagation wavevector <code>k</code> will be optimized using <a href="library.html#Sunny.minimize_spiral_energy!"><code>minimize_spiral_energy!</code></a>. In contrast, <code>axis</code> will typically be determined from symmetry considerations.</p><p>The resulting object can be used to calculate the spin wave <a href="library.html#Sunny.dispersion"><code>dispersion</code></a>, or the structure factor via <a href="library.html#Sunny.intensities_bands"><code>intensities_bands</code></a> and <a href="library.html#Sunny.intensities"><code>intensities</code></a>.</p><p>The algorithm for this calculation was developed in <a href="https://arxiv.org/abs/1402.6069">Toth and Lake, J. Phys.: Condens. Matter <strong>27</strong>, 166002 (2015)</a> and implemented in the <a href="https://spinw.org/">SpinW code</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Spiral/SpinWaveTheorySpiral.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.System" href="#Sunny.System"><code>Sunny.System</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">System(crystal::Crystal, moments, mode; dims=(1, 1, 1), seed=nothing)</code></pre><p>A spin system is constructed from the <a href="library.html#Sunny.Crystal"><code>Crystal</code></a> unit cell, a specification of the spin <code>moments</code> symmetry-distinct sites, and a calculation <code>mode</code>. Interactions can be added to the system using, e.g., <a href="library.html#Sunny.set_exchange!"><code>set_exchange!</code></a>. The default supercell dimensions are 1×1×1 chemical cells, but this can be changed with <code>dims</code>.</p><p>Spin <code>moments</code> comprise a list of pairs, <code>[i1 =&gt; Moment(...), i2 =&gt; ...]</code>, where <code>i1, i2, ...</code> are a complete set of symmetry-distinct atoms. Each <a href="library.html#Sunny.Moment"><code>Moment</code></a> contains spin and <span>$g$</span>-factor information.</p><p>The two primary options for <code>mode</code> are <code>:SUN</code> and <code>:dipole</code>. In the former, each spin-<span>$s$</span> degree of freedom is described as an SU(<em>N</em>) coherent state, i.e. a quantum superposition of <span>$N = 2s + 1$</span> levels. This formalism can be useful to capture multipolar spin fluctuations or local entanglement effects. </p><p>Mode <code>:dipole</code> projects the SU(<em>N</em>) dynamics onto the restricted space of pure dipoles. In practice this means that Sunny will simulate Landau-Lifshitz dynamics, but single-ion anisotropy and biquadratic exchange interactions will be renormalized to improve accuracy. To disable this renormalization, use the mode <code>:dipole_uncorrected</code>, which corresponds to the formal <span>$s → ∞$</span> limit. For details, see the documentation page: <a href="renormalization.html#Interaction-Renormalization">Interaction Renormalization</a>.</p><p>Stochastic operations on this system can be made reproducible by selecting a <code>seed</code> for this system&#39;s pseudo-random number generator. The default system seed will be generated from Julia&#39;s task-local RNG, which can itself be seeded using <code>Random.seed!</code>.</p><p>All spins are initially polarized in the global <span>$z$</span>-direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/System.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Units" href="#Sunny.Units"><code>Sunny.Units</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Units(energy, length)</code></pre><p>Physical constants in units of reference <code>energy</code> and <code>length</code> scales. Possible lengths are <code>[:angstrom, :nm]</code>. For atomic scale modeling, it is preferable to work in units of <code>length=:angstrom</code>, which follows the CIF file standard. Possible energy units are <code>[:meV, :K, :THz, :inverse_cm, :T]</code>. Kelvin is converted to energy via the Boltzmann constant <span>$k_B$</span>. Similarly, hertz is converted via the Planck constant <span>$h$</span>, inverse cm via the speed of light <span>$c$</span>, and tesla (field strength) via the Bohr magneton <span>$μ_B$</span>. For a given <code>Units</code> system, one can access any of the length and energy scale symbols listed above.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Unit system with [energy] = meV and [length] = Å
units = Units(:meV, :angstrom)

# Use the Boltzmann constant kB to convert 1 kelvin into meV
@assert units.K ≈ 0.0861733326

# Use the Planck constant h to convert 1 THz into meV
@assert units.THz ≈ 4.135667696

# Use the constant h c to convert 1 cm⁻¹ into meV
@assert units.inverse_cm ≈ 0.1239841984

# Use the Bohr magneton μB to convert 1 tesla into meV
@assert units.T ≈ 0.05788381806

# The physical constant μ0 μB² in units of Å³ meV.
@assert u.vacuum_permeability ≈ 0.6745817653</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Units.jl#L25-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.add_sample!" href="#Sunny.add_sample!"><code>Sunny.add_sample!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_sample!(sc::SampledCorrelations, sys::System)
add_sample!(sc::SampledCorrelationsStatic, sys::System)</code></pre><p>Measure pair correlation data for the spin configuration in <code>sys</code>, and accumulate these statistics into <code>sc</code>. For a dynamical <a href="library.html#Sunny.SampledCorrelations"><code>SampledCorrelations</code></a>, this involves time-integration of the provided spin trajectory, recording correlations in both space and time. Conversely, <a href="library.html#Sunny.SampledCorrelationsStatic"><code>SampledCorrelationsStatic</code></a>, will record only spatial correlations for the single spin configuration that is provided.</p><p>Time-integration will update the spin configuration of <code>sys</code> in-place. To avoid this mutation, consider calling <a href="library.html#Sunny.clone_system"><code>clone_system</code></a> prior to <code>add_sample!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/SampledCorrelations/CorrelationSampling.jl#L139-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.clone_correlations" href="#Sunny.clone_correlations"><code>Sunny.clone_correlations</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clone_correlations(sc::SampledCorrelations)</code></pre><p>Create a copy of a <code>SampledCorrelations</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/SampledCorrelations/SampledCorrelations.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.clone_system" href="#Sunny.clone_system"><code>Sunny.clone_system</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clone_system(sys::System)</code></pre><p>Creates a full clone of the system, such that mutable updates to one copy will not affect the other, and thread safety is guaranteed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/System.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.dispersion" href="#Sunny.dispersion"><code>Sunny.dispersion</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dispersion(swt::SpinWaveTheory, qpts)</code></pre><p>Given a list of wavevectors <code>qpts</code> in reciprocal lattice units (RLU), returns excitation energies for each band. The return value <code>ret</code> is 2D array, and should be indexed as <code>ret[band_index, q_index]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/SpinWaveTheory/DispersionAndIntensities.jl#L120-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.dmvec" href="#Sunny.dmvec"><code>Sunny.dmvec</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dmvec(D)</code></pre><p>Antisymmetric matrix representation of the Dzyaloshinskii-Moriya pseudo-vector,</p><pre><code class="nohighlight hljs">  [  0    D[3] -D[2]
   -D[3]   0    D[1]
    D[2] -D[1]   0  ]</code></pre><p>By construction, <code>Si&#39;*dmvec(D)*Sj ≈ D⋅(Si×Sj)</code> for any dipoles <code>Si</code> and <code>Sj</code>. This helper function is intended for use with <a href="library.html#Sunny.set_exchange!"><code>set_exchange!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/PairExchange.jl#L549-L562">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.domain_average" href="#Sunny.domain_average"><code>Sunny.domain_average</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">domain_average(f, cryst, qpts; rotations, weights)</code></pre><p>Calculate an average intensity for the reciprocal-space points <code>qpts</code> under a discrete set of <code>rotations</code>. Rotations, in global coordinates, may be given either as an axis-angle pair or as a 3×3 rotation matrix. Each rotation is weighted according to the elements in <code>weights</code>. The function <code>f</code> should accept a list of rotated q-points and return an <a href="library.html#Sunny.intensities"><code>intensities</code></a> calculation.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># 0, 120, and 240 degree rotations about the global z-axis
rotations = [([0,0,1], n*(2π/3)) for n in 0:2]
weights = [1, 1, 1]
res = domain_average(cryst, path; rotations, weights) do path_rotated
    intensities(swt, path_rotated; energies, kernel)
end
plot_intensities(res)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Measurements/RotationalAverages.jl#L157-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.eachsite" href="#Sunny.eachsite"><code>Sunny.eachsite</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachsite(sys::System)</code></pre><p>An iterator over all <a href="library.html#Sunny.Site"><code>Site</code></a>s in the system. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/System.jl#L226-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.enable_dipole_dipole!" href="#Sunny.enable_dipole_dipole!"><code>Sunny.enable_dipole_dipole!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">enable_dipole_dipole!(sys::System, μ0_μB²)</code></pre><p>Enables long-range interactions between magnetic dipole moments,</p><p class="math-container">\[    -(μ_0/4π) ∑_{⟨ij⟩}  [3 (μ_i⋅𝐫̂_{ij})(μ_j⋅𝐫̂_{ij}) - μ_i⋅μ_j] / r_{ij}^3,\]</p><p>where the sum is over all pairs of sites (singly counted), including periodic images, regularized using the Ewald summation convention. Each magnetic moment is <span>$μ = -g μ_B 𝐒$</span>, where <span>$𝐒$</span> is the spin angular momentum dipole. The parameter <code>μ0_μB²</code> specifies the physical constant <span>$μ_0 μ_B^2$</span>, which has dimensions of length³-energy. Obtain this constant for a given system of <a href="library.html#Sunny.Units"><code>Units</code></a> via its <code>vacuum_permeability</code> property.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">units = Units(:meV, :angstrom)
enable_dipole_dipole!(sys, units.vacuum_permeability)</code></pre><div class="admonition is-success"><header class="admonition-header">Efficiency considerations</header><div class="admonition-body"><p>Dipole-dipole interactions are very efficient in the context of spin dynamics simulation, e.g. <a href="library.html#Sunny.Langevin"><code>Langevin</code></a>. Sunny applies the fast Fourier transform (FFT) to spins on each Bravais sublattice, such that the computational cost to integrate one time-step scales like <span>$M^2 N \ln N$</span>, where <span>$N$</span> is the number of cells in the system and <span>$M$</span> is the number of Bravais sublattices per cell. Conversely, dipole-dipole interactions are highly <em>inefficient</em> in the context of a <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>. Each Monte Carlo update of a single spin currently requires scanning over all other spins in the system.</p></div></div><p>See also <a href="library.html#Sunny.modify_exchange_with_truncated_dipole_dipole!"><code>modify_exchange_with_truncated_dipole_dipole!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/Interactions.jl#L66-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.energy" href="#Sunny.energy"><code>Sunny.energy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">energy(sys::System)</code></pre><p>The total system energy. See also <a href="library.html#Sunny.energy_per_site"><code>energy_per_site</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/Interactions.jl#L250-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.energy_per_site" href="#Sunny.energy_per_site"><code>Sunny.energy_per_site</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">energy_per_site(sys::System)</code></pre><p>The total system <a href="library.html#Sunny.energy"><code>energy</code></a> divided by the number of sites.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/Interactions.jl#L241-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.excitations" href="#Sunny.excitations"><code>Sunny.excitations</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">excitations(swt::SpinWaveTheory, q)
excitations(swt::SpinWaveTheorySpiral, q; branch)</code></pre><p>Returns a pair <code>(energies, T)</code> providing the excitation energies and eigenvectors. Prefer <a href="library.html#Sunny.excitations!"><code>excitations!</code></a> for performance, which avoids matrix allocations. See the documentation of <a href="library.html#Sunny.excitations!"><code>excitations!</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/SpinWaveTheory/DispersionAndIntensities.jl#L104-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.excitations!" href="#Sunny.excitations!"><code>Sunny.excitations!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">excitations!(T, tmp, swt::SpinWaveTheory, q)</code></pre><p>Given a wavevector <code>q</code>, solves for the matrix <code>T</code> representing quasi-particle excitations, and returns a list of quasi-particle energies. Both <code>T</code> and <code>tmp</code> must be supplied as <span>$2L×2L$</span> complex matrices, where <span>$L$</span> is the number of bands for a single <span>$𝐪$</span> value.</p><p>The columns of <code>T</code> are understood to be contracted with the Holstein-Primakoff bosons <span>$[𝐛_𝐪, 𝐛_{-𝐪}^†]$</span>. The first <span>$L$</span> columns provide the eigenvectors of the quadratic Hamiltonian for the wavevector <span>$𝐪$</span>. The next <span>$L$</span> columns of <code>T</code> describe eigenvectors for <span>$-𝐪$</span>. The return value is a vector with similar grouping: the first <span>$L$</span> values are energies for <span>$𝐪$</span>, and the next <span>$L$</span> values are the <em>negation</em> of energies for <span>$-𝐪$</span>.</p><pre><code class="nohighlight hljs">excitations!(T, tmp, swt::SpinWaveTheorySpiral, q; branch)</code></pre><p>Calculations on a <a href="library.html#Sunny.SpinWaveTheorySpiral"><code>SpinWaveTheorySpiral</code></a> additionally require a <code>branch</code> index. The possible branches <span>$(1, 2, 3)$</span> correspond to scattering processes <span>$𝐪 - 𝐤, 𝐪, 𝐪 + 𝐤$</span> respectively, where <span>$𝐤$</span> is the ordering wavevector. Each branch will contribute <span>$L$</span> excitations, where <span>$L$</span> is the number of spins in the magnetic cell. This yields a total of <span>$3L$</span> excitations for a given momentum transfer <span>$𝐪$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/SpinWaveTheory/DispersionAndIntensities.jl#L66-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.gaussian" href="#Sunny.gaussian"><code>Sunny.gaussian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gaussian(; {fwhm, σ})</code></pre><p>Returns the function <code>exp(-x^2/2σ^2) / √(2π*σ^2)</code>. Either <code>fwhm</code> or <code>σ</code> must be specified, where <code>fwhm = (2.355...) * σ</code> is the full width at half maximum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Measurements/Broadening.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.global_position" href="#Sunny.global_position"><code>Sunny.global_position</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">global_position(sys::System, site::Site)</code></pre><p>Position of a <a href="library.html#Sunny.Site"><code>Site</code></a> in global coordinates.</p><p>To precompute a full list of positions, one can use <a href="library.html#Sunny.eachsite"><code>eachsite</code></a> as below:</p><pre><code class="language-julia hljs">pos = [global_position(sys, site) for site in eachsite(sys)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/System.jl#L242-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensities" href="#Sunny.intensities"><code>Sunny.intensities</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intensities(swt::SpinWaveTheory, qpts; energies, kernel, kT=0)
intensities(sc::SampledCorrelations, qpts; energies, kernel=nothing, kT)</code></pre><p>Calculates dynamical pair correlation intensities for a set of <span>$𝐪$</span>-points in reciprocal space.</p><p>Linear spin wave theory calculations are performed with an instance of <a href="library.html#Sunny.SpinWaveTheory"><code>SpinWaveTheory</code></a>. The alternative <a href="library.html#Sunny.SpinWaveTheorySpiral"><code>SpinWaveTheorySpiral</code></a> allows to study generalized spiral orders with a single, incommensurate-<span>$𝐤$</span> ordering wavevector. Another alternative <a href="library.html#Sunny.SpinWaveTheoryKPM"><code>SpinWaveTheoryKPM</code></a> is favorable for calculations on large magnetic cells, and allows to study systems with disorder. An optional nonzero temperature <code>kT</code> will scale intensities by the quantum thermal occupation factor <span>$|1 + n_B(ω)|$</span> where <span>$n_B(ω) = 1/(e^{βω}-1)$</span> is the Bose function.</p><p>Intensities can also be calculated for <code>SampledCorrelations</code> associated with classical spin dynamics. In this case, thermal broadening will already be present, and the line-broadening <code>kernel</code> becomes optional. Conversely, the parameter <code>kT</code> becomes required. If positive, it will introduce an intensity correction factor <span>$|βω (1 + n_B(ω))|$</span> that undoes the occupation factor for the classical Boltzmann distribution and applies the quantum thermal occupation factor. The special choice <code>kT = nothing</code> will suppress the classical-to-quantum correction factor, and yield statistics consistent with the classical Boltzmann distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/SpinWaveTheory/DispersionAndIntensities.jl#L243-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensities_bands" href="#Sunny.intensities_bands"><code>Sunny.intensities_bands</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intensities_bands(swt::SpinWaveTheory, qpts; kT=0)</code></pre><p>Calculate spin wave excitation bands for a set of q-points in reciprocal space. This calculation is analogous to <a href="library.html#Sunny.intensities"><code>intensities</code></a>, but does not perform line broadening of the bands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/SpinWaveTheory/DispersionAndIntensities.jl#L137-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensities_static" href="#Sunny.intensities_static"><code>Sunny.intensities_static</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intensities_static(swt::SpinWaveTheory, qpts; bounds=(-Inf, Inf), kernel=nothing, kT=0)
intensities_static(sc::SampledCorrelations, qpts; bounds=(-Inf, Inf), kT)
intensities_static(sc::SampledCorrelationsStatic, qpts)</code></pre><p>Like <a href="library.html#Sunny.intensities"><code>intensities</code></a>, but integrates the dynamical correlations <span>$\mathcal{S}(𝐪, ω)$</span> over a range of energies <span>$ω$</span>. By default, the integration <code>bounds</code> are <span>$(-∞, ∞)$</span>, yielding the instantaneous (equal-time) correlations.</p><p>In <a href="library.html#Sunny.SpinWaveTheory"><code>SpinWaveTheory</code></a>, the integral will be realized as a sum over discrete bands. Alternative calculation methods are <a href="library.html#Sunny.SpinWaveTheorySpiral"><code>SpinWaveTheorySpiral</code></a> and <a href="library.html#Sunny.SpinWaveTheoryKPM"><code>SpinWaveTheoryKPM</code></a>.</p><p>Classical dynamics data in <a href="library.html#Sunny.SampledCorrelations"><code>SampledCorrelations</code></a> can also be used to calculate static intensities. In this case, the domain of integration will be a finite grid of available <code>energies</code>. Here, the parameter <code>kT</code> will be used to account for the quantum thermal occupation of excitations, as documented in <a href="library.html#Sunny.intensities"><code>intensities</code></a>.</p><p>Static intensities calculated from <a href="library.html#Sunny.SampledCorrelationsStatic"><code>SampledCorrelationsStatic</code></a> are dynamics-independent. Instead, instantaneous correlations sampled from the classical Boltzmann distribution will be reported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/SpinWaveTheory/DispersionAndIntensities.jl#L273-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.lattice_params" href="#Sunny.lattice_params"><code>Sunny.lattice_params</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lattice_params(latvecs)</code></pre><p>Compute the lattice parameters <span>$(a, b, c, α, β, γ)$</span> for the three lattice vectors provided as columns of <code>latvecs</code>. The inverse mapping is <a href="library.html#Sunny.lattice_vectors"><code>lattice_vectors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Symmetry/LatticeUtils.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.lattice_vectors" href="#Sunny.lattice_vectors"><code>Sunny.lattice_vectors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lattice_vectors(a, b, c, α, β, γ)</code></pre><p>Return the lattice vectors, as columns of the <span>$3×3$</span> output matrix, that define the shape of a crystallographic cell in global Cartesian coordinates. Conversely, one can view the output matrix as defining the global Cartesian coordinate system with respect to the lattice system.</p><p>The lattice constants <span>$(a, b, c)$</span> have units of length, and the angles <span>$(α, β, γ)$</span> are in degrees. The inverse mapping is <a href="library.html#Sunny.lattice_params"><code>lattice_params</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">latvecs = lattice_vectors(1, 1, 2, 90, 90, 120)
a1, a2, a3 = eachcol(latvecs)
@assert a1 ≈ [1, 0, 0]       # a1 always aligned with global x
@assert a2 ≈ [-1/2, √3/2, 0] # a2 always in global (x,y) plane
@assert a3 ≈ [0, 0, 2]       # a3 may generally be a combination of (x,y,z)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Symmetry/LatticeUtils.jl#L20-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.load_nxs" href="#Sunny.load_nxs"><code>Sunny.load_nxs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">params, signal = load_nxs(filename; field=&quot;signal&quot;)</code></pre><p>Given the name of a Mantid-exported <code>MDHistoWorkspace</code> file, load the <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> and the signal from that file.</p><p>To load another field instead of the signal, specify e.g. <code>field=&quot;errors_squared&quot;</code>. Typical fields include <code>errors_squared</code>, <code>mask</code>, <code>num_events</code>, and <code>signal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Binning/ExperimentData.jl#L40-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.lorentzian" href="#Sunny.lorentzian"><code>Sunny.lorentzian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lorentzian(; fwhm)</code></pre><p>Returns the function <code>(Γ/2) / (π*(x^2+(Γ/2)^2))</code> where <code>Γ = fwhm</code> is the full width at half maximum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Measurements/Broadening.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.magnetic_moment" href="#Sunny.magnetic_moment"><code>Sunny.magnetic_moment</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">magnetic_moment(sys::System, site::Site)</code></pre><p>Returns <span>$- g 𝐒$</span>, the local magnetic moment in units of the Bohr magneton. The spin dipole <span>$𝐒$</span> and <span>$g$</span>-tensor may both be <a href="library.html#Sunny.Site"><code>Site</code></a> dependent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/System.jl#L259-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.merge_correlations" href="#Sunny.merge_correlations"><code>Sunny.merge_correlations</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge_correlations(scs::Vector{SampledCorrelations)</code></pre><p>Accumulate a list of <code>SampledCorrelations</code> into a single, summary <code>SampledCorrelations</code>. Useful for reducing the results of parallel computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/SampledCorrelations/SampledCorrelations.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.minimize_energy!" href="#Sunny.minimize_energy!"><code>Sunny.minimize_energy!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimize_energy!(sys::System{N}; maxiters=1000, method=Optim.ConjugateGradient(),
                 kwargs...) where N</code></pre><p>Optimizes the spin configuration in <code>sys</code> to minimize energy. A total of <code>maxiters</code> iterations will be attempted. The <code>method</code> parameter will be used in the <code>optimize</code> function of the <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl package</a>. Any remaining <code>kwargs</code> will be included in the <code>Options</code> constructor of Optim.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Optimization.jl#L94-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.minimize_spiral_energy!" href="#Sunny.minimize_spiral_energy!"><code>Sunny.minimize_spiral_energy!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimize_spiral_energy!(sys, axis; maxiters=10_000, k_guess=randn(sys.rng, 3))</code></pre><p>Finds a generalized spiral order that minimizes the <a href="library.html#Sunny.spiral_energy"><code>spiral_energy</code></a>. This involves optimization of the spin configuration in <code>sys</code>, and the propagation wavevector <span>$𝐤$</span>, which will be returned in reciprocal lattice units (RLU). The <code>axis</code> vector normal to the polarization plane cannot yet be optimized; it should be determined according to symmetry considerations and provided in global Cartesian coordinates. The initial <code>k_guess</code> will be random, unless otherwise provided.</p><p>See also <a href="library.html#Sunny.suggest_magnetic_supercell"><code>suggest_magnetic_supercell</code></a> to find a system shape that is approximately commensurate with the returned propagation wavevector <span>$𝐤$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Spiral/SpiralEnergy.jl#L184-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.modify_exchange_with_truncated_dipole_dipole!" href="#Sunny.modify_exchange_with_truncated_dipole_dipole!"><code>Sunny.modify_exchange_with_truncated_dipole_dipole!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modify_exchange_with_truncated_dipole_dipole!(sys::System, cutoff, μ0_μB²)</code></pre><p>Like <a href="library.html#Sunny.enable_dipole_dipole!"><code>enable_dipole_dipole!</code></a>, the purpose of this function is to introduce long-range dipole-dipole interactions between magnetic moments. Whereas <code>enable_dipole_dipole!</code> employs Ewald summation, this function instead employs real-space pair couplings with truncation at the specified <code>cutoff</code> distance. If the cutoff is relatively small, then this function may be faster than <code>enable_dipole_dipole!</code>.</p><div class="admonition is-warning"><header class="admonition-header">Mutation of existing couplings</header><div class="admonition-body"><p>This function will modify existing bilinear couplings between spins by adding dipole-dipole interactions. It must therefore be called <em>after</em> all other pair couplings have been specified. Conversely, any calls to <code>set_exchange!</code>, <code>set_pair_coupling!</code>, etc. will irreversibly delete the dipole-dipole interactions that have been introduced by this function.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/Ewald.jl#L244-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.polarize_spins!" href="#Sunny.polarize_spins!"><code>Sunny.polarize_spins!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polarize_spins!(sys::System, dir)</code></pre><p>Polarize all spins in the system along the direction <code>dir</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/System.jl#L544-L548">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.position_to_site" href="#Sunny.position_to_site"><code>Sunny.position_to_site</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">position_to_site(sys::System, r)</code></pre><p>Converts a position <code>r</code> to four indices of a <a href="library.html#Sunny.Site"><code>Site</code></a>. The coordinates of <code>r</code> are given in units of the lattice vectors for the original crystal. This function can be useful for working with systems that have been reshaped using <a href="library.html#Sunny.reshape_supercell"><code>reshape_supercell</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Find the `site` at the center of a unit cell which is displaced by four
# multiples of the first lattice vector
site = position_to_site(sys, [4.5, 0.5, 0.5])

# Print the dipole at this site
println(sys.dipoles[site])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/System.jl#L286-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.powder_average" href="#Sunny.powder_average"><code>Sunny.powder_average</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">powder_average(f, cryst, radii, n; seed=0)</code></pre><p>Calculate a powder-average over structure factor intensities. The <code>radii</code>, with units of inverse length, define spherical shells in reciprocal space. The <a href="https://arxiv.org/abs/1607.04590">Fibonacci lattice</a> yields <code>n</code> points on the sphere, with quasi-uniformity. Sample points on different shells are decorrelated through random rotations. A consistent random number <code>seed</code> will yield reproducible results. The function <code>f</code> should accept a list of q-points and call <a href="library.html#Sunny.intensities"><code>intensities</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">radii = range(0.0, 3.0, 200)
res = powder_average(cryst, radii, 500) do qs
    intensities(swt, qs; energies, kernel)
end
plot_intensities(res)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Measurements/RotationalAverages.jl#L103-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.primitive_cell" href="#Sunny.primitive_cell"><code>Sunny.primitive_cell</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">primitive_cell(cryst)</code></pre><p>The shape of a primitive cell in multiples of the lattice vectors for <code>cryst</code>. Specifically, columns of <code>cryst.latvecs * primitive(cryst)</code> define the primitive lattice vectors in global Cartesian coordinates. Returns <code>nothing</code> if spacegroup setting information is missing.</p><p>This function may be useful for constructing inputs to <a href="library.html#Sunny.reshape_supercell"><code>reshape_supercell</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Symmetry/Crystal.jl#L428-L438">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_bond" href="#Sunny.print_bond"><code>Sunny.print_bond</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">print_bond(cryst::Crystal, bond::Bond; b_ref::Bond)</code></pre><p>Prints symmetry information for bond <code>bond</code>. A symmetry-equivalent reference bond <code>b_ref</code> can optionally be provided to fix the meaning of the coefficients <code>A</code>, <code>B</code>, ...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Symmetry/Printing.jl#L114-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_irreducible_bz_paths" href="#Sunny.print_irreducible_bz_paths"><code>Sunny.print_irreducible_bz_paths</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">print_irreducible_bz_paths(cryst::Crystal)</code></pre><p>Prints certain high-symmetry points with suggested paths between them. The points lie in the irreducible Brillouin, which is reduced from the first Brillouin zone by the point group symmetries of the crystal. Coordinates are printed in reciprocal lattice units (RLU), i.e., as multiples of the conventional lattice vectors of <code>cryst</code>. These high-symmetry paths were originally formulated in Ref. [1] and implemented in <a href="https://github.com/giovannipizzi/seekpath">SeeK-path</a>. Sunny obtains this functionality from the <a href="https://github.com/thchr/Brillouin.jl">Brillouin.jl</a> package.</p><p>See also <a href="library.html#Sunny.view_bz"><code>view_bz</code></a> for an interactive visualization of these high-symmetry paths.</p><p><strong>References</strong></p><ol><li><a href="https://doi.org/10.1016/j.commatsci.2016.10.015">Y. Hinuma, G. Pizzi, Y. Kumagai, F. Oba, I. Tanaka, <em>Band structure diagram paths based on crystallography</em>, Comp. Mat. Sci. <strong>128</strong>, 140 (2017)</a>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Symmetry/BZPaths.jl#L24-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_site" href="#Sunny.print_site"><code>Sunny.print_site</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">print_site(cryst, i; R=I)</code></pre><p>Print symmetry information for the site <code>i</code>, including allowed g-tensor and allowed anisotropy operator. An optional rotation matrix <code>R</code> can be provided to define the reference frame for expression of the anisotropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Symmetry/Printing.jl#L208-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_stevens_expansion" href="#Sunny.print_stevens_expansion"><code>Sunny.print_stevens_expansion</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function print_stevens_expansion(op)</code></pre><p>Prints a local Hermitian operator as a linear combination of Stevens operators. The operator <code>op</code> may be a finite-dimensional matrix or an abstract spin polynomial in the large-<span>$s$</span> limit.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">S = spin_matrices(2)
print_stevens_expansion(S[1]^4 + S[2]^4 + S[3]^4)
# Prints: (1/20)𝒪₄₀ + (1/4)𝒪₄₄ + 102/5

S = spin_matrices(Inf)
print_stevens_expansion(S[1]^4 + S[2]^4 + S[3]^4)
# Prints: (1/20)𝒪₄₀ + (1/4)𝒪₄₄ + (3/5)𝒮⁴</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Operators/Stevens.jl#L177-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_suggested_frame" href="#Sunny.print_suggested_frame"><code>Sunny.print_suggested_frame</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">print_suggested_frame(cryst, i)</code></pre><p>Print a suggested reference frame, as a rotation matrix <code>R</code>, that can be used as input to <code>print_site()</code>. The purpose is to simplify the description of allowed anisotropies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Symmetry/Printing.jl#L192-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_symmetry_table" href="#Sunny.print_symmetry_table"><code>Sunny.print_symmetry_table</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">print_symmetry_table(cryst::Crystal, max_dist)</code></pre><p>Print symmetry information for all equivalence classes of sites and bonds, up to a maximum bond distance of <code>max_dist</code>. Equivalent to calling <code>print_bond(cryst, b)</code> for every bond <code>b</code> in <code>reference_bonds(cryst, max_dist)</code>, where <code>Bond(i, i, [0,0,0])</code> refers to a single site <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Symmetry/Printing.jl#L176-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_wrapped_intensities" href="#Sunny.print_wrapped_intensities"><code>Sunny.print_wrapped_intensities</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">print_wrapped_intensities(sys::System; nmax=10)</code></pre><p>For Bravais lattices: Prints up to <code>nmax</code> wavevectors according to their instantaneous (static) structure factor intensities, listed in descending order. For non-Bravais lattices: Performs the same analysis for each spin sublattice independently; the output weights are naïvely averaged over sublattices, without incorporating phase shift information. This procedure therefore wraps all wavevectors into the first Brillouin zone. Each wavevector coordinate is given between <span>$-1/2$</span> and <span>$1/2$</span> in reciprocal lattice units (RLU).  The output from this function will typically be used as input to <a href="library.html#Sunny.suggest_magnetic_supercell"><code>suggest_magnetic_supercell</code></a>.</p><p>Because this function does not incorporate phase information in its averaging over sublattices, the printed weights are not directly comparable with experiment. For that purpose, use <a href="library.html#Sunny.SampledCorrelationsStatic"><code>SampledCorrelationsStatic</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/MagneticOrdering.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.propose_delta" href="#Sunny.propose_delta"><code>Sunny.propose_delta</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">propose_delta(magnitude)</code></pre><p>Generate a proposal function that adds a Gaussian perturbation to the existing spin state. In <code>:dipole</code> mode, the procedure is to first introduce a random three-vector perturbation <span>$𝐒′ = 𝐒 + |𝐒| ξ$</span> and then return the properly normalized spin <span>$|𝐒| (𝐒′/|𝐒′|)$</span>. Each component of the random vector <span>$ξ$</span> is Gaussian distributed with a standard deviation of <code>magnitude</code>; the latter is dimensionless and typically smaller than one. </p><p>In <code>:SUN</code> mode, the procedure is analogous, but now involving Gaussian perturbations to each of the <span>$N$</span> complex components of an SU(<em>N</em>) coherent state.</p><p>In the limit of very large <code>magnitude</code>, this function coincides with <a href="library.html#Sunny.propose_uniform"><code>propose_uniform</code></a>.</p><p>Consider also <a href="library.html#Sunny.Langevin"><code>Langevin</code></a> sampling, which is rejection free.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/MonteCarlo/Samplers.jl#L25-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.propose_flip" href="#Sunny.propose_flip"><code>Sunny.propose_flip</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">propose_flip</code></pre><p>Function to propose pure spin flip updates in the context of a <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>. Dipoles are flipped as <span>$𝐒 → -𝐒$</span>. SU(<em>N</em>) coherent states are flipped using the time-reversal operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/MonteCarlo/Samplers.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.propose_uniform" href="#Sunny.propose_uniform"><code>Sunny.propose_uniform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">propose_uniform</code></pre><p>Function to propose a uniformly random spin update in the context of a <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>. In <code>:dipole</code> mode, the result is a random three-vector with appropriate normalization. In <code>:SUN</code> mode, the result is a random SU(<em>N</em>) coherent state with appropriate normalization.</p><p>For low-temperature Monte Carlo simulations, uniform spin proposals can be very inefficient due to a high probability of rejection in the Metropolis accept/reject step. Consider also <a href="library.html#Sunny.Langevin"><code>Langevin</code></a> sampling, which is rejection free.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/MonteCarlo/Samplers.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.q_space_grid" href="#Sunny.q_space_grid"><code>Sunny.q_space_grid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">q_space_grid(cryst::Crystal, axis1, range1, axis2, range2; offset=[0,0,0], orthogonalize=false)
q_space_grid(cryst::Crystal, axis1, range1, axis2, range2, axis3, range3; orthogonalize=false)</code></pre><p>Returns a 2D or 3D grid of q-points with uniform spacing. The volume shape is defined by <code>(axis1, axis2, ...)</code> in reciprocal lattice units (RLU). Elements of <code>(range1, range2, ...)</code> provide coefficients <span>$c_i$</span> used to define grid positions,</p><pre><code class="language-julia hljs">    offset + c1 * axis1 + c2 * axis2 + ...</code></pre><p>A nonzero <code>offset</code> is allowed only in the 2D case. </p><p>The first range parameter, <code>range1</code>, must be a regularly spaced list of coefficients, e.g., <code>range1 = range(lo1, hi1, n)</code>. Subsequent range parameters may be a pair of bounds, without grid spacing information. For example, by selecting <code>range2 = (lo2, hi2)</code>, an appropriate step-size will be inferred to provide an approximately uniform sampling density in global Cartesian coordinates.</p><p>The axes may be non-orthogonal. To extend to an orthohombic volume in global Cartesian coordinates, set <code>orthogonalize=true</code>.</p><p>For a 1D grid, use <a href="library.html#Sunny.q_space_path"><code>q_space_path</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Measurements/QPoints.jl#L104-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.q_space_path" href="#Sunny.q_space_path"><code>Sunny.q_space_path</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">q_space_path(cryst::Crystal, qs, n; labels=nothing)</code></pre><p>Returns a 1D path consisting of <code>n</code> wavevectors sampled piecewise-linearly between the points in <code>qs</code>. Although the <code>qs</code> are provided in reciprocal lattice units (RLU), consecutive samples are spaced uniformly in the global (inverse-length) Cartesian coordinate system. Optional <code>labels</code> can be associated with each special q-point, and will be used in plotting functions.</p><p>See also <a href="library.html#Sunny.q_space_grid"><code>q_space_grid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Measurements/QPoints.jl#L49-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.randomize_spins!" href="#Sunny.randomize_spins!"><code>Sunny.randomize_spins!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">randomize_spins!(sys::System)</code></pre><p>Randomizes all spins under appropriate the uniform distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/System.jl#L502-L506">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.reference_bonds" href="#Sunny.reference_bonds"><code>Sunny.reference_bonds</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reference_bonds(cryst::Crystal, max_dist)</code></pre><p>Returns a full list of bonds, one for each symmetry equivalence class, up to distance <code>max_dist</code>. The reference bond <code>b</code> for each equivalence class is selected according to a scoring system that prioritizes simplification of the elements in <code>basis_for_symmetry_allowed_couplings(cryst, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Symmetry/SymmetryAnalysis.jl#L191-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.remove_periodicity!" href="#Sunny.remove_periodicity!"><code>Sunny.remove_periodicity!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_periodicity!(sys::System, flags)</code></pre><p>Remove periodic interactions along each dimension <code>d</code> if <code>flags[d]</code> is <code>true</code>. The system must support inhomogeneous interactions via <a href="library.html#Sunny.to_inhomogeneous"><code>to_inhomogeneous</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Remove periodic boundaries along the 1st and 3rd dimensions
remove_periodicity!(sys::System, (true, false, true))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/PairExchange.jl#L519-L532">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.repeat_periodically" href="#Sunny.repeat_periodically"><code>Sunny.repeat_periodically</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">repeat_periodically(sys::System, counts::NTuple{3, Int})</code></pre><p>Creates a <a href="library.html#Sunny.System"><code>System</code></a> identical to <code>sys</code> but repeated a given number of times along each system axis according to the specified <code>counts</code>. This is a special case of the more general <a href="library.html#Sunny.reshape_supercell"><code>reshape_supercell</code></a>.</p><p>See also <a href="library.html#Sunny.repeat_periodically_as_spiral"><code>repeat_periodically_as_spiral</code></a>, which rotates the spins between periodic copies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Reshaping.jl#L140-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.repeat_periodically_as_spiral" href="#Sunny.repeat_periodically_as_spiral"><code>Sunny.repeat_periodically_as_spiral</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">repeat_periodically_as_spiral(sys::System, counts::NTuple{3, Int}; k, axis)</code></pre><p>Repeats the magnetic cell of <a href="library.html#Sunny.System"><code>System</code></a> a number of times along each system axis according to the specified <code>counts</code>. Spins in each system image will be rotated according to the propagation wavevector <code>k</code> (in RLU) and the rotation <code>axis</code> (in global Cartesian coordinates). Coincides with <a href="library.html#Sunny.repeat_periodically"><code>repeat_periodically</code></a> in the special case of <code>k = [0, 0, 0]</code></p><p>See also <a href="library.html#Sunny.minimize_spiral_energy!"><code>minimize_spiral_energy!</code></a> to find an energy-minimizing wavevector <code>k</code> and spin dipole configuration.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">k = minimize_spiral_energy!(sys, axis; k_guess=randn(3))
repeat_periodically_as_spiral(sys, counts; k, axis)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Reshaping.jl#L155-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.reshape_supercell" href="#Sunny.reshape_supercell"><code>Sunny.reshape_supercell</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reshape_supercell(sys::System, shape)</code></pre><p>Maps an existing <a href="library.html#Sunny.System"><code>System</code></a> to a new one that has the shape and periodicity of a requested supercell. The columns of the <span>$3×3$</span> integer matrix <code>shape</code> represent the supercell lattice vectors measured in units of the original crystal lattice vectors. Interactions, spins, and other settings will be inherited from <code>sys</code>.</p><p>In the special case that <code>shape</code> is a diagonal matrix, this function coincides with <a href="library.html#Sunny.resize_supercell"><code>resize_supercell</code></a>.</p><p>See also <a href="library.html#Sunny.repeat_periodically"><code>repeat_periodically</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Reshaping.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.resize_supercell" href="#Sunny.resize_supercell"><code>Sunny.resize_supercell</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resize_supercell(sys::System, dims::NTuple{3, Int})</code></pre><p>Creates a <a href="library.html#Sunny.System"><code>System</code></a> with a given number of conventional unit cells in each lattice vector direction. Interactions, spins, and other settings will be inherited from <code>sys</code>.</p><p>Equivalent to:</p><pre><code class="language-julia hljs">reshape_supercell(sys, [dims[1] 0 0; 0 dims[2] 0; 0 0 dims[3]])</code></pre><p>See also <a href="library.html#Sunny.reshape_supercell"><code>reshape_supercell</code></a> and <a href="library.html#Sunny.repeat_periodically"><code>repeat_periodically</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Reshaping.jl#L121-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.rotate_operator" href="#Sunny.rotate_operator"><code>Sunny.rotate_operator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate_operator(A, R)</code></pre><p>Rotates the local quantum operator <code>A</code> according to the <span>$3×3$</span> rotation matrix <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Operators/Rotation.jl#L140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_coherent!" href="#Sunny.set_coherent!"><code>Sunny.set_coherent!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_coherent!(sys::System, Z, site::Site)</code></pre><p>Set a coherent spin state at a <a href="library.html#Sunny.Site"><code>Site</code></a> using the <span>$N$</span> complex amplitudes in <code>Z</code>.</p><p>For a single quantum spin-<span>$s$</span>, these amplitudes will be interpreted in the eigenbasis of <span>$Ŝ^z$</span>. That is, <code>Z[1]</code> represents the amplitude for the basis state fully polarized along the <span>$ẑ$</span>-direction, and subsequent components represent states with decreasing angular momentum along this axis (<span>$m = s, s-1, …, -s$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/System.jl#L514-L525">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_dipole!" href="#Sunny.set_dipole!"><code>Sunny.set_dipole!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_dipole!(sys::System, dir, site::Site)</code></pre><p>Polarize the spin at a <a href="library.html#Sunny.Site"><code>Site</code></a> along the direction <code>dir</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/System.jl#L534-L538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_dipoles_from_mcif!" href="#Sunny.set_dipoles_from_mcif!"><code>Sunny.set_dipoles_from_mcif!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_dipoles_from_mcif!(sys::System, filename::AbstractString)</code></pre><p>Load the magnetic supercell according to an mCIF file. System <code>sys</code> must already be resized to the correct supercell dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/MCIF.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_exchange!" href="#Sunny.set_exchange!"><code>Sunny.set_exchange!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_exchange!(sys::System, J, bond::Bond; biquad=0)</code></pre><p>Sets an exchange interaction <span>$𝐒_i⋅J 𝐒_j$</span> along the specified <code>bond</code>. This interaction will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous interactions on these bonds will be overwritten. The parameter <code>bond</code> has the form <code>Bond(i, j, offset)</code>, where <code>i</code> and <code>j</code> are atom indices within the unit cell, and <code>offset</code> is a displacement in unit cells.</p><p>As a convenience, scalar <code>J</code> can be used to specify a Heisenberg interaction. Also, the function <a href="library.html#Sunny.dmvec"><code>dmvec(D)</code></a> can be used to construct the antisymmetric part of the exchange, where <code>D</code> is the Dzyaloshinskii-Moriya pseudo-vector. The resulting interaction will be <span>$𝐃⋅(𝐒_i×𝐒_j)$</span>.</p><p>The optional numeric parameter <code>biquad</code> multiplies a scalar biquadratic interaction, <span>$(𝐒_i⋅𝐒_j)^2$</span>, with <a href="renormalization.html#Interaction-Renormalization">Interaction Renormalization</a> if appropriate. For more general interactions, use <a href="library.html#Sunny.set_pair_coupling!"><code>set_pair_coupling!</code></a> instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra

# Set a Heisenberg and DM interaction: 2Si⋅Sj + D⋅(Si×Sj)
D = [0, 0, 3]
set_exchange!(sys, 2I + dmvec(D), bond)

# The same interaction as an explicit exchange matrix
J = [2 3 0;
    -3 2 0;
     0 0 2]
set_exchange!(sys, J, bond)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/PairExchange.jl#L345-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_exchange_at!" href="#Sunny.set_exchange_at!"><code>Sunny.set_exchange_at!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_exchange_at!(sys::System, J, site1::Site, site2::Site; biquad=0, offset=nothing)</code></pre><p>Sets an exchange interaction `<code>𝐒_i⋅J 𝐒_j</code> along the single bond connecting two <a href="library.html#Sunny.Site"><code>Site</code></a>s, ignoring crystal symmetry. Any previous coupling on this bond will be overwritten. The system must support inhomogeneous interactions via <a href="library.html#Sunny.to_inhomogeneous"><code>to_inhomogeneous</code></a>.</p><p>Use <a href="library.html#Sunny.symmetry_equivalent_bonds"><code>symmetry_equivalent_bonds</code></a> to find <code>(site1, site2, offset)</code> values that would be symmetry equivalent to a given <a href="library.html#Sunny.Bond"><code>Bond</code></a> in a homogeneous system. For smaller systems, the <code>offset</code> vector (in multiples of unit cells) will resolve ambiguities in the periodic wrapping.</p><p>See also <a href="library.html#Sunny.set_exchange!"><code>set_exchange!</code></a> for more details on specifying <code>J</code> and <code>biquad</code>. For more general couplings, use <a href="library.html#Sunny.set_pair_coupling_at!"><code>set_pair_coupling_at!</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/PairExchange.jl#L452-L468">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_field!" href="#Sunny.set_field!"><code>Sunny.set_field!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_field!(sys::System, B_μB)</code></pre><p>Sets the external magnetic field <span>$𝐁$</span> scaled by the Bohr magneton <span>$μ_B$</span>. This scaled field has units of energy and couples directly to the dimensionless <a href="library.html#Sunny.magnetic_moment"><code>magnetic_moment</code></a>. At every site, the Zeeman coupling contributes an energy <span>$+ (𝐁 μ_B) ⋅ (g 𝐒)$</span>, involving the local <span>$g$</span>-tensor and spin angular momentum <span>$𝐒$</span>. Commonly, <span>$g ≈ +2$</span> such that <span>$𝐒$</span> is favored to anti-align with the applied field <span>$𝐁$</span>. Note that a given system of <a href="library.html#Sunny.Units"><code>Units</code></a> will implicitly use the Bohr magneton to convert between field and energy dimensions.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># In units of meV, apply a 2 tesla field in the z-direction
units = Units(:meV, :angstrom)
set_field!(sys, [0, 0, 2] * units.T)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/Interactions.jl#L111-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_field_at!" href="#Sunny.set_field_at!"><code>Sunny.set_field_at!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_field_at!(sys::System, B_μB, site::Site)</code></pre><p>Sets the external magnetic field <span>$𝐁$</span> scaled by the Bohr magneton <span>$μ_B$</span> for a single <a href="library.html#Sunny.Site"><code>Site</code></a>. This scaled field has units of energy and couples directly to the dimensionless <a href="library.html#Sunny.magnetic_moment"><code>magnetic_moment</code></a>. Note that a given system of <a href="library.html#Sunny.Units"><code>Units</code></a> will implicitly use the Bohr magneton to convert between field and energy dimensions.</p><p>See the documentation of <a href="library.html#Sunny.set_field!"><code>set_field!</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/Interactions.jl#L137-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_onsite_coupling!" href="#Sunny.set_onsite_coupling!"><code>Sunny.set_onsite_coupling!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_onsite_coupling!(sys::System, op, i::Int)</code></pre><p>Set the single-ion anisotropy for the <code>i</code>th atom of every unit cell, as well as all symmetry-equivalent atoms. The operator <code>op</code> may be provided as an abstract function of the local spin operators, as a polynomial of <a href="library.html#Sunny.spin_matrices"><code>spin_matrices</code></a>, or as a linear combination of <a href="library.html#Sunny.stevens_matrices"><code>stevens_matrices</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># An easy axis anisotropy in the z-direction
set_onsite_coupling!(sys, S -&gt; -D*S[3]^3, i)

# The unique quartic single-ion anisotropy for a site with cubic point group
# symmetry
set_onsite_coupling!(sys, S -&gt; 20*(S[1]^4 + S[2]^4 + S[3]^4), i)

# An equivalent expression of this quartic anisotropy, up to a constant shift
O = stevens_matrices(spin_label(sys, i))
set_onsite_coupling!(sys, O[4,0] + 5*O[4,4], i)</code></pre><div class="admonition is-warning"><header class="admonition-header">Limitations arising from quantum spin operators</header><div class="admonition-body"><p>Single-ion anisotropy is physically impossible for local moments with quantum spin <span>$s = 1/2$</span>. Consider, for example, that any Pauli matrix squared gives the identity. More generally, one can verify that the <span>$k$</span>th order Stevens operators <code>O[k, q]</code> are zero whenever <span>$s &lt; k/2$</span>. Consequently, an anisotropy quartic in the spin operators requires <span>$s ≥ 2$</span> and an anisotropy of sixth order requires <span>$s ≥ 3$</span>. To circumvent this physical limitation, Sunny provides a mode <code>:dipole_uncorrected</code> that naïvely replaces quantum spin operators with classical moments. See the documentation page <a href="renormalization.html#Interaction-Renormalization">Interaction Renormalization</a> for more information.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/OnsiteCoupling.jl#L95-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_onsite_coupling_at!" href="#Sunny.set_onsite_coupling_at!"><code>Sunny.set_onsite_coupling_at!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_onsite_coupling_at!(sys::System, op, site::Site)</code></pre><p>Sets the single-ion anisotropy operator <code>op</code> for a single <a href="library.html#Sunny.Site"><code>Site</code></a>, ignoring crystal symmetry.  The system must support inhomogeneous interactions via <a href="library.html#Sunny.to_inhomogeneous"><code>to_inhomogeneous</code></a>.</p><p>See also <a href="library.html#Sunny.set_onsite_coupling!"><code>set_onsite_coupling!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/OnsiteCoupling.jl#L179-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_pair_coupling!" href="#Sunny.set_pair_coupling!"><code>Sunny.set_pair_coupling!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_pair_coupling!(sys::System, op, bond)</code></pre><p>Sets an arbitrary coupling <code>op</code> along <code>bond</code>. This coupling will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous interactions on these bonds will be overwritten. The parameter <code>bond</code> has the form <code>Bond(i, j, offset)</code>, where <code>i</code> and <code>j</code> are atom indices within the unit cell, and <code>offset</code> is a displacement in unit cells. The operator <code>op</code> may be provided as an anonymous function that accepts two spin dipole operators, or as a matrix that acts in the tensor product space of the two sites.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Bilinear+biquadratic exchange involving 3×3 matrices J1 and J2
set_pair_coupling!(sys, (Si, Sj) -&gt; Si&#39;*J1*Sj + (Si&#39;*J2*Sj)^2, bond)

# Equivalent expression using an appropriate fixed matrix representation
S = spin_matrices(1/2)
Si, Sj = to_product_space(S, S)
set_pair_coupling!(sys, Si&#39;*J1*Sj + (Si&#39;*J2*Sj)^2, bond)</code></pre><p>See also <a href="library.html#Sunny.spin_matrices"><code>spin_matrices</code></a>, <a href="library.html#Sunny.to_product_space"><code>to_product_space</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/PairExchange.jl#L264-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_pair_coupling_at!" href="#Sunny.set_pair_coupling_at!"><code>Sunny.set_pair_coupling_at!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_pair_coupling_at!(sys::System, op, site1::Site, site2::Site; offset=nothing)</code></pre><p>Sets an arbitrary coupling along the single bond connecting two <a href="library.html#Sunny.Site"><code>Site</code></a>s, ignoring crystal symmetry. Any previous coupling on this bond will be overwritten. The system must support inhomogeneous interactions via <a href="library.html#Sunny.to_inhomogeneous"><code>to_inhomogeneous</code></a>.</p><p>Use <a href="library.html#Sunny.symmetry_equivalent_bonds"><code>symmetry_equivalent_bonds</code></a> to find <code>(site1, site2, offset)</code> values that would be symmetry equivalent to a given <a href="library.html#Sunny.Bond"><code>Bond</code></a> in a homogeneous system. For smaller systems, the <code>offset</code> vector (in multiples of unit cells) will resolve ambiguities in the periodic wrapping.</p><p>The operator <code>op</code> may be provided as an anonymous function that accepts two spin dipole operators, or as a matrix that acts in the tensor product space of the two sites. The documentation for <a href="library.html#Sunny.set_pair_coupling!"><code>set_pair_coupling!</code></a> provides examples constructing <code>op</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/PairExchange.jl#L475-L492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_spin_rescaling!" href="#Sunny.set_spin_rescaling!"><code>Sunny.set_spin_rescaling!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_spin_rescaling!(sys, α)</code></pre><p>In dipole mode, rescale all spin magnitudes <span>$S → α S$</span>. In SU(N) mode, rescale all SU(N) coherent states <span>$Z → √α Z$</span> such that every expectation value rescales like <span>$⟨A⟩ → α ⟨A⟩$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/System.jl#L555-L561">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_vacancy_at!" href="#Sunny.set_vacancy_at!"><code>Sunny.set_vacancy_at!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_vacancy_at!(sys::System, site::Site)</code></pre><p>Make a single site nonmagnetic. <a href="library.html#Sunny.Site"><code>Site</code></a> includes a unit cell and a sublattice index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/Interactions.jl#L152-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.spin_label" href="#Sunny.spin_label"><code>Sunny.spin_label</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spin_label(sys::System, i::Int)</code></pre><p>If atom <code>i</code> carries a single spin-<span>$s$</span> moment, then returns the half-integer label <span>$s$</span>. Otherwise, throws an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/System.jl#L209-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.spin_matrices" href="#Sunny.spin_matrices"><code>Sunny.spin_matrices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spin_matrices(s)</code></pre><p>Returns a triple of <span>$N×N$</span> spin matrices, where <span>$N = 2s+1$</span>. These are the generators of SU(2) in the spin-<code>s</code> representation.</p><p>If <code>s == Inf</code>, then the return values are abstract symbols denoting infinite-dimensional matrices that commute. These can be useful for repeating historical studies, or modeling micromagnetic systems. A technical discussion appears in the Sunny documentation page: <a href="renormalization.html#Interaction-Renormalization">Interaction Renormalization</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">S = spin_matrices(3/2)
@assert S&#39;*S ≈ (3/2)*(3/2+1)*I
@assert S[1]*S[2] - S[2]*S[1] ≈ im*S[3]

S = spin_matrices(Inf)
@assert S[1]*S[2] - S[2]*S[1] == 0</code></pre><p>See also <a href="library.html#Sunny.print_stevens_expansion"><code>print_stevens_expansion</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Operators/Spin.jl#L17-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.spiral_energy" href="#Sunny.spiral_energy"><code>Sunny.spiral_energy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spiral_energy(sys::System; k, axis)</code></pre><p>Returns the energy of a generalized spiral phase associated with the propagation wavevector <code>k</code> (in reciprocal lattice units, RLU) and an <code>axis</code> vector that is normal to the polarization plane (in global Cartesian coordinates).</p><p>When <span>$𝐤$</span> is incommensurate, this calculation can be viewed as creating an infinite number of periodic copies of <code>sys</code>. The spins on each periodic copy are rotated about the <code>axis</code> vector, with the angle <span>$θ = 2π 𝐤⋅𝐫$</span>, where <code>𝐫</code> denotes the displacement vector between periodic copies of <code>sys</code> in multiples of the lattice vectors of the chemical cell.</p><p>The return value is the energy associated with one periodic copy of <code>sys</code>. The special case <span>$𝐤 = 0$</span> yields result is identical to <a href="library.html#Sunny.energy"><code>energy</code></a>.</p><p>See also <a href="library.html#Sunny.minimize_spiral_energy!"><code>minimize_spiral_energy!</code></a> and <a href="library.html#Sunny.repeat_periodically_as_spiral"><code>repeat_periodically_as_spiral</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Spiral/SpiralEnergy.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.spiral_energy_per_site" href="#Sunny.spiral_energy_per_site"><code>Sunny.spiral_energy_per_site</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spiral_energy_per_site(sys::System; k, axis)</code></pre><p>The <a href="library.html#Sunny.spiral_energy"><code>spiral_energy</code></a> divided by the number of sites in <code>sys</code>. The special case <span>$𝐤 = 0$</span> yields a result identical to <a href="library.html#Sunny.energy_per_site"><code>energy_per_site</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Spiral/SpiralEnergy.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.ssf_custom" href="#Sunny.ssf_custom"><code>Sunny.ssf_custom</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ssf_custom(f, sys::System; apply_g=true, formfactors=nothing)</code></pre><p>Specify measurement of the spin structure factor with a custom contraction function <code>f</code>. This function accepts a wavevector <span>$𝐪$</span> in global Cartesian coordinates, and a 3×3 matrix with structure factor intensity components <span>$\mathcal{S}^{αβ}(𝐪,ω)$</span>. Indices <span>$(α, β)$</span> denote dipole components in global coordinates. The return value of <code>f</code> can be any number or <code>isbits</code> type. With specific choices of <code>f</code>, one can obtain measurements such as defined in <a href="library.html#Sunny.ssf_perp"><code>ssf_perp</code></a> and <a href="library.html#Sunny.ssf_trace"><code>ssf_trace</code></a>.</p><p>By default, the g-factor or tensor is applied at each site, such that the structure factor components are correlations between the magnetic moment operators. Set <code>apply_g = false</code> to measure correlations between the bare spin operators.</p><p>The optional <code>formfactors</code> comprise a list of pairs <code>[i1 =&gt; FormFactor(...), i2 =&gt; ...]</code>, where <code>i1, i2, ...</code> are a complete set of symmetry-distinct atoms, and each <a href="library.html#Sunny.FormFactor"><code>FormFactor</code></a> implements <span>$𝐪$</span>-space attenuation for the given atom.</p><p>Intended for use with <a href="library.html#Sunny.SpinWaveTheory"><code>SpinWaveTheory</code></a> and instances of <a href="library.html#Sunny.SampledCorrelations"><code>SampledCorrelations</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Measure all 3×3 structure factor components Sᵅᵝ
measure = ssf_custom((q, ssf) -&gt; ssf, sys)

# Measure the structure factor trace Sᵅᵅ
measure = ssf_custom((q, ssf) -&gt; real(sum(ssf)), sys)</code></pre><p>See also the Sunny documentation on <a href="structure-factor.html#Structure-Factor-Conventions">Structure Factor Conventions</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Measurements/MeasureSpec.jl#L112-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.ssf_custom_bm" href="#Sunny.ssf_custom_bm"><code>Sunny.ssf_custom_bm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ssf_custom_bm(f, sys::System; u, v, apply_g=true, formfactors=nothing)</code></pre><p>Specify measurement of the spin structure factor with a custom contraction function <code>f</code>. The interface is identical to <a href="library.html#Sunny.ssf_custom"><code>ssf_custom</code></a> except that <code>f</code> here receives momentum <span>$𝐪$</span> and the 3×3 structure factor data <span>$\mathcal{S}^{αβ}(𝐪, ω)$</span> in the basis of the Blume-Maleev axis system. The wavevectors <code>u</code> and <code>v</code>, provided in reciprocal lattice units, will be used to define the scattering plane. In global Cartesian coordinates, the three orthonormal BM axes <code>(e1, e2, e3)</code> are defined as follows:</p><pre><code class="language-julia hljs">e3 = normalize(u × v)  # normal to the scattering plane (u, v)
e1 = normalize(q)      # momentum transfer q within scattering plane
e2 = normalize(e3 × q) # perpendicular to q and in the scattering plane</code></pre><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Measure imaginary part of S²³ - S³² in the Blume-Maleev axis system for
# the scattering plane [0, K, L].
measure = ssf_custom_bm(sys; u=[0, 1, 0], v=[0, 0, 1]) do q, ssf
    imag(ssf[2,3] - ssf[3,2])
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Measurements/MeasureSpec.jl#L160-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.ssf_perp" href="#Sunny.ssf_perp"><code>Sunny.ssf_perp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ssf_perp(sys::System; apply_g=true, formfactors=nothing)</code></pre><p>Specify measurement of the spin structure factor with contraction by <span>$(I-𝐪⊗𝐪/q^2)$</span>. The contracted value provides an estimate of unpolarized scattering intensity. In the singular limit <span>$𝐪 → 0$</span>, the contraction matrix is replaced by its rotational average, <span>$(2/3) I$</span>.</p><p>This function is a special case of <a href="library.html#Sunny.ssf_custom"><code>ssf_custom</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Select Co²⁺ form factor for atom 1 and its symmetry equivalents
formfactors = [1 =&gt; FormFactor(&quot;Co2&quot;)]
ssf_perp(sys; formfactors)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Measurements/MeasureSpec.jl#L206-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.ssf_trace" href="#Sunny.ssf_trace"><code>Sunny.ssf_trace</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ssf_trace(sys::System; apply_g=true, formfactors=nothing)</code></pre><p>Specify measurement of the spin structure factor, with trace over spin components. This quantity can be useful for checking quantum sum rules.</p><p>This function is a special case of <a href="library.html#Sunny.ssf_custom"><code>ssf_custom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Measurements/MeasureSpec.jl#L237-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.standardize" href="#Sunny.standardize"><code>Sunny.standardize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">standardize(cryst::Crystal; idealize=true)</code></pre><p>Return the symmetry-inferred standardized crystal unit cell. If <code>idealize=true</code>, then the lattice vectors and site positions will be adapted. See &quot;definitions and conventions&quot; of the <a href="https://spglib.readthedocs.io/en/stable/">spglib documentation</a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Symmetry/Crystal.jl#L233-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.step!" href="#Sunny.step!"><code>Sunny.step!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">step!(sys::System, dynamics)</code></pre><p>Advance the spin configuration one dynamical time-step. The <code>dynamics</code> object may be a continuous spin dynamics, such as <a href="library.html#Sunny.Langevin"><code>Langevin</code></a> or <a href="library.html#Sunny.ImplicitMidpoint"><code>ImplicitMidpoint</code></a>, or it may be a discrete Monte Carlo sampling scheme such as <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Integrators.jl#L298-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.stevens_matrices" href="#Sunny.stevens_matrices"><code>Sunny.stevens_matrices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stevens_matrices(s)</code></pre><p>Returns the Stevens operators in the spin-<code>s</code> representation. The return value <code>O</code> can be indexed as <code>O[k,q]</code>, where <span>$0 ≤ k ≤ 6$</span> labels an irrep of SO(3) and <span>$-k ≤ q ≤ k$</span>. This will produce an <span>$N×N$</span> matrix where <span>$N = 2s + 1$</span>. Linear combinations of Stevens operators can be used as a &quot;physical basis&quot; for decomposing local observables. To see this decomposition, use <a href="library.html#Sunny.print_stevens_expansion"><code>print_stevens_expansion</code></a>.</p><p>If <code>s == Inf</code>, then symbolic operators will be returned. In this infinite dimensional representation, the Stevens operators become homogeneous polynomials of commuting spin operators.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">O = stevens_matrices(2)
S = spin_matrices(2)

A = (1/20)O[4,0] + (1/4)O[4,4] + (102/5)I
B = S[1]^4 + S[2]^4 + S[3]^4
@assert A ≈ B</code></pre><p>See also <a href="library.html#Sunny.spin_matrices"><code>spin_matrices</code></a> and <a href="renormalization.html#Interaction-Renormalization">Interaction Renormalization</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Operators/Stevens.jl#L225-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.subcrystal" href="#Sunny.subcrystal"><code>Sunny.subcrystal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">subcrystal(cryst, types) :: Crystal</code></pre><p>Filters sublattices of a <code>Crystal</code> by atom <code>types</code>, keeping the space group unchanged.</p><pre><code class="nohighlight hljs">subcrystal(cryst, classes) :: Crystal</code></pre><p>Filters sublattices of <code>Crystal</code> by equivalence <code>classes</code>, keeping the space group unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Symmetry/Crystal.jl#L547-L557">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.suggest_magnetic_supercell" href="#Sunny.suggest_magnetic_supercell"><code>Sunny.suggest_magnetic_supercell</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">suggest_magnetic_supercell(ks; tol=1e-12, maxsize=100)</code></pre><p>Suggests a magnetic supercell, in units of the crystal lattice vectors, that is consistent with periodicity of the wavevectors <code>ks</code> in RLU. If the wavevectors are incommensurate (with respect to the maximum supercell size <code>maxsize</code>), one can select a larger error tolerance <code>tol</code> to find a supercell that is almost commensurate.</p><p>Prints a <span>$3×3$</span> matrix of integers that is suitable for use in <a href="library.html#Sunny.reshape_supercell"><code>reshape_supercell</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># A magnetic supercell for a single-Q structure. Will print
k1 = [0, -1/4, 1/4]
suggest_magnetic_supercell([k1])       # [1 0 0; 0 2 1; 0 -2 1]

# A larger magnetic supercell for a double-Q structure
k2 = [1/4, 0, 1/4]
suggest_magnetic_supercell([k1, k2])   # [1 2 2; -1 2 -2; -1 2 2]

# If given incommensurate wavevectors, find an approximate supercell that
# is exactly commensurate for nearby wavevectors.
suggest_magnetic_supercell([[0, 0, 1/√5], [0, 0, 1/√7]]; tol=1e-2)

# This prints [1 0 0; 0 1 0; 0 0 16], which becomes commensurate under the
# approximations `1/√5 ≈ 7/16` and `1/√7 ≈ 3/8`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/MagneticOrdering.jl#L71-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.suggest_timestep" href="#Sunny.suggest_timestep"><code>Sunny.suggest_timestep</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">suggest_timestep(sys, integrator; tol)</code></pre><p>Suggests a timestep for the numerical integration of spin dynamics according to a given error tolerance <code>tol</code>. The <code>integrator</code> should be <a href="library.html#Sunny.Langevin"><code>Langevin</code></a> or <a href="library.html#Sunny.ImplicitMidpoint"><code>ImplicitMidpoint</code></a>. The suggested <span>$dt$</span> will be inversely proportional to the magnitude of the effective field <span>$|dE/d𝐒|$</span> arising from the current spin configuration in <code>sys</code>. The recommended timestep <span>$dt$</span> scales like <code>√tol</code>, which assumes second-order accuracy of the integrator.</p><p>The system <code>sys</code> should be initialized to an equilibrium spin configuration for the target temperature. Alternatively, a reasonably timestep estimate can be obtained from any low-energy spin configuration. For this, one can use <a href="library.html#Sunny.randomize_spins!"><code>randomize_spins!</code></a> and then <a href="library.html#Sunny.minimize_energy!"><code>minimize_energy!</code></a>.</p><p>Large <code>damping</code> magnitude or target temperature <code>kT</code> will tighten the timestep bound. If <code>damping</code> exceeds 1, it will rescale the suggested timestep by an approximate the factor <span>$1/damping$</span>. If <code>kT</code> is the largest energy scale, then the suggested timestep will scale like <code>1/(damping*kT)</code>. Quantification of numerical error for stochastic dynamics is subtle. The stochastic Heun integration scheme is weakly convergent of order-1, such that errors in the estimates of averaged observables may scale like <code>dt</code>. This implies that the <code>tol</code> argument may actually scale like the <em>square</em> of the true numerical error, and should be selected with this in mind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Integrators.jl#L136-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.symmetry_equivalent_bonds" href="#Sunny.symmetry_equivalent_bonds"><code>Sunny.symmetry_equivalent_bonds</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symmetry_equivalent_bonds(sys::System, bond::Bond)</code></pre><p>Given a <a href="library.html#Sunny.Bond"><code>Bond</code></a> for the original (unreshaped) crystal, return all symmetry equivalent bonds in the <a href="library.html#Sunny.System"><code>System</code></a>. Each returned bond is represented as a pair of <a href="library.html#Sunny.Site"><code>Site</code></a>s and an <code>offset</code>, which may be used as input to <a href="library.html#Sunny.set_exchange_at!"><code>set_exchange_at!</code></a> or <a href="library.html#Sunny.set_pair_coupling_at!"><code>set_pair_coupling_at!</code></a>. Reverse bonds are not included in the iterator (no double counting).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">for (site1, site2, offset) in symmetry_equivalent_bonds(sys, bond)
    @assert site1 &lt; site2
    set_exchange_at!(sys, J, site1, site2; offset)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/System.jl#L355-L371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.to_inhomogeneous" href="#Sunny.to_inhomogeneous"><code>Sunny.to_inhomogeneous</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_inhomogeneous(sys::System)</code></pre><p>Returns a copy of the system that allows for inhomogeneous interactions, which can be set using <a href="library.html#Sunny.set_onsite_coupling_at!"><code>set_onsite_coupling_at!</code></a>, <a href="library.html#Sunny.set_exchange_at!"><code>set_exchange_at!</code></a>, and <a href="library.html#Sunny.set_vacancy_at!"><code>set_vacancy_at!</code></a>.</p><p>Inhomogeneous systems do not support symmetry-propagation of interactions or system reshaping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/System/Interactions.jl#L39-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.to_product_space" href="#Sunny.to_product_space"><code>Sunny.to_product_space</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_product_space(A, B, ...)</code></pre><p>Given lists of operators acting on local Hilbert spaces individually, return the corresponding operators that act on the tensor product space. In typical usage, the inputs will represent local physical observables and the outputs will be used to define quantum couplings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/Operators/TensorOperators.jl#L94-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.@mix_proposals" href="#Sunny.@mix_proposals"><code>Sunny.@mix_proposals</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@mix_proposals weight1 propose1 weight2 propose2 ...</code></pre><p>Macro to generate a proposal function that randomly selects among the provided functions according to the provided probability weights. For use with <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># A proposal function that proposes a spin flip 40% of the time, and a
# Gaussian perturbation 60% of the time.
@mix_proposals 0.4 propose_flip 0.6 propose_delta(0.2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/src/MonteCarlo/Samplers.jl#L61-L74">source</a></section></article><h2 id="Optional-Makie-extensions"><a class="docs-heading-anchor" href="#Optional-Makie-extensions">Optional Makie extensions</a><a id="Optional-Makie-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-Makie-extensions" title="Permalink"></a></h2><p>Load a Makie graphics package (<code>GLMakie</code>, <code>WGLMakie</code>, or <code>CairoMakie</code>) to enable the following extensions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.view_bz" href="#Sunny.view_bz"><code>Sunny.view_bz</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">view_bz(crystal::Crystal, objs...; orthographic=false, compass=true)</code></pre><p><strong>Experimental</strong></p><p>Launches a graphical user interface to visualize reciprocal space with respect to the <a href="library.html#Sunny.Crystal"><code>Crystal</code></a> unit cell. The first Brilliouin zone for the primitive lattice is shown as a convex polyhedron. High-symmetry points and paths between them are inspectable, consistent with the data in <a href="library.html#Sunny.print_irreducible_bz_paths"><code>print_irreducible_bz_paths</code></a>. Additional <code>objs</code> may be passed, e.g., to visualize custom paths or grids in reciprocal space.</p><ul><li><code>orthographic</code>: Use orthographic camera perspective.</li><li><code>compass</code>: If true, draw Cartesian axes in bottom left.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/ext/PlottingExt/ViewQSpace.jl#L47-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.view_crystal" href="#Sunny.view_crystal"><code>Sunny.view_crystal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">view_crystal(crystal::Crystal; refbonds=10, orthographic=false, ghost_radius=nothing, ndims=3, compass=true)
view_crystal(sys::System; ...)</code></pre><p>Launches a graphical user interface to visualize the <a href="library.html#Sunny.Crystal"><code>Crystal</code></a> unit cell. If a <a href="library.html#Sunny.System"><code>System</code></a> is provided, then the 3×3 exchange matrices for each bond will be depicted graphically.</p><ul><li><code>refbonds</code>: By default, calculate up to 10 reference bonds using the <code>reference_bonds</code> function. An explicit list of reference bonds may also be provided.</li><li><code>orthographic</code>: Use orthographic camera perspective.</li><li><code>ghost_radius</code>: Show periodic images up to a given distance. Defaults to the cell size.</li><li><code>ndims</code>: Spatial dimensions of system (1, 2, or 3).</li><li><code>compass</code>: If true, draw Cartesian axes in bottom left.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/ext/PlottingExt/ViewCrystal.jl#L395-L411">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.plot_intensities" href="#Sunny.plot_intensities"><code>Sunny.plot_intensities</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_intensities(res::BandIntensities; colormap=nothing, colorrange=nothing, allpositive=true,
                 saturation=0.9, sensitivity=0.0025, fwhm=nothing, ylims=nothing, units=nothing,
                 into=nothing, title=&quot;&quot;)
plot_intensities(res::Intensities; colormap=nothing, colorrange=nothing, allpositive=true, 
                 saturation=0.9, units=nothing, into=nothing, title=&quot;&quot;)
plot_intensities(res::StaticIntensities; colormap=nothing, colorrange=nothing, allpositive=true, 
                 saturation=0.9, units=nothing, into=nothing, title=&quot;&quot;)
plot_intensities(res::PowderIntensities; colormap=nothing, colorrange=nothing, allpositive=true, 
                 saturation=0.9, units=nothing, into=nothing, title=&quot;&quot;)</code></pre><p>Keyword arguments:</p><ul><li><code>colormap</code>: Color palette for plotting broadened intensities. See Makie docs for allowed values.</li><li><code>colorrange</code>: A lower and upper bound on intensities. For heatmaps, these bounds define the intensity values that saturate the colormap.</li><li><code>allpositive</code>: Should intensities be all positive, apart from numerical error? If true, the default colors will clip below zero intensity. If false, the default colors will be symmetric about zero intensity.</li><li><code>saturation</code>: If <code>colorrange</code> is not explicitly set, this dimensionless parameter defines the upper saturated intensity value as a quantile of maximum intensities taken over wavevectors.</li><li><code>sensitivity</code>: When plotting <code>BandIntensities</code>, this defines a lower bound on the visible intensities as a fraction of the upper saturated intensity value.</li><li><code>fwhm</code>: When plotting <code>BandIntensities</code>, this overrides the full-width at half-maximum value used for Gaussian broadening.</li><li><code>ylims</code>: Limits of the y-axis.</li><li><code>units</code>: A <a href="library.html#Sunny.Units"><code>Units</code></a> instance for labeling axes and performing conversions.</li><li><code>into</code>: A symbol for conversion into a new base energy unit (e.g. <code>:meV</code>, <code>:K</code>, etc.)</li><li><code>title</code>: An optional title for the plot.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/ext/PlottingExt/PlotIntensities.jl#L249-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.plot_intensities!" href="#Sunny.plot_intensities!"><code>Sunny.plot_intensities!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_intensities!(panel, res::AbstractIntensities; opts...)</code></pre><p>Mutating variant of <a href="library.html#Sunny.plot_intensities"><code>plot_intensities</code></a> that allows drawing into a single panel of a Makie figure.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">fig = Figure()
plot_intensities!(fig[1, 1], res1; title=&quot;Panel 1&quot;)
plot_intensities!(fig[2, 1], res2; title=&quot;Panel 2&quot;)
display(fig)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/ext/PlottingExt/PlotIntensities.jl#L38-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.plot_spins" href="#Sunny.plot_spins"><code>Sunny.plot_spins</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_spins(sys::System; arrowscale=1.0, color=:red, colorfn=nothing,
           colormap=:viridis, colorrange=nothing, show_cell=true, orthographic=false,
           ghost_radius=0, ndims=3, compass=true)</code></pre><p>Plot the spin configuration defined by <code>sys</code>. Optional parameters are:</p><ul><li><code>arrowscale</code>: Scale all arrows by dimensionless factor.</li><li><code>color</code>: Arrow colors. May be symbolic or numeric. If scalar, will be shared among all sites.</li><li><code>colorfn</code>: Function that dynamically maps from a site index to a numeric color value. Useful for animations.</li><li><code>colormap</code>, <code>colorrange</code>: Used to populate colors from numbers following Makie conventions.</li><li><code>show_cell</code>: Show original crystallographic unit cell.</li><li><code>orthographic</code>: Use orthographic camera perspective.</li><li><code>ghost_radius</code>: Show periodic images up to a given distance (length units).</li><li><code>ndims</code>: Spatial dimensions of system (1, 2, or 3).</li><li><code>compass</code>: If true, draw Cartesian axes in bottom left.</li></ul><p>Calling <code>notify</code> on the return value will animate the figure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/ext/PlottingExt/PlotSpins.jl#L13-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.plot_spins!" href="#Sunny.plot_spins!"><code>Sunny.plot_spins!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_spins!(ax, sys::System; opts...)</code></pre><p>Mutating variant of <a href="library.html#Sunny.plot_spins"><code>plot_spins</code></a> that allows drawing into a single panel of a Makie figure.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">fig = Figure()
plot_spins!(fig[1, 1], sys1)
plot_spins!(fig[2, 1], sys2)
display(fig)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/ext/PlottingExt/PlotSpins.jl#L44-L58">source</a></section></article><h2 id="Optional-WriteVTK-extensions"><a class="docs-heading-anchor" href="#Optional-WriteVTK-extensions">Optional WriteVTK extensions</a><a id="Optional-WriteVTK-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-WriteVTK-extensions" title="Permalink"></a></h2><p>Load the <code>WriteVTK</code> package to enable the following extensions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.export_vtk" href="#Sunny.export_vtk"><code>Sunny.export_vtk</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">export_vtk(filename,params::BinningParameters,data)</code></pre><p>Export a VTK-compatible file to <code>filename</code> (do not include file extension when specifying the file name) which contains the <code>data</code> as VTK Cell Data on a grid parameterized by <code>params</code>.</p><p>At least one axis of the <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> must be integrated over, since VTK does not support 4D data. See <code>integrate_axes!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/854f1f71398198138fa73217dc1e404fea253e43/ext/ExportVTKExt.jl#L59-L68">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="examples/contributed/kappa_tutorial.html">« Enforcing the quantum sum rule with moment renormalization</a><a class="docs-footer-nextpage" href="structure-factor.html">Structure Factor Conventions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 6 December 2024 22:31">Friday 6 December 2024</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
