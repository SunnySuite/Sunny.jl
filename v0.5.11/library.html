<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library API · Sunny documentation</title><meta name="title" content="Library API · Sunny documentation"/><meta property="og:title" content="Library API · Sunny documentation"/><meta property="twitter:title" content="Library API · Sunny documentation"/><meta name="description" content="Documentation for Sunny documentation."/><meta property="og:description" content="Documentation for Sunny documentation."/><meta property="twitter:description" content="Documentation for Sunny documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img class="docs-light-only" src="assets/logo.svg" alt="Sunny documentation logo"/><img class="docs-dark-only" src="assets/logo-dark.svg" alt="Sunny documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Sunny documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Overview</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/01_LSWT_SU3_FeI2.html">1. Multi-flavor spin wave simulations of FeI₂ (Showcase)</a></li><li><a class="tocitem" href="examples/02_LSWT_CoRh2O4.html">2. Spin wave simulations of CoRh₂O₄</a></li><li><a class="tocitem" href="examples/03_LLD_CoRh2O4.html">3. Landau-Lifshitz dynamics of CoRh₂O₄ at finite <em>T</em></a></li><li><a class="tocitem" href="examples/04_GSD_FeI2.html">4. Generalized spin dynamics of FeI₂ at finite <em>T</em></a></li><li><a class="tocitem" href="examples/05_MC_Ising.html">5. Monte Carlo sampling of the Ising model</a></li><li><a class="tocitem" href="examples/06_CP2_Skyrmions.html">6. Dynamical quench into CP² skyrmion liquid</a></li><li><a class="tocitem" href="examples/07_Dipole_Dipole.html">7. Long-range dipole interactions</a></li><li><input class="collapse-toggle" id="menuitem-2-8" type="checkbox"/><label class="tocitem" for="menuitem-2-8"><span class="docs-label">SpinW tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="examples/spinw/SW08_Kagome_AFM.html">SW8 - Kagome Antiferromagnet</a></li><li><a class="tocitem" href="examples/spinw/SW15_Ba3NbFe3Si2O14.html">SW15 - Ba₃NbFe₃Si₂O₁₄</a></li><li><a class="tocitem" href="examples/spinw/SW18_Distorted_kagome.html">SW18 - Distorted kagome</a></li><li><a class="tocitem" href="examples/spinw/SW19_Different_Ions.html">SW19 - Different magnetic ions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-9" type="checkbox"/><label class="tocitem" for="menuitem-2-9"><span class="docs-label">Contributed</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="examples/contributed/MgCr2O4-tutorial.html">MgCr2O4 at Finite Temperature</a></li><li><a class="tocitem" href="examples/contributed/kappa_tutorial.html">Enforcing the quantum sum rule with moment renormalization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-10" type="checkbox"/><label class="tocitem" for="menuitem-2-10"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="parallelism.html">Parallelizing Calculations</a></li><li><a class="tocitem" href="writevtk.html">ParaView Rendering</a></li></ul></li></ul></li><li><span class="tocitem">Modeling Guides</span><ul><li><a class="tocitem" href="structure-factor.html">Structure Factor Calculations</a></li><li><a class="tocitem" href="renormalization.html">Interaction Strength Renormalization</a></li></ul></li><li class="is-active"><a class="tocitem" href="library.html">Library API</a><ul class="internal"><li><a class="tocitem" href="#Optional-Makie-extensions"><span>Optional Makie extensions</span></a></li><li><a class="tocitem" href="#Optional-WriteVTK-extensions"><span>Optional WriteVTK extensions</span></a></li></ul></li><li><a class="tocitem" href="versions.html">Version History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="library.html">Library API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="library.html">Library API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SunnySuite/Sunny.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SunnySuite/Sunny.jl/blob/main/docs/src/library.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-API"><a class="docs-heading-anchor" href="#Library-API">Library API</a><a id="Library-API-1"></a><a class="docs-heading-anchor-permalink" href="#Library-API" title="Permalink"></a></h1><p>This page describes the public types and functions exported by Sunny. This documentation can be also be accessed using the Julia help system (enter <code>?</code> at the Julia command prompt).</p><ul><li><a href="library.html#Sunny.Units"><code>Sunny.Units</code></a></li><li><a href="library.html#Sunny.meV_per_K"><code>Sunny.meV_per_K</code></a></li><li><a href="library.html#Sunny.BinningParameters"><code>Sunny.BinningParameters</code></a></li><li><a href="library.html#Sunny.Bond"><code>Sunny.Bond</code></a></li><li><a href="library.html#Sunny.Crystal"><code>Sunny.Crystal</code></a></li><li><a href="library.html#Sunny.FormFactor-Tuple{String}"><code>Sunny.FormFactor</code></a></li><li><a href="library.html#Sunny.ImplicitMidpoint"><code>Sunny.ImplicitMidpoint</code></a></li><li><a href="library.html#Sunny.Langevin"><code>Sunny.Langevin</code></a></li><li><a href="library.html#Sunny.LocalSampler"><code>Sunny.LocalSampler</code></a></li><li><a href="library.html#Sunny.SampledCorrelations"><code>Sunny.SampledCorrelations</code></a></li><li><a href="library.html#Sunny.Site"><code>Sunny.Site</code></a></li><li><a href="library.html#Sunny.SpinInfo"><code>Sunny.SpinInfo</code></a></li><li><a href="library.html#Sunny.SpinWaveTheory"><code>Sunny.SpinWaveTheory</code></a></li><li><a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>Sunny.System</code></a></li><li><a href="library.html#Sunny.add_sample!-Tuple{SampledCorrelations, System}"><code>Sunny.add_sample!</code></a></li><li><a href="library.html#Sunny.available_energies-Tuple{SampledCorrelations}"><code>Sunny.available_energies</code></a></li><li><a href="library.html#Sunny.available_wave_vectors-Tuple{SampledCorrelations}"><code>Sunny.available_wave_vectors</code></a></li><li><a href="library.html#Sunny.axes_bincenters-Tuple{Any, Any, Any}"><code>Sunny.axes_bincenters</code></a></li><li><a href="library.html#Sunny.broaden_energy-Tuple{SampledCorrelations, Any, Function}"><code>Sunny.broaden_energy</code></a></li><li><a href="library.html#Sunny.clone_system-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.clone_system</code></a></li><li><a href="library.html#Sunny.count_bins-Tuple{Any, Any, Any}"><code>Sunny.count_bins</code></a></li><li><a href="library.html#Sunny.dispersion-Tuple{SpinWaveTheory, Any}"><code>Sunny.dispersion</code></a></li><li><a href="library.html#Sunny.dmvec-Tuple{Any}"><code>Sunny.dmvec</code></a></li><li><a href="library.html#Sunny.dssf-Tuple{SpinWaveTheory, Any}"><code>Sunny.dssf</code></a></li><li><a href="library.html#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.dynamical_correlations</code></a></li><li><a href="library.html#Sunny.eachsite-Tuple{System}"><code>Sunny.eachsite</code></a></li><li><a href="library.html#Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.enable_dipole_dipole!</code></a></li><li><a href="library.html#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy</code></a></li><li><a href="library.html#Sunny.energy_per_site-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy_per_site</code></a></li><li><a href="library.html#Sunny.export_vtk"><code>Sunny.export_vtk</code></a></li><li><a href="library.html#Sunny.gaussian-Tuple{}"><code>Sunny.gaussian</code></a></li><li><a href="library.html#Sunny.generate_mantid_script_from_binning_parameters-Tuple{Any}"><code>Sunny.generate_mantid_script_from_binning_parameters</code></a></li><li><a href="library.html#Sunny.global_position-Tuple{System, Any}"><code>Sunny.global_position</code></a></li><li><a href="library.html#Sunny.instant_correlations-Tuple{System}"><code>Sunny.instant_correlations</code></a></li><li><a href="library.html#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}"><code>Sunny.instant_intensities_interpolated</code></a></li><li><a href="library.html#Sunny.integrate_axes!-Tuple{BinningParameters}"><code>Sunny.integrate_axes!</code></a></li><li><a href="library.html#Sunny.integrated_gaussian-Tuple{}"><code>Sunny.integrated_gaussian</code></a></li><li><a href="library.html#Sunny.integrated_lorentzian-Tuple{}"><code>Sunny.integrated_lorentzian</code></a></li><li><a href="library.html#Sunny.intensities_bands-Tuple{SpinWaveTheory, Any, Sunny.SpinWaveIntensityFormula}"><code>Sunny.intensities_bands</code></a></li><li><a href="library.html#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}"><code>Sunny.intensities_binned</code></a></li><li><a href="library.html#Sunny.intensities_broadened-Tuple{SpinWaveTheory, Any, Any, Any}"><code>Sunny.intensities_broadened</code></a></li><li><a href="library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>Sunny.intensities_interpolated</code></a></li><li><a href="library.html#Sunny.intensity_formula-Tuple{Function, SampledCorrelations, AbstractVector{Int64}}"><code>Sunny.intensity_formula</code></a></li><li><a href="library.html#Sunny.intensity_formula-Tuple{SpinWaveTheory, Symbol}"><code>Sunny.intensity_formula</code></a></li><li><a href="library.html#Sunny.intensity_formula-Tuple{Function, Any, Any}"><code>Sunny.intensity_formula</code></a></li><li><a href="library.html#Sunny.intensity_formula-Tuple{Function, SpinWaveTheory, AbstractVector{Int64}}"><code>Sunny.intensity_formula</code></a></li><li><a href="library.html#Sunny.lattice_params-Tuple{Any}"><code>Sunny.lattice_params</code></a></li><li><a href="library.html#Sunny.lattice_vectors-NTuple{6, Any}"><code>Sunny.lattice_vectors</code></a></li><li><a href="library.html#Sunny.load_nxs-Tuple{Any}"><code>Sunny.load_nxs</code></a></li><li><a href="library.html#Sunny.lorentzian-Tuple{}"><code>Sunny.lorentzian</code></a></li><li><a href="library.html#Sunny.magnetic_moment-Tuple{System, Any}"><code>Sunny.magnetic_moment</code></a></li><li><a href="library.html#Sunny.merge_correlations-Union{Tuple{Array{SampledCorrelations{N}, 1}}, Tuple{N}} where N"><code>Sunny.merge_correlations</code></a></li><li><a href="library.html#Sunny.minimize_energy!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.minimize_energy!</code></a></li><li><a href="library.html#Sunny.modify_exchange_with_truncated_dipole_dipole!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.modify_exchange_with_truncated_dipole_dipole!</code></a></li><li><a href="library.html#Sunny.plot_spins"><code>Sunny.plot_spins</code></a></li><li><a href="library.html#Sunny.polarize_spins!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.polarize_spins!</code></a></li><li><a href="library.html#Sunny.position_to_site-Tuple{System, Any}"><code>Sunny.position_to_site</code></a></li><li><a href="library.html#Sunny.powder_average_binned-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>Sunny.powder_average_binned</code></a></li><li><a href="library.html#Sunny.primitive_cell_shape-Tuple{Crystal}"><code>Sunny.primitive_cell_shape</code></a></li><li><a href="library.html#Sunny.print_bond-Tuple{Crystal, Bond}"><code>Sunny.print_bond</code></a></li><li><a href="library.html#Sunny.print_site-Tuple{Any, Any}"><code>Sunny.print_site</code></a></li><li><a href="library.html#Sunny.print_stevens_expansion-Tuple{AbstractMatrix}"><code>Sunny.print_stevens_expansion</code></a></li><li><a href="library.html#Sunny.print_suggested_frame-Tuple{Crystal, Int64}"><code>Sunny.print_suggested_frame</code></a></li><li><a href="library.html#Sunny.print_symmetry_table-Tuple{Crystal, Any}"><code>Sunny.print_symmetry_table</code></a></li><li><a href="library.html#Sunny.print_wrapped_intensities-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.print_wrapped_intensities</code></a></li><li><a href="library.html#Sunny.propose_delta-Tuple{Any}"><code>Sunny.propose_delta</code></a></li><li><a href="library.html#Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.propose_flip</code></a></li><li><a href="library.html#Sunny.propose_uniform"><code>Sunny.propose_uniform</code></a></li><li><a href="library.html#Sunny.randomize_spins!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.randomize_spins!</code></a></li><li><a href="library.html#Sunny.reciprocal_space_path-Tuple{Crystal, Any, Any}"><code>Sunny.reciprocal_space_path</code></a></li><li><a href="library.html#Sunny.reciprocal_space_path_bins-Tuple{Any, Any, Any, Vararg{Any}}"><code>Sunny.reciprocal_space_path_bins</code></a></li><li><a href="library.html#Sunny.reciprocal_space_shell-Tuple{Crystal, Any, Any}"><code>Sunny.reciprocal_space_shell</code></a></li><li><a href="library.html#Sunny.reference_bonds-Tuple{Crystal, Float64}"><code>Sunny.reference_bonds</code></a></li><li><a href="library.html#Sunny.remove_periodicity!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.remove_periodicity!</code></a></li><li><a href="library.html#Sunny.repeat_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.repeat_periodically</code></a></li><li><a href="library.html#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.reshape_supercell</code></a></li><li><a href="library.html#Sunny.resize_supercell-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.resize_supercell</code></a></li><li><a href="library.html#Sunny.rotate_operator-Tuple{LinearAlgebra.Hermitian{ComplexF64, Matrix{ComplexF64}}, Any}"><code>Sunny.rotate_operator</code></a></li><li><a href="library.html#Sunny.rotation_in_rlu-Tuple{Crystal, Any, Any}"><code>Sunny.rotation_in_rlu</code></a></li><li><a href="library.html#Sunny.set_coherent!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N"><code>Sunny.set_coherent!</code></a></li><li><a href="library.html#Sunny.set_dipole!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N"><code>Sunny.set_dipole!</code></a></li><li><a href="library.html#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_exchange!</code></a></li><li><a href="library.html#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>Sunny.set_exchange_at!</code></a></li><li><a href="library.html#Sunny.set_external_field!-Tuple{System, Any}"><code>Sunny.set_external_field!</code></a></li><li><a href="library.html#Sunny.set_external_field_at!-Tuple{System, Any, Any}"><code>Sunny.set_external_field_at!</code></a></li><li><a href="library.html#Sunny.set_onsite_coupling!-Tuple{System, Any, Int64}"><code>Sunny.set_onsite_coupling!</code></a></li><li><a href="library.html#Sunny.set_onsite_coupling_at!-Tuple{System, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}}"><code>Sunny.set_onsite_coupling_at!</code></a></li><li><a href="library.html#Sunny.set_pair_coupling!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Any}} where N"><code>Sunny.set_pair_coupling!</code></a></li><li><a href="library.html#Sunny.set_pair_coupling_at!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>Sunny.set_pair_coupling_at!</code></a></li><li><a href="library.html#Sunny.set_spin_rescaling!-Tuple{System{0}, Any}"><code>Sunny.set_spin_rescaling!</code></a></li><li><a href="library.html#Sunny.set_spiral_order!-Tuple{Any}"><code>Sunny.set_spiral_order!</code></a></li><li><a href="library.html#Sunny.set_spiral_order_on_sublattice!-Tuple{Any, Any}"><code>Sunny.set_spiral_order_on_sublattice!</code></a></li><li><a href="library.html#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.set_vacancy_at!</code></a></li><li><a href="library.html#Sunny.slice_2D_binning_parameters-Tuple{Vector{Float64}, Any, Any, Int64, Any}"><code>Sunny.slice_2D_binning_parameters</code></a></li><li><a href="library.html#Sunny.spin_label-Tuple{System, Int64}"><code>Sunny.spin_label</code></a></li><li><a href="library.html#Sunny.spin_matrices-Tuple{Any}"><code>Sunny.spin_matrices</code></a></li><li><a href="library.html#Sunny.step!"><code>Sunny.step!</code></a></li><li><a href="library.html#Sunny.stevens_matrices-Tuple{Any}"><code>Sunny.stevens_matrices</code></a></li><li><a href="library.html#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N"><code>Sunny.subcrystal</code></a></li><li><a href="library.html#Sunny.suggest_magnetic_supercell-Tuple{Any}"><code>Sunny.suggest_magnetic_supercell</code></a></li><li><a href="library.html#Sunny.suggest_timestep-Union{Tuple{N}, Tuple{System{N}, Union{ImplicitMidpoint, Langevin}}} where N"><code>Sunny.suggest_timestep</code></a></li><li><a href="library.html#Sunny.symmetry_equivalent_bonds-Tuple{System, Bond}"><code>Sunny.symmetry_equivalent_bonds</code></a></li><li><a href="library.html#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.to_inhomogeneous</code></a></li><li><a href="library.html#Sunny.to_product_space-Tuple{Any, Any, Vararg{Any}}"><code>Sunny.to_product_space</code></a></li><li><a href="library.html#Sunny.unit_resolution_binning_parameters-Tuple{Any, Any, Vararg{Any}}"><code>Sunny.unit_resolution_binning_parameters</code></a></li><li><a href="library.html#Sunny.view_crystal"><code>Sunny.view_crystal</code></a></li><li><a href="library.html#Sunny.@mix_proposals-Tuple"><code>Sunny.@mix_proposals</code></a></li></ul><ul><li><a href="library.html#Sunny.plot_spins"><code>Sunny.plot_spins</code></a></li><li><a href="library.html#Sunny.view_crystal"><code>Sunny.view_crystal</code></a></li><li><a href="library.html#Sunny.export_vtk"><code>Sunny.export_vtk</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Site" href="#Sunny.Site"><code>Sunny.Site</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(cell1, cell2, cell3, i) :: Site</code></pre><p>Four indices identifying a single site in a <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a>. The first three indices select the lattice cell and the last selects the sublattice (i.e., the atom within the unit cell).</p><p>This object can be used to index <code>dipoles</code> and <code>coherents</code> fields of a <code>System</code>. A <code>Site</code> is also required to specify inhomogeneous interactions via functions such as <a href="library.html#Sunny.set_external_field_at!-Tuple{System, Any, Any}"><code>set_external_field_at!</code></a> or <a href="library.html#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>set_exchange_at!</code></a>.</p><p>Note that the definition of a cell may change when a system is reshaped. In this case, it is convenient to construct the <code>Site</code> using <a href="library.html#Sunny.position_to_site-Tuple{System, Any}"><code>position_to_site</code></a>, which always takes a position in fractional coordinates of the original lattice vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/System.jl#L163-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Units" href="#Sunny.Units"><code>Sunny.Units</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Units.meV
Units.theory</code></pre><p>The unit system is implicitly determined by the definition of two physical constants: the vacuum permeability <span>$μ₀$</span> and the Bohr magneton <span>$μ_B$</span>. Temperatures are effectively measured in units of energy (<span>$k_B = 1$</span>) and time is effectively measured in units of inverse energy (<span>$ħ = 1$</span>). The default unit system, <code>Units.meV</code>, employs (meV, Å, tesla). Select alternatively <code>Units.theory</code> for a units system defined so that <span>$μ₀ = μ_B = 1$</span>.</p><p>See also <a href="library.html#Sunny.meV_per_K"><code>meV_per_K</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Units.jl#L14-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.meV_per_K" href="#Sunny.meV_per_K"><code>Sunny.meV_per_K</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">meV_per_K = 0.086173332621451774</code></pre><p>A physical constant. Useful for converting kelvin into the default energy units, meV.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Units.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.BinningParameters" href="#Sunny.BinningParameters"><code>Sunny.BinningParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BinningParameters(binstart,binend,binwidth;covectors = I(4))
BinningParameters(binstart,binend;numbins,covectors = I(4))</code></pre><p>Describes a 4D parallelepided histogram in a format compatible with experimental Inelasitic Neutron Scattering data. See <a href="library.html#Sunny.generate_mantid_script_from_binning_parameters-Tuple{Any}"><code>generate_mantid_script_from_binning_parameters</code></a> to convert <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> to a format understandable by the <a href="https://www.mantidproject.org/">Mantid software</a>, or <a href="library.html#Sunny.load_nxs-Tuple{Any}"><code>load_nxs</code></a> to load <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> from a Mantid <code>.nxs</code> file.</p><p>The coordinates of the histogram axes are specified by multiplication  of <code>(q,ω)</code> with each row of the <code>covectors</code> matrix, with <code>q</code> given in [R.L.U.]. Since the default <code>covectors</code> matrix is the identity matrix, the default axes are <code>(qx,qy,qz,ω)</code> in absolute units.</p><p>The convention for the binning scheme is that:</p><ul><li>The left edge of the first bin starts at <code>binstart</code></li><li>The bin width is <code>binwidth</code></li><li>The last bin contains <code>binend</code></li><li>There are no &quot;partial bins;&quot; the last bin may contain values greater than <code>binend</code>. C.f. <a href="library.html#Sunny.count_bins-Tuple{Any, Any, Any}"><code>count_bins</code></a>.</li></ul><p>A <code>value</code> can be binned by computing its bin index:</p><pre><code class="nohighlight hljs">coords = covectors * value
bin_ix = 1 .+ floor.(Int64,(coords .- binstart) ./ binwidth)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/Binning.jl#L2-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Bond" href="#Sunny.Bond"><code>Sunny.Bond</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bond(i, j, n)</code></pre><p>Represents a bond between atom indices <code>i</code> and <code>j</code>. <code>n</code> is a vector of three integers specifying unit cell displacement in terms of lattice vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Symmetry/Bond.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Crystal" href="#Sunny.Crystal"><code>Sunny.Crystal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An object describing a crystallographic unit cell and its space group symmetry. Constructors are as follows:</p><pre><code class="nohighlight hljs">Crystal(filename; symprec=1e-5)</code></pre><p>Reads the crystal from a <code>.cif</code> file located at the path <code>filename</code>.  The optional parameter <code>symprec</code> controls the precision tolerance for spacegroup symmetries.</p><pre><code class="nohighlight hljs">Crystal(latvecs, positions; types=nothing, symprec=1e-5)</code></pre><p>Constructs a crystal from the complete list of atom positions <code>positions</code>, with coordinates (between 0 and 1) in units of lattice vectors <code>latvecs</code>. Spacegroup symmetry information is automatically inferred. The optional parameter <code>types</code> is a list of strings, one for each atom, and can be used to break symmetry-equivalence between atoms.</p><pre><code class="nohighlight hljs">Crystal(latvecs, positions, spacegroup_number; types=nothing, setting=nothing, symprec=1e-5)</code></pre><p>Builds a crystal by applying symmetry operators for a given international spacegroup number. For certain spacegroups, there are multiple possible unit cell settings; in this case, a warning message will be printed, and a list of crystals will be returned, one for every possible setting. Alternatively, the optional <code>setting</code> string will disambiguate between unit cell conventions.</p><p>Currently, crystals built using only the spacegroup number will be missing some symmetry information. It is generally preferred to build a crystal from a <code>.cif</code> file or from the full specification of the unit cell.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Read a Crystal from a .cif file
Crystal(&quot;filename.cif&quot;)

# Build a BCC crystal in the conventional cubic unit cell by specifying both
# atoms. The spacegroup 229 is inferred.
latvecs = lattice_vectors(1, 1, 1, 90, 90, 90)
positions = [[0, 0, 0], [1/2, 1/2, 1/2]]
Crystal(latvecs, positions)

# Build a CsCl crystal (two simple cubic sublattices). Because of the distinct
# atom types, the spacegroup number 221 is now inferred.
types = [&quot;Na&quot;, &quot;Cl&quot;]
cryst = Crystal(latvecs, positions; types)

# Build a diamond cubic crystal from its spacegroup number 227 and a single
# atom position. This spacegroup has two possible settings (&quot;1&quot; or &quot;2&quot;), which
# determine an overall unit cell translation.
positions = [[1/4, 1/4, 1/4]]
cryst = Crystal(latvecs, positions, 227; setting=&quot;1&quot;)</code></pre><p>See also <a href="library.html#Sunny.lattice_vectors-NTuple{6, Any}"><code>lattice_vectors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Symmetry/Crystal.jl#L8-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.FormFactor-Tuple{String}" href="#Sunny.FormFactor-Tuple{String}"><code>Sunny.FormFactor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FormFactor(ion::String; g_lande=2)</code></pre><p>The magnetic form factor for a given magnetic ion and charge state. When passed to an <a href="library.html#Sunny.intensity_formula-Tuple{Function, Any, Any}"><code>intensity_formula</code></a>, it rescales structure factor intensities based on the magnitude of the scattering vector, <span>$|𝐪|$</span>.</p><p>The parameter <code>ion</code> must be one of the following strings:</p><pre><code class="nohighlight hljs">Am2, Am3, Am4, Am5, Am6, Am7, Au1, Au2, Au3, Au4, Au5, Ce2, Co0, Co1, Co2, Co3,
Co4, Cr0, Cr1, Cr2, Cr3, Cr4, Cu0, Cu1, Cu2, Cu3, Cu4, Dy2, Dy3, Er2, Er3, Eu2,
Eu3, Fe0, Fe1, Fe2, Fe3, Fe4, Gd2, Gd3, Hf2, Hf3, Ho2, Ho3, Ir0a, Ir0b, Ir0c,
Ir1a, Ir1b, Ir2, Ir3, Ir4, Ir5, Ir6, Mn0, Mn1, Mn2, Mn3, Mn4, Mn5, Mo0, Mo1, Nb0,
Nb1, Nd2, Nd3, Ni0, Ni1, Ni2, Ni3, Ni4, Np3, Np4, Np5, Np6, Os0a, Os0b, Os0c,
Os1a, Os1b, Os2, Os3, Os4, Os5, Os6, Os7, Pd0, Pd1, Pr3, Pt1, Pt2, Pt3, Pt4,
Pt5, Pt6, Pu3, Pu4, Pu5, Pu6, Re0a, Re0b, Re0c, Re1a, Re1b, Re2, Re3, Re4, Re5,
Re6, Rh0, Rh1, Ru0, Ru1, Sc0, Sc1, Sc2, Sm2, Sm3, Ta2, Ta3, Ta4, Tb2, Tb3, Tc0,
Tc1, Ti0, Ti1, Ti2, Ti3, Tm2, Tm3, U3, U4, U5, V0, V1, V2, V3, V4, W0a, W0b,
W0c, W1a, W1b, W2c, W3, W4, W5, Y0, Yb2, Yb3, Zr0, Zr1</code></pre><p>The trailing number denotes ionization state. For example, <code>&quot;Fe0&quot;</code> denotes a neutral iron atom, while <code>&quot;Fe2&quot;</code> denotes <code>Fe²⁺</code>. If multiple electronic configurations are possible, they will be distinguished by a trailing letter (<code>a</code>, <code>b</code>, ...). Omitting this letter will print an informative error,</p><pre><code class="nohighlight hljs">FormFactor(&quot;Ir0&quot;)

ERROR: Disambiguate form factor according to electronic configuration:
    &quot;Ir0a&quot; -- 6s⁰5d⁹
    &quot;Ir0b&quot; -- 6s¹5d⁸
    &quot;Ir0c&quot; -- 6s²5d⁷</code></pre><p>In the dipolar approximation (small <span>$|𝐪|$</span>) the form factor is</p><p><span>$F(s) = ⟨j_0(s)⟩ + \frac{2-g}{g} ⟨j_2(s)⟩$</span>,</p><p>involving <span>$s = |𝐪|/4π$</span> and the Landé <span>$g$</span>-factor. The <span>$⟨j_l(s)⟩$</span> are radial averages of the <span>$l$</span>th spherical Bessel function of the magnetic dipole. More details are provided in Ref. [1].</p><p>The <span>$⟨j_l(s)⟩$</span> can be approximated as a sum of Gaussians,</p><p class="math-container">\[⟨j_0(s)⟩ = A e^{-as^2} + B e^{-bs^2} + C e^{-cs^2} + D e^{-ds^2} + E \\
⟨j_2(s)⟩ = (A e^{-as^2} + B e^{-bs^2} + C e^{-cs^2} + D e^{-ds^2} + E) s^2\]</p><p>For 3d, 4d, rare earth, and actinide ions, Sunny uses the revised tables of P. J. Brown, as documented in the McPhase package [2]. For 5d ions, Sunny uses the tables of Kobayashi, Nagao, Ito [3].</p><p>Two special, <span>$𝐪$</span>-independent form factor values are available: <code>one(FormFactor)</code> and <code>zero(FormFactor)</code>. The first idealizes the magnetic ion as a perfect point particle, while the second zeros all contributions from the magnetic ion.</p><p>References:</p><ol><li><a href="https://www.ill.eu/sites/ccsl/ffacts/ffachtml.html">P. J. Brown, The Neutron Data Booklet, 2nd ed., Sec. 2.5 Magnetic Form Factors (2003)</a></li><li>Coefficient tables in <a href="https://www2.cpfs.mpg.de/~rotter/homepage_mcphase/manual/node137.html">McPhase documentation</a></li><li>K. Kobayashi, T. Nagao, M. Ito, Acta Cryst. A, 67 pp 473–480 (2011)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/FormFactor.jl#L36-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.ImplicitMidpoint" href="#Sunny.ImplicitMidpoint"><code>Sunny.ImplicitMidpoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImplicitMidpoint(dt::Float64; atol=1e-12) where N</code></pre><p>The implicit midpoint method for integrating the Landau-Lifshitz spin dynamics or its generalization to SU(<em>N</em>) coherent states [1]. One call to the <a href="library.html#Sunny.step!"><code>step!</code></a> function will advance a <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> by <code>dt</code> units of time. This integration scheme is exactly symplectic and eliminates energy drift over arbitrarily long simulation trajectories.</p><p>References:</p><ol><li><a href="https://arxiv.org/abs/2106.14125">H. Zhang and C. D. Batista, Phys. Rev. B 104, 104409 (2021)</a>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Integrators.jl#L93-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Langevin" href="#Sunny.Langevin"><code>Sunny.Langevin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Langevin(dt::Float64; damping::Float64, kT::Float64)</code></pre><p>An integrator for Langevin spin dynamics using the explicit Heun method. The <code>damping</code> parameter controls the coupling to an implicit thermal bath. One call to the <a href="library.html#Sunny.step!"><code>step!</code></a> function will advance a <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> by <code>dt</code> units of time. Can be used to sample from the Boltzmann distribution at temperature <code>kT</code>. An alternative approach to sampling states from thermal equilibrium is <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>, which proposes local Monte Carlo moves. For example, use <code>LocalSampler</code> instead of <code>Langevin</code> to sample Ising-like spins.</p><p>Setting <code>damping = 0</code> disables coupling to the thermal bath, yielding an energy-conserving spin dynamics. The <code>Langevin</code> integrator uses an explicit numerical integrator which cannot prevent energy drift. Alternatively, the <a href="library.html#Sunny.ImplicitMidpoint"><code>ImplicitMidpoint</code></a> method can be used, which is more expensive but prevents energy drift through exact conservation of the symplectic 2-form.</p><p>If the <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> has <code>mode = :dipole</code>, then the dynamics is the stochastic Landau-Lifshitz equation,</p><p class="math-container">\[    d𝐬/dt = -𝐬 × (ξ - 𝐁 + λ 𝐬 × 𝐁),\]</p><p>where <span>$𝐁 = -dE/d𝐬$</span> is the effective field felt by the expected spin dipole <span>$𝐬$</span>. The components of <span>$ξ$</span> are Gaussian white noise, with magnitude <span>$√(2 k_B T λ)$</span> set by a fluctuation-dissipation theorem. The parameter <code>damping</code> sets the phenomenological coupling <span>$λ$</span> to the thermal bath. </p><p>If the <code>System</code> has <code>mode = :SUN</code>, then this dynamics generalizes [1] to a stochastic nonlinear Schrödinger equation for SU(<em>N</em>) coherent states <span>$𝐙$</span>,</p><p class="math-container">\[    d𝐙/dt = -i P [ζ + (1 - i λ̃) ℋ 𝐙].\]</p><p>Here, <span>$P$</span> projects onto the space orthogonal to <span>$𝐙$</span>, and <span>$ζ$</span> denotes complex Gaussian white noise with magnitude <span>$√(2 k_B T λ̃)$</span>. The local-Hamiltonian <span>$ℋ$</span> embeds the energy gradient into the 𝔰𝔲(<em>N</em>) Lie algebra, and generates evolution of spin dipoles, quadrupoles, etc. The parameter <code>damping</code> here sets <span>$λ̃$</span>, which is analogous to <span>$λ$</span> above.</p><p>When applied to SU(2) coherent states, the generalized spin dynamics reduces exactly to the stochastic Landau-Lifshitz equation. The mapping is as follows. Normalized coherent states <span>$𝐙$</span> map to dipole expectation values <span>$𝐬 = 𝐙^{†} Ŝ 𝐙$</span>, where spin operators <span>$Ŝ$</span> are a spin-<span>$|𝐬|$</span> representation of SU(2). The local effective Hamiltonian <span>$ℋ = -𝐁 ⋅ Ŝ$</span> generates rotation of the dipole in analogy to the vector cross product <span>$S × 𝐁$</span>. The coupling to the thermal bath maps as <span>$λ̃ = |𝐬| λ$</span>. Note, therefore, that the scaling of the <code>damping</code> parameter varies subtly between <code>:dipole</code> and <code>:SUN</code> modes.</p><p>References:</p><ol><li><a href="https://arxiv.org/abs/2209.01265">D. Dahlbom et al., Phys. Rev. B 106, 235154 (2022)</a>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Integrators.jl#L1-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.LocalSampler" href="#Sunny.LocalSampler"><code>Sunny.LocalSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocalSampler(; kT, nsweeps=1.0, propose=propose_uniform)</code></pre><p>Monte Carlo simulation involving Metropolis updates to individual spins. One call to the <a href="library.html#Sunny.step!"><code>step!</code></a> function will perform <code>nsweeps</code> of MCMC sampling for a provided <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a>. The default value of <code>1.0</code> means that <code>step!</code> performs, on average, one trial update per spin.</p><p>Assuming ergodicity, the <code>LocalSampler</code> will sample from thermal equilibrium for the target temperature <code>kT</code>. </p><p>The trial spin updates are sampled using the <code>propose</code> function. Built-in options include <a href="library.html#Sunny.propose_uniform"><code>propose_uniform</code></a>, <a href="library.html#Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>propose_flip</code></a>, and <a href="library.html#Sunny.propose_delta-Tuple{Any}"><code>propose_delta</code></a>. Multiple proposals can be mixed with the macro <a href="library.html#Sunny.@mix_proposals-Tuple"><code>@mix_proposals</code></a>.</p><p>The returned object stores fields <code>ΔE</code> and <code>Δs</code>, which represent the cumulative change to the net energy and dipole, respectively.</p><p>An alternative approach to sampling is <a href="library.html#Sunny.Langevin"><code>Langevin</code></a>, which may be preferred for simulating continuous spins, especially in the presence of long-range dipole-dipole interactions (cf. <a href="library.html#Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>enable_dipole_dipole!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/MonteCarlo/Samplers.jl#L98-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.SampledCorrelations" href="#Sunny.SampledCorrelations"><code>Sunny.SampledCorrelations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SampledCorrelations</code></pre><p>Basic data type for storing sampled correlation data. A <code>SampleCorrelations</code> is initialized by calling either <a href="library.html#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N"><code>dynamical_correlations</code></a> or <a href="library.html#Sunny.instant_correlations-Tuple{System}"><code>instant_correlations</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SampledCorrelations/SampledCorrelations.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.SpinInfo" href="#Sunny.SpinInfo"><code>Sunny.SpinInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpinInfo(atom::Int; S, g=2)</code></pre><p>Characterizes the spin at a given <code>atom</code> index within the crystal unit cell. <code>S</code> is an integer multiple of 1/2 and gives the spin angular momentum in units of ħ. <code>g</code> is the g-factor or tensor, such that an angular momentum dipole <span>$s$</span> produces a magnetic moment <span>$g s$</span> in units of the Bohr magneton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/SpinInfo.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.SpinWaveTheory" href="#Sunny.SpinWaveTheory"><code>Sunny.SpinWaveTheory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpinWaveTheory(sys, energy_ϵ::Float64=1e-8)</code></pre><p>Constructs an object to perform linear spin wave theory. Use it with <a href="library.html#Sunny.dispersion-Tuple{SpinWaveTheory, Any}"><code>dispersion</code></a> and <a href="library.html#Sunny.dssf-Tuple{SpinWaveTheory, Any}"><code>dssf</code></a> functions.</p><p>The optional parameter <code>energy_ϵ</code> adds a small positive shift to the diagonal of the dynamical matrix <span>$D$</span> to avoid numerical issues with zero-energy quasi-particle modes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SpinWaveTheory/SpinWaveTheory.jl#L14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}" href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>Sunny.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(crystal::Crystal, latsize, infos, mode; units=Units.meV, seed::Int)</code></pre><p>Construct a <code>System</code> of spins for a given <a href="library.html#Sunny.Crystal"><code>Crystal</code></a> symmetry. The <code>latsize</code> parameter determines the number of unit cells in each lattice vector direction. The <code>infos</code> parameter is a list of <a href="library.html#Sunny.SpinInfo"><code>SpinInfo</code></a> objects, which determine the magnitude <span>$S$</span> and <span>$g$</span>-tensor of each spin.</p><p>The two primary options for <code>mode</code> are <code>:SUN</code> and <code>:dipole</code>. In the former, each spin-<span>$S$</span> degree of freedom is described as an SU(<em>N</em>) coherent state, i.e. a quantum superposition of <span>$N = 2S + 1$</span> levels. This formalism can be useful to capture multipolar spin fluctuations or local entanglement effects. </p><p>Mode <code>:dipole</code> projects the SU(<em>N</em>) dynamics onto the restricted space of pure dipoles. In practice this means that Sunny will simulate Landau-Lifshitz dynamics, but single-ion anisotropy and biquadratic exchange interactions will be renormalized to improve accuracy. To disable this renormalization, use the mode <code>:dipole_large_S</code> which applies the <span>$S → ∞$</span> classical limit. For details, see the documentation page: <a href="renormalization.html#Interaction-Strength-Renormalization">Interaction Strength Renormalization</a>.</p><p>The default units system of (meV, Å, tesla) can be overridden by with the <code>units</code> parameter; see <a href="library.html#Sunny.Units"><code>Units</code></a>. </p><p>An optional <code>seed</code> may be provided to achieve reproducible random number generation.</p><p>All spins are initially polarized in the <span>$z$</span>-direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/System.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.add_sample!-Tuple{SampledCorrelations, System}" href="#Sunny.add_sample!-Tuple{SampledCorrelations, System}"><code>Sunny.add_sample!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_sample!(sc::SampledCorrelations, sys::System)</code></pre><p><code>add_trajectory</code> uses the spin configuration contained in the <code>System</code> to generate a correlation data and accumulate it into <code>sc</code>. For static structure factors, this involves analyzing the spin-spin correlations of the spin configuration provided. For a dynamic structure factor, a trajectory is calculated using the given spin configuration as an initial condition. The spin-spin correlations are then calculated in time and accumulated into <code>sc</code>. </p><p>This function will change the state of <code>sys</code> when calculating dynamical structure factor data. To preserve the initial state of <code>sys</code>, it must be saved separately prior to calling <code>add_sample!</code>. Alternatively, the initial spin configuration may be copied into a new <code>System</code> and this new <code>System</code> can be passed to <code>add_sample!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SampledCorrelations/CorrelationSampling.jl#L157-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.available_energies-Tuple{SampledCorrelations}" href="#Sunny.available_energies-Tuple{SampledCorrelations}"><code>Sunny.available_energies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">available_energies(sc::SampledCorrelations; negative_energies=false)</code></pre><p>Return the ω values for the energy index of a <code>SampledCorrelations</code>. By default, only returns values for non-negative energies, which corresponds to the default output of <code>intensities</code>. Set <code>negative_energies</code> to true to retrieve all ω values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SampledCorrelations/CorrelationUtils.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.available_wave_vectors-Tuple{SampledCorrelations}" href="#Sunny.available_wave_vectors-Tuple{SampledCorrelations}"><code>Sunny.available_wave_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">available_wave_vectors(sc::SampledCorrelations; bzsize=(1,1,1))</code></pre><p>Returns all wave vectors for which <code>sc</code> contains exact values. <code>bsize</code> specifies the number of Brillouin zones to be included.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SampledCorrelations/CorrelationUtils.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.axes_bincenters-Tuple{Any, Any, Any}" href="#Sunny.axes_bincenters-Tuple{Any, Any, Any}"><code>Sunny.axes_bincenters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">axes_bincenters(params::BinningParameters)</code></pre><p>Returns tick marks which label the bins of the histogram described by <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> by their bin centers.</p><p>The following alternative syntax can be used to compute bin centers for a single axis:</p><pre><code class="nohighlight hljs">axes_bincenters(binstart,binend,binwidth)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/Binning.jl#L288-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.broaden_energy-Tuple{SampledCorrelations, Any, Function}" href="#Sunny.broaden_energy-Tuple{SampledCorrelations, Any, Function}"><code>Sunny.broaden_energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">broaden_energy(sc::SampledCorrelations, vals, kernel::Function; negative_energies=false)</code></pre><p>Performs a real-space convolution along the energy axis of an array of intensities. Assumes the format of the intensities array corresponds to what would be returned by <a href="library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a>. <code>kernel</code> must be a function that takes two numbers: <code>kernel(ω, ω₀)</code>, where <code>ω</code> is a frequency, and <code>ω₀</code> is the center frequency of the kernel. Sunny provides <a href="library.html#Sunny.lorentzian-Tuple{}"><code>lorentzian</code></a> for the most common use case:</p><pre><code class="nohighlight hljs">newvals = broaden_energy(sc, vals, (ω, ω₀) -&gt; lorentzian(fwhm=0.2)(ω-ω₀))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SampledCorrelations/DataRetrieval.jl#L194-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.clone_system-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.clone_system-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.clone_system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clone_system(sys::System)</code></pre><p>Creates a full clone of the system, such that mutable updates to one copy will not affect the other, and thread safety is guaranteed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/System.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.count_bins-Tuple{Any, Any, Any}" href="#Sunny.count_bins-Tuple{Any, Any, Any}"><code>Sunny.count_bins</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_bins(binstart,binend,binwidth)</code></pre><p>Returns the number of bins in the binning scheme implied by <code>binstart</code>, <code>binend</code>, and <code>binwidth</code>. To count the bins in a <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a>, use <code>params.numbins</code>.</p><p>This function defines how partial bins are handled, so it should be used preferentially over computing the number of bins manually.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/Binning.jl#L77-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.dispersion-Tuple{SpinWaveTheory, Any}" href="#Sunny.dispersion-Tuple{SpinWaveTheory, Any}"><code>Sunny.dispersion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dispersion(swt::SpinWaveTheory, qs)</code></pre><p>Computes the spin excitation energy dispersion relations given a <a href="library.html#Sunny.SpinWaveTheory"><code>SpinWaveTheory</code></a> and an array of wave vectors <code>qs</code>. Each element <span>$q$</span> of <code>qs</code> must be a 3-vector in units of reciprocal lattice units. I.e., <span>$qᵢ$</span> is given in <span>$2π/|aᵢ|$</span> with <span>$|aᵢ|$</span> the lattice constant of the original chemical lattice.</p><p>The first indices of the returned array correspond to those of <code>qs</code>. A final index, corresponding to mode, is added to these. Each entry of the array is an energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SpinWaveTheory/DispersionAndIntensities.jl#L84-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.dmvec-Tuple{Any}" href="#Sunny.dmvec-Tuple{Any}"><code>Sunny.dmvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dmvec(D)</code></pre><p>Antisymmetric matrix representation of the Dzyaloshinskii-Moriya pseudo-vector,</p><pre><code class="nohighlight hljs">  [  0    D[3] -D[2]
   -D[3]   0    D[1]
    D[2] -D[1]   0  ]</code></pre><p>This matrix is closely related to the vector cross product, <code>dmvec(u)*v ≈ -u×v</code>. Useful in the context of <a href="library.html#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_exchange!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/PairExchange.jl#L559-L572">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.dssf-Tuple{SpinWaveTheory, Any}" href="#Sunny.dssf-Tuple{SpinWaveTheory, Any}"><code>Sunny.dssf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dssf(swt::SpinWaveTheory, qs)</code></pre><p>Given a <a href="library.html#Sunny.SpinWaveTheory"><code>SpinWaveTheory</code></a> object, computes the dynamical spin structure factor,</p><p class="math-container">\[    𝒮^{αβ}(𝐤, ω) = 1/(2πN)∫dt ∑_𝐫 \exp[i(ωt - 𝐤⋅𝐫)] ⟨S^α(𝐫, t)S^β(0, 0)⟩,\]</p><p>using the result from linear spin-wave theory,</p><p class="math-container">\[    𝒮^{αβ}(𝐤, ω) = ∑_n |A_n^{αβ}(𝐤)|^2 δ[ω-ω_n(𝐤)].\]</p><p><code>qs</code> is an array of wave vectors of arbitrary dimension. Each element <span>$q$</span> of <code>qs</code> must be a 3-vector in reciprocal lattice units (RLU), i.e., in the basis of reciprocal lattice vectors.</p><p>The first indices of the returned array correspond to those of <code>qs</code>. A final index, corresponding to mode, is added to these. Each entry of this array is a tensor (3×3 matrix) corresponding to the indices <span>$α$</span> and <span>$β$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SpinWaveTheory/DispersionAndIntensities.jl#L125-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.dynamical_correlations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dynamical_correlations(sys::System; dt, nω, ωmax, 
                       observables=nothing, correlations=nothing)</code></pre><p>Creates an empty <code>SampledCorrelations</code> object for calculating and storing dynamical structure factor intensities <span>$𝒮(𝐪,ω)$</span>. Call <a href="library.html#Sunny.add_sample!-Tuple{SampledCorrelations, System}"><code>add_sample!</code></a> to accumulate data for the given configuration of a spin system. Internally, this will run a dynamical trajectory and measure time correlations. The <span>$𝒮(𝐪,ω)$</span> data can be retrieved by calling <a href="library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a>. Alternatively, <a href="library.html#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}"><code>instant_intensities_interpolated</code></a> will integrate out <span>$ω$</span> to obtain <span>$𝒮(𝐪)$</span>, optionally applying classical-to-quantum correction factors.</p><p>Three keywords are required to specify the dynamics used for the trajectory calculation.</p><ul><li><code>dt</code>: The time step used for calculating the trajectory from which dynamic   spin-spin correlations are calculated. The trajectories are calculated with   an <a href="library.html#Sunny.ImplicitMidpoint"><code>ImplicitMidpoint</code></a> integrator.</li><li><code>ωmax</code>: The maximum energy, <span>$ω$</span>, that will be resolved. Note that allowed   values of <code>ωmax</code> are constrained by the given <code>dt</code>, so Sunny will choose the   smallest possible value that is no smaller than the specified <code>ωmax</code>.</li><li><code>nω</code>: The number of energy bins to calculated between 0 and <code>ωmax</code>.</li></ul><p>Additional keyword options are the following:</p><ul><li><code>observables</code>: Allows the user to specify custom observables. The   <code>observables</code> must be given as a list of complex <code>N×N</code> matrices or   <code>LinearMap</code>s. It&#39;s recommended to name each observable, for example:   <code>observables = [:A =&gt; a_observable_matrix, :B =&gt; b_map, ...]</code>. By default,   Sunny uses the 3 components of the dipole, <code>:Sx</code>, <code>:Sy</code> and <code>:Sz</code>.</li><li><code>correlations</code>: Specify which correlation functions are calculated, i.e. which   matrix elements <span>$αβ$</span> of <span>$𝒮^{αβ}(q,ω)$</span> are calculated and stored.   Specified with a vector of tuples. By default Sunny records all auto- and   cross-correlations generated by all <code>observables</code>. To retain only the xx and   xy correlations, one would set <code>correlations=[(:Sx,:Sx), (:Sx,:Sy)]</code> or   <code>correlations=[(1,1),(1,2)]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SampledCorrelations/SampledCorrelations.jl#L89-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.eachsite-Tuple{System}" href="#Sunny.eachsite-Tuple{System}"><code>Sunny.eachsite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachsite(sys::System)</code></pre><p>An iterator over all <a href="library.html#Sunny.Site"><code>Site</code></a>s in the system. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/System.jl#L217-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.enable_dipole_dipole!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enable_dipole_dipole!(sys::System)</code></pre><p>Enables long-range interactions between magnetic dipole moments,</p><p class="math-container">\[    -(μ_0/4π) ∑_{⟨ij⟩}  [3 (μ_i⋅𝐫̂_{ij})(μ_j⋅𝐫̂_{ij}) - μ_i⋅μ_j] / r_{ij}^3\]</p><p>where the sum is over all pairs of spins (singly counted), including periodic images, regularized using the Ewald summation convention. See <a href="library.html#Sunny.magnetic_moment-Tuple{System, Any}"><code>magnetic_moment</code></a> for the relationship between <span>$μ_i$</span> and the spin angular momentum. The vacuum permeability <span>$μ_0$</span> is a physical constant determined by system of <a href="library.html#Sunny.Units"><code>Units</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/Interactions.jl#L66-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy(sys::System)</code></pre><p>The total system energy. See also <a href="library.html#Sunny.energy_per_site-Union{Tuple{System{N}}, Tuple{N}} where N"><code>energy_per_site</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/Interactions.jl#L208-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.energy_per_site-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.energy_per_site-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy_per_site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy_per_site(sys::System)</code></pre><p>The total system <a href="library.html#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N"><code>energy</code></a> divided by the number of sites.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/Interactions.jl#L199-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.gaussian-Tuple{}" href="#Sunny.gaussian-Tuple{}"><code>Sunny.gaussian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gaussian(; {fwhm, σ})</code></pre><p>Returns the function <code>exp(-x^2/2σ^2) / √(2π*σ^2)</code>. Exactly one of <code>fwhm</code> or <code>σ</code> must be specified, where <code>fwhm = (2.355...) * σ</code> denotes the full width at half maximum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SampledCorrelations/DataRetrieval.jl#L138-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.generate_mantid_script_from_binning_parameters-Tuple{Any}" href="#Sunny.generate_mantid_script_from_binning_parameters-Tuple{Any}"><code>Sunny.generate_mantid_script_from_binning_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_mantid_script_from_binning_parameters(params::BinningParameters)</code></pre><p>Generate a Mantid script which bins data according to the given <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Units</header><div class="admonition-body"><p>Take care to ensure the units are correct (R.L.U. or absolute). You may want to call <code>Sunny.bin_rlu_as_absolute_units!</code> or <code>Sunny.bin_absolute_units_as_rlu!</code> first.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/ExperimentData.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.global_position-Tuple{System, Any}" href="#Sunny.global_position-Tuple{System, Any}"><code>Sunny.global_position</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">global_position(sys::System, site::Site)</code></pre><p>Position of a <a href="library.html#Sunny.Site"><code>Site</code></a> in global coordinates.</p><p>To precompute a full list of positions, one can use <a href="library.html#Sunny.eachsite-Tuple{System}"><code>eachsite</code></a> as below:</p><pre><code class="language-julia hljs">pos = [global_position(sys, site) for site in eachsite(sys)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/System.jl#L224-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.instant_correlations-Tuple{System}" href="#Sunny.instant_correlations-Tuple{System}"><code>Sunny.instant_correlations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">instant_correlations(sys::System; process_trajectory=:none, observables=nothing, correlations=nothing)</code></pre><p>Creates an empty <code>SampledCorrelations</code> object for calculating and storing instantaneous structure factor intensities <span>$𝒮(𝐪)$</span>. Call <a href="library.html#Sunny.add_sample!-Tuple{SampledCorrelations, System}"><code>add_sample!</code></a> to accumulate data for the given configuration of a spin system. Call <a href="library.html#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}"><code>instant_intensities_interpolated</code></a> to retrieve averaged <span>$𝒮(𝐪)$</span> data.</p><p><em>Important note</em>: When dealing with continuous (non-Ising) spins, consider creating using <a href="library.html#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N"><code>dynamical_correlations</code></a> instead of <code>instant_correlations</code>. The former will provide full <span>$𝒮(𝐪,ω)$</span> data, from which <span>$𝒮(𝐪)$</span> can be obtained by integrating out <span>$ω$</span>. During this integration step, Sunny can incorporate temperature- and <span>$ω$</span>-dependent classical-to-quantum correction factors to produce more accurate <span>$𝒮(𝐪)$</span> estimates. See <a href="library.html#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}"><code>instant_intensities_interpolated</code></a> for more information.</p><p>The following optional keywords are available:</p><ul><li><code>observables</code>: Allows the user to specify custom observables. The   <code>observables</code> must be given as a list of complex <code>N×N</code> matrices or   <code>LinearMap</code>s. It&#39;s recommended to name each observable, for example:   <code>observables = [:A =&gt; a_observable_matrix, :B =&gt; b_map, ...]</code>. By default,   Sunny uses the 3 components of the dipole, <code>:Sx</code>, <code>:Sy</code> and <code>:Sz</code>.</li><li><code>correlations</code>: Specify which correlation functions are calculated, i.e. which   matrix elements <span>$αβ$</span> of <span>$𝒮^{αβ}(q,ω)$</span> are calculated and stored.   Specified with a vector of tuples. By default Sunny records all auto- and   cross-correlations generated by all <code>observables</code>. To retain only the xx and   xy correlations, one would set <code>correlations=[(:Sx,:Sx), (:Sx,:Sy)]</code> or   <code>correlations=[(1,1),(1,2)]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SampledCorrelations/SampledCorrelations.jl#L191-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}" href="#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}"><code>Sunny.instant_intensities_interpolated</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">instant_intensities_interpolated(sc::SampledCorrelations, qs, formula::ClassicalIntensityFormula; kwargs...)</code></pre><p>Return <span>$𝒮(𝐪)$</span> intensities at wave vectors <code>qs</code>. The functionality is very similar to <a href="library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a>, except the returned array has dimensions identical to <code>qs</code>. If called on a <code>SampledCorrelations</code> with dynamical information, i.e., <span>$𝒮(𝐪,ω)$</span>, the <span>$ω$</span> information is integrated out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/Interpolation.jl#L183-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.integrate_axes!-Tuple{BinningParameters}" href="#Sunny.integrate_axes!-Tuple{BinningParameters}"><code>Sunny.integrate_axes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrate_axes!(params::BinningParameters; axes)</code></pre><p>Integrate over one or more axes of the histogram by setting the number of bins in that axis to 1. Examples:</p><pre><code class="nohighlight hljs">integrate_axes!(params; axes = [2,3])
integrate_axes!(params; axes = 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/Binning.jl#L98-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.integrated_gaussian-Tuple{}" href="#Sunny.integrated_gaussian-Tuple{}"><code>Sunny.integrated_gaussian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrated_gaussian(; {fwhm, σ})</code></pre><p>Returns the function <code>erf(x/√2σ)/2</code>, which is the integral of <a href="library.html#Sunny.gaussian-Tuple{}"><code>gaussian</code></a> over the range <span>$[0, x]$</span>. Exactly one of <code>fwhm</code> or <code>σ</code> must be specified, where <code>fwhm = (2.355...) * σ</code> denotes the full width at half maximum. Intended for use with <a href="library.html#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}"><code>intensities_binned</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SampledCorrelations/DataRetrieval.jl#L154-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.integrated_lorentzian-Tuple{}" href="#Sunny.integrated_lorentzian-Tuple{}"><code>Sunny.integrated_lorentzian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrated_lorentzian(; fwhm)</code></pre><p>Returns the function <code>atan(2x/Γ)/π</code>, which is the integral of <a href="library.html#Sunny.lorentzian-Tuple{}"><code>lorentzian</code></a> over the range <span>$[0, x]$</span>, where <code>Γ = fwhm</code> is the full width at half maximum. Intended for use with <a href="library.html#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}"><code>intensities_binned</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SampledCorrelations/DataRetrieval.jl#L181-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensities_bands-Tuple{SpinWaveTheory, Any, Sunny.SpinWaveIntensityFormula}" href="#Sunny.intensities_bands-Tuple{SpinWaveTheory, Any, Sunny.SpinWaveIntensityFormula}"><code>Sunny.intensities_bands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dispersion, intensities = intensities_bands(swt::SpinWaveTheory, qs, formula::SpinWaveIntensityFormula)</code></pre><p>Computes the scattering intensities at each energy band for each momentum transfer <code>q</code> in <code>qs</code>, according to linear spin wave theory and the given intensity <code>formula</code>. The <code>formula</code> must have a delta-function kernel, e.g.:</p><pre><code class="nohighlight hljs">formula = intensity_formula(swt, :perp, formula; kernel=delta_function_kernel)</code></pre><p>or else the bands will be broadened, and their intensity can not be computed.</p><p>The outputs will be arrays with indices identical to <code>qs</code>, with the last index giving the band index. <code>dispersions</code> reports the energy of each band, while <code>intensities</code> reports the scattering intensity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/LinearSpinWaveIntensities.jl#L43-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}" href="#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}"><code>Sunny.intensities_binned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensity, counts = intensities_binned(sc::SampledCorrelations, params::BinningParameters, formula; integrated_kernel)</code></pre><p>Given correlation data contained in a <a href="library.html#Sunny.SampledCorrelations"><code>SampledCorrelations</code></a> and <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> describing the shape of a histogram, compute the intensity and normalization for each histogram bin using a given <a href="library.html#Sunny.intensity_formula-Tuple{Function, Any, Any}"><code>intensity_formula</code></a>.</p><p>The <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> are expected to accept <code>(q,ω)</code> in R.L.U. for the (possibly reshaped) crystal associated with <code>sc</code>.</p><p>This is an alternative to <a href="library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a> which bins the scattering intensities into a histogram instead of interpolating between them at specified <code>qs</code> values. See <a href="library.html#Sunny.unit_resolution_binning_parameters-Tuple{Any, Any, Vararg{Any}}"><code>unit_resolution_binning_parameters</code></a> for a reasonable default choice of <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> which roughly emulates <a href="library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a> with <code>interpolation = :round</code>.</p><p>If a function <code>integrated_kernel(Δω)</code> is passed, it will be used as the CDF of a kernel function for energy broadening. For example, <code>integrated_kernel = Δω -&gt; atan(Δω/η)/pi</code> (c.f. <a href="library.html#Sunny.integrated_lorentzian-Tuple{}"><code>integrated_lorentzian</code></a> implements Lorentzian broadening with parameter <code>η</code>. Energy-dependent energy broadening can be achieved by providing an <code>integrated_kernel(ω,Δω)</code> whose first argument is the energy transfer <code>ω</code>.</p><p>Currently, energy broadening is only supported if the <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> are such that the first three axes are purely spatial and the last (energy) axis is <code>[0,0,0,1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/Binning.jl#L359-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensities_broadened-Tuple{SpinWaveTheory, Any, Any, Any}" href="#Sunny.intensities_broadened-Tuple{SpinWaveTheory, Any, Any, Any}"><code>Sunny.intensities_broadened</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensities_broadened(swt::SpinWaveTheory, qs, ωs, formula)</code></pre><p>Computes the scattering intensities at each <code>(q,ω)</code> according to Linear Spin Wave Theory and the given intensity <code>formula</code>. The required <code>formula</code> must have a non-delta-function kernel, e.g.:</p><pre><code class="nohighlight hljs">formula = intensity_formula(swt, :perp; kernel = lorentzian(0.05))</code></pre><p>or else the intensity at <code>ωs</code> which are not exactly on the dispersion curve can not be calculated.</p><p>The intensity is computed at each wave vector in <code>qs</code> and each energy in <code>ωs</code>. The output will be an array with indices identical to <code>qs</code>, with the last index matching <code>ωs</code>.</p><p>Note that <code>qs</code> is an array of wave vectors of arbitrary dimension. Each element <span>$q$</span> of <code>qs</code> must be a 3-wavevector in absolute units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/LinearSpinWaveIntensities.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}" href="#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>Sunny.intensities_interpolated</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensities_interpolated(sc::SampledCorrelations, qs, formula:ClassicalIntensityFormula; interpolation=nothing, negative_energies=false)</code></pre><p>The basic function for retrieving <span>$𝒮(𝐪,ω)$</span> information from a <code>SampledCorrelations</code>. Maps an array of wave vectors <code>qs</code> to an array of structure factor intensities, including an additional energy index. The values of <span>$ω$</span> associated with the energy index can be retrieved by calling <a href="library.html#Sunny.available_energies-Tuple{SampledCorrelations}"><code>available_energies</code></a>. The three coordinates of each wave vector are measured in reciprocal lattice units, i.e., multiples of the reciprocal lattice vectors.</p><ul><li><code>interpolation</code>: Since <span>$𝒮(𝐪, ω)$</span> is calculated on a finite lattice, data   is only available at discrete wave vectors. By default, Sunny will round a   requested <code>q</code> to the nearest available wave vector. Linear interpolation can   be applied by setting <code>interpolation=:linear</code>.</li><li><code>negative_energies</code>: If set to <code>true</code>, Sunny will return the periodic   extension of the energy axis. Most users will not want this.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/Interpolation.jl#L100-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensity_formula-Tuple{Function, Any, Any}" href="#Sunny.intensity_formula-Tuple{Function, Any, Any}"><code>Sunny.intensity_formula</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A custom intensity formula can be specifed by providing a function <code>intensity = f(q,ω,correlations)</code> and specifying which correlations it requires:</p><pre><code class="nohighlight hljs">intensity_formula(f,sc::SampledCorrelations, required_correlations; kwargs...)</code></pre><p>The function is intended to be specified using <code>do</code> notation. For example, this custom formula sums the off-diagonal correlations:</p><pre><code class="nohighlight hljs">required = [(:Sx,:Sy),(:Sy,:Sz),(:Sx,:Sz)]
intensity_formula(sc,required,return_type = ComplexF64) do k, ω, off_diagonal_correlations
    sum(off_diagonal_correlations)
end</code></pre><p>If your custom formula returns a type other than <code>Float64</code>, use the <code>return_type</code> keyword argument to flag this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SampledCorrelations/DataRetrieval.jl#L102-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensity_formula-Tuple{Function, SampledCorrelations, AbstractVector{Int64}}" href="#Sunny.intensity_formula-Tuple{Function, SampledCorrelations, AbstractVector{Int64}}"><code>Sunny.intensity_formula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">formula = intensity_formula(sc::SampledCorrelations)</code></pre><p>Establish a formula for computing the intensity of the discrete scattering modes <code>(q,ω)</code> using the correlation data <span>$𝒮^{αβ}(q,ω)$</span> stored in the <a href="library.html#Sunny.SampledCorrelations"><code>SampledCorrelations</code></a>. The <code>formula</code> returned from <code>intensity_formula</code> can be passed to <a href="library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a> or <a href="library.html#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}"><code>intensities_binned</code></a>.</p><pre><code class="nohighlight hljs">intensity_formula(sc,...; kT = Inf, formfactors = ...)</code></pre><p>There are keyword arguments providing temperature and form factor corrections:</p><ul><li><code>kT</code>: If a temperature is provided, the intensities will be rescaled by a   temperature- and ω-dependent classical-to-quantum factor. <code>kT</code> should be   specified when making comparisons with spin wave calculations or   experimental data. If <code>kT</code> is not specified, infinite temperature (no   correction) is assumed.</li><li><code>formfactors</code>: To apply form factor corrections, provide this keyword with a   list of <code>FormFactor</code>s, one for each symmetry-distinct site in the crystal.   The order of <code>FormFactor</code>s must correspond to the order of site symmetry   classes, e.g., as they appear when printed in <code>display(crystal)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SampledCorrelations/DataRetrieval.jl#L41-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensity_formula-Tuple{Function, SpinWaveTheory, AbstractVector{Int64}}" href="#Sunny.intensity_formula-Tuple{Function, SpinWaveTheory, AbstractVector{Int64}}"><code>Sunny.intensity_formula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">formula = intensity_formula(swt::SpinWaveTheory; kernel = ...)</code></pre><p>Establish a formula for computing the scattering intensity by diagonalizing the hamiltonian <span>$H(q)$</span> using Linear Spin Wave Theory.</p><p>If <code>kernel = delta_function_kernel</code>, then the resulting formula can be used with <a href="library.html#Sunny.intensities_bands-Tuple{SpinWaveTheory, Any, Sunny.SpinWaveIntensityFormula}"><code>intensities_bands</code></a>.</p><p>If <code>kernel</code> is an energy broadening kernel function, then the resulting formula can be used with <a href="library.html#Sunny.intensities_broadened-Tuple{SpinWaveTheory, Any, Any, Any}"><code>intensities_broadened</code></a>. Energy broadening kernel functions can either be a function of <code>Δω</code> only, e.g.:</p><pre><code class="nohighlight hljs">kernel = Δω -&gt; ...</code></pre><p>or a function of both the energy transfer <code>ω</code> and of <code>Δω</code>, e.g.:</p><pre><code class="nohighlight hljs">kernel = (ω,Δω) -&gt; ...</code></pre><p>The integral of a properly normalized kernel function over all <code>Δω</code> is one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SpinWaveTheory/DispersionAndIntensities.jl#L213-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensity_formula-Tuple{SpinWaveTheory, Symbol}" href="#Sunny.intensity_formula-Tuple{SpinWaveTheory, Symbol}"><code>Sunny.intensity_formula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensity_formula([swt or sc], contraction_mode::Symbol)</code></pre><p>Sunny has several built-in formulas that can be selected by setting <code>contraction_mode</code> to one of these values:</p><ul><li><code>:trace</code> (default), which yields <span>$\operatorname{tr} 𝒮(q,ω) = ∑_α 𝒮^{αα}(q,ω)$</span></li><li><code>:perp</code>, which contracts <span>$𝒮^{αβ}(q,ω)$</span> with the dipole factor <span>$δ_{αβ} - q_{α}q_{β}$</span>, returning the unpolarized intensity.</li><li><code>:full</code>, which will return all elements <span>$𝒮^{αβ}(𝐪,ω)$</span> without contraction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/ElementContraction.jl#L155-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.lattice_params-Tuple{Any}" href="#Sunny.lattice_params-Tuple{Any}"><code>Sunny.lattice_params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_params(latvecs)</code></pre><p>Compute the lattice parameters <span>$(a, b, c, α, β, γ)$</span> for the three lattice vectors provided as columns of <code>latvecs</code>. The inverse mapping is <a href="library.html#Sunny.lattice_vectors-NTuple{6, Any}"><code>lattice_vectors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Symmetry/LatticeUtils.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.lattice_vectors-NTuple{6, Any}" href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>Sunny.lattice_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_vectors(a, b, c, α, β, γ)</code></pre><p>Return the lattice vectors, as columns of the <span>$3×3$</span> output matrix, that correspond to the conventional unit cell defined by the lattice constants <span>$(a, b, c)$</span> and the angles <span>$(α, β, γ)$</span> in degrees. The inverse mapping is <a href="library.html#Sunny.lattice_params-Tuple{Any}"><code>lattice_params</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Symmetry/LatticeUtils.jl#L20-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.load_nxs-Tuple{Any}" href="#Sunny.load_nxs-Tuple{Any}"><code>Sunny.load_nxs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">params, signal = load_nxs(filename; field=&quot;signal&quot;)</code></pre><p>Given the name of a Mantid-exported <code>MDHistoWorkspace</code> file, load the <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> and the signal from that file.</p><p>To load another field instead of the signal, specify e.g. <code>field=&quot;errors_squared&quot;</code>. Typical fields include <code>errors_squared</code>, <code>mask</code>, <code>num_events</code>, and <code>signal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/ExperimentData.jl#L37-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.lorentzian-Tuple{}" href="#Sunny.lorentzian-Tuple{}"><code>Sunny.lorentzian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lorentzian(; fwhm)</code></pre><p>Returns the function <code>(Γ/2) / (π*(x^2+(Γ/2)^2))</code> where <code>Γ = fwhm</code> is the full width at half maximum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SampledCorrelations/DataRetrieval.jl#L170-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.magnetic_moment-Tuple{System, Any}" href="#Sunny.magnetic_moment-Tuple{System, Any}"><code>Sunny.magnetic_moment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">magnetic_moment(sys::System, site::Site)</code></pre><p>Get the magnetic moment for a <a href="library.html#Sunny.Site"><code>Site</code></a>. This is the spin dipole <span>$𝐒$</span> multiplied by the local <span>$g$</span>-tensor and the Bohr magneton <span>$μ_B$</span>. The latter is a physical constant determined by system of <a href="library.html#Sunny.Units"><code>Units</code></a>.</p><p class="math-container">\[μ = + μ_B g 𝐒\]</p><div class="admonition is-warning"><header class="admonition-header">Sign error</header><div class="admonition-body"><p>The above sign is incorrect in the standard convention that the electron spin <span>$g$</span>-factor is positive. For a pure electron spin, <span>$μ$</span> and <span>$𝐒$</span> must be anti-aligned. In practice, this sign error can be resolved by effectively reversing any applied magnetic field. The sign of <span>$μ$</span> will be fixed in a future Sunny version.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/System.jl#L241-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.merge_correlations-Union{Tuple{Array{SampledCorrelations{N}, 1}}, Tuple{N}} where N" href="#Sunny.merge_correlations-Union{Tuple{Array{SampledCorrelations{N}, 1}}, Tuple{N}} where N"><code>Sunny.merge_correlations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge_correlations(scs::Vector{SampledCorrelations)</code></pre><p>Accumulate a list of <code>SampledCorrelations</code> into a single, summary <code>SampledCorrelations</code>. Useful for reducing the results of parallel computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/SampledCorrelations/SampledCorrelations.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.minimize_energy!-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.minimize_energy!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.minimize_energy!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimize_energy!(sys::System{N}; maxiters=1000, method=Optim.ConjugateGradient(),
                 g_tol=1e-10, kwargs...) where N</code></pre><p>Optimizes the spin configuration in <code>sys</code> to minimize energy. A total of <code>maxiters</code> iterations will be attempted. Convergence is reached when the root mean squared energy gradient goes below <code>g_tol</code>. The remaining <code>kwargs</code> will be forwarded to the <code>optimize</code> method of the Optim.jl package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Optimization.jl#L90-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.modify_exchange_with_truncated_dipole_dipole!-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.modify_exchange_with_truncated_dipole_dipole!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.modify_exchange_with_truncated_dipole_dipole!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modify_exchange_with_truncated_dipole_dipole!(sys::System, cutoff)</code></pre><p>This <em>experimental</em> function is subject to change.</p><p>Like <a href="library.html#Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>enable_dipole_dipole!</code></a>, the purpose of this function is to introduce long-range dipole-dipole interactions between magnetic moments. Whereas <code>enable_dipole_dipole!</code> employs Ewald summation, this function instead employs real-space pair couplings, with truncation at some user-specified <code>cutoff</code> distance. If the cutoff is relatively small, then this function can be faster than <code>enable_dipole_dipole!</code>, especially for spin wave theory calculations.</p><p><strong>Caution</strong>. This function will modify existing bilinear couplings between spins by adding dipole-dipole interactions. It must therefore be called <em>after</em> all other pair couplings have been specified. Conversely, any calls to <code>set_exchange!</code>, <code>set_pair_coupling!</code>, etc. will irreversibly delete the dipole-dipole interactions that have been introduced by this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/Ewald.jl#L244-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.polarize_spins!-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.polarize_spins!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.polarize_spins!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polarize_spins!(sys::System, dir)</code></pre><p>Polarize all spins in the system along the direction <code>dir</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/System.jl#L536-L540">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.position_to_site-Tuple{System, Any}" href="#Sunny.position_to_site-Tuple{System, Any}"><code>Sunny.position_to_site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">position_to_site(sys::System, r)</code></pre><p>Converts a position <code>r</code> to four indices of a <a href="library.html#Sunny.Site"><code>Site</code></a>. The coordinates of <code>r</code> are given in units of the lattice vectors for the original crystal. This function can be useful for working with systems that have been reshaped using <a href="library.html#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>reshape_supercell</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Find the `site` at the center of a unit cell which is displaced by four
# multiples of the first lattice vector
site = position_to_site(sys, [4.5, 0.5, 0.5])

# Print the dipole at this site
println(sys.dipoles[site])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/System.jl#L278-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.powder_average_binned-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}" href="#Sunny.powder_average_binned-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>Sunny.powder_average_binned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">powder_average_binned(sc::SampledCorrelations, radial_binning_parameters; formula
                     ω_binning_parameters, integrated_kernel = nothing, bzsize = nothing)</code></pre><p>This function emulates the experimental situation of &quot;powder averaging,&quot; where only the magnitude (and not the direction) of the momentum transfer is resolvable. The intensities are binned similarly to <a href="library.html#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}"><code>intensities_binned</code></a>, but the histogram x-axis is <code>|k|</code> in absolute units, which is a nonlinear function of <code>kx</code>,<code>ky</code>,<code>kz</code>. The y-axis is energy.</p><p>Radial binning parameters are specified as tuples <code>(start,end,bin_width)</code>, e.g. <code>radial_binning_parameters = (0,6π,6π/55)</code>.</p><p>Energy broadening is supported in the same way as <code>intensities_binned</code>, and this function accepts the same kind of <a href="library.html#Sunny.intensity_formula-Tuple{Function, Any, Any}"><code>intensity_formula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/PowderAveraging.jl#L49-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.primitive_cell_shape-Tuple{Crystal}" href="#Sunny.primitive_cell_shape-Tuple{Crystal}"><code>Sunny.primitive_cell_shape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primitive_cell_shape(cryst::Crystal)</code></pre><p>Returns the shape of the primitive cell as a 3×3 matrix, in fractional coordinates of the conventional lattice vectors. May be useful for constructing inputs to <a href="library.html#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>reshape_supercell</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Valid if `cryst` has not been reshaped
@assert cryst.prim_latvecs ≈ cryst.latvecs * primitive_cell_shape(cryst)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Symmetry/Crystal.jl#L420-L432">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_bond-Tuple{Crystal, Bond}" href="#Sunny.print_bond-Tuple{Crystal, Bond}"><code>Sunny.print_bond</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_bond(cryst::Crystal, bond::Bond; b_ref::Bond)</code></pre><p>Prints symmetry information for bond <code>bond</code>. A symmetry-equivalent reference bond <code>b_ref</code> can optionally be provided to fix the meaning of the coefficients <code>A</code>, <code>B</code>, ...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Symmetry/Printing.jl#L105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_site-Tuple{Any, Any}" href="#Sunny.print_site-Tuple{Any, Any}"><code>Sunny.print_site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_site(cryst, i; R=I)</code></pre><p>Print symmetry information for the site <code>i</code>, including allowed g-tensor and allowed anisotropy operator. An optional rotation matrix <code>R</code> can be provided to define the reference frame for expression of the anisotropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Symmetry/Printing.jl#L199-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_stevens_expansion-Tuple{AbstractMatrix}" href="#Sunny.print_stevens_expansion-Tuple{AbstractMatrix}"><code>Sunny.print_stevens_expansion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function print_stevens_expansion(op)</code></pre><p>Prints a local Hermitian operator as a linear combination of Stevens operators. The operator <code>op</code> may be a finite-dimensional matrix or an abstract spin polynomial in the large-<span>$S$</span> limit.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">S = spin_matrices(2)
print_stevens_expansion(S[1]^4 + S[2]^4 + S[3]^4)
# Prints: (1/20)𝒪₄₀ + (1/4)𝒪₄₄ + 102/5

S = spin_matrices(Inf)
print_stevens_expansion(S[1]^4 + S[2]^4 + S[3]^4)
# Prints: (1/20)𝒪₄₀ + (1/4)𝒪₄₄ + (3/5)𝒮⁴</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Operators/Stevens.jl#L177-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_suggested_frame-Tuple{Crystal, Int64}" href="#Sunny.print_suggested_frame-Tuple{Crystal, Int64}"><code>Sunny.print_suggested_frame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_suggested_frame(cryst, i; digits=4)</code></pre><p>Print a suggested reference frame, as a rotation matrix <code>R</code>, that can be used as input to <code>print_site()</code>. The purpose is to simplify the description of allowed anisotropies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Symmetry/Printing.jl#L183-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_symmetry_table-Tuple{Crystal, Any}" href="#Sunny.print_symmetry_table-Tuple{Crystal, Any}"><code>Sunny.print_symmetry_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_symmetry_table(cryst::Crystal, max_dist)</code></pre><p>Print symmetry information for all equivalence classes of sites and bonds, up to a maximum bond distance of <code>max_dist</code>. Equivalent to calling <code>print_bond(cryst, b)</code> for every bond <code>b</code> in <code>reference_bonds(cryst, max_dist)</code>, where <code>Bond(i, i, [0,0,0])</code> refers to a single site <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Symmetry/Printing.jl#L167-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_wrapped_intensities-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.print_wrapped_intensities-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.print_wrapped_intensities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_wrapped_intensities(sys::System; nmax=10)</code></pre><p>For Bravais lattices: Prints up to <code>nmax</code> wavevectors according to their instantaneous (static) structure factor intensities, listed in descending order. For non-Bravais lattices: Performs the same analysis for each spin sublattice independently; the output weights are naïvely averaged over sublattices, without incorporating phase shift information. This procedure therefore wraps all wavevectors into the first Brillouin zone. Each wavevector coordinate is given between <span>$-1/2$</span> and <span>$1/2$</span> in reciprocal lattice units (RLU).  The output from this function will typically be used as input to <a href="library.html#Sunny.suggest_magnetic_supercell-Tuple{Any}"><code>suggest_magnetic_supercell</code></a>.</p><p>Because this function does not incorporate phase information in its averaging over sublattices, the printed weights are not directly comparable with experiment. For that purpose, use <a href="library.html#Sunny.instant_correlations-Tuple{System}"><code>instant_correlations</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/MagneticOrdering.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.propose_delta-Tuple{Any}" href="#Sunny.propose_delta-Tuple{Any}"><code>Sunny.propose_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propose_delta(magnitude)</code></pre><p>Generate a proposal function that adds a Gaussian perturbation to the existing spin state. In <code>:dipole</code> mode, the procedure is to first introduce a random three-vector perturbation <span>$𝐬′ = 𝐬 + |𝐬| ξ$</span> and then return the properly normalized spin <span>$|𝐬| (𝐬′/|𝐬′|)$</span>. Each component of the random vector <span>$ξ$</span> is Gaussian distributed with a standard deviation of <code>magnitude</code>; the latter is dimensionless and typically smaller than one. </p><p>In <code>:SUN</code> mode, the procedure is analogous, but now involving Gaussian perturbations to each of the <span>$N$</span> complex components of an SU(<em>N</em>) coherent state.</p><p>In the limit of very large <code>magnitude</code>, this function coincides with <a href="library.html#Sunny.propose_uniform"><code>propose_uniform</code></a>.</p><p>For use with <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/MonteCarlo/Samplers.jl#L20-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.propose_flip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propose_flip</code></pre><p>Function to propose pure spin flip updates in the context of a <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>. Dipoles are flipped as <span>$𝐬 → -𝐬$</span>. SU(<em>N</em>) coherent states are flipped using the time-reversal operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/MonteCarlo/Samplers.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.propose_uniform" href="#Sunny.propose_uniform"><code>Sunny.propose_uniform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">propose_uniform</code></pre><p>Function to propose a uniformly random spin update in the context of a <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>. In <code>:dipole</code> mode, the result is a random three-vector with appropriate normalization. In <code>:SUN</code> mode, the result is a random SU(<em>N</em>) coherent state with appropriate normalization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/MonteCarlo/Samplers.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.randomize_spins!-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.randomize_spins!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.randomize_spins!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randomize_spins!(sys::System)</code></pre><p>Randomizes all spins under appropriate the uniform distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/System.jl#L494-L498">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.reciprocal_space_path-Tuple{Crystal, Any, Any}" href="#Sunny.reciprocal_space_path-Tuple{Crystal, Any, Any}"><code>Sunny.reciprocal_space_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reciprocal_space_path(cryst::Crystal, qs, density)</code></pre><p>Returns a pair <code>(path, xticks)</code>. The <code>path</code> return value is a list of wavevectors that samples linearly between the provided wavevectors <code>qs</code>. The <code>xticks</code> return value can be used to label the special <span>$𝐪$</span> values on the x-axis of a plot.</p><p>Special note about units: the wavevectors <code>qs</code> must be provided in reciprocal lattice units (RLU) for the given crystal, but the sampling density must be specified in the global frame. Specifically, the density is given as number of sample points per unit of radian inverse length, where the unit of length is the same as that used to specify the lattice vectors of the Crystal. The <code>path</code> will therefore include more samples between <code>q</code>-points that are further apart in absolute Fourier distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/Interpolation.jl#L212-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.reciprocal_space_path_bins-Tuple{Any, Any, Any, Vararg{Any}}" href="#Sunny.reciprocal_space_path_bins-Tuple{Any, Any, Any, Vararg{Any}}"><code>Sunny.reciprocal_space_path_bins</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reciprocal_space_path_bins(sc,qs,density,args...;kwargs...)</code></pre><p>Takes a list of wave vectors, <code>qs</code> in R.L.U., and builds a series of histogram <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> whose first axis traces a path through the provided points. The second and third axes are integrated over according to the <code>args</code> and <code>kwargs</code>, which are passed through to <a href="library.html#Sunny.slice_2D_binning_parameters-Tuple{Vector{Float64}, Any, Any, Int64, Any}"><code>slice_2D_binning_parameters</code></a>.</p><p>Also returned is a list of marker indices corresponding to the input points, and a list of ranges giving the indices of each histogram <code>x</code>-axis within a concatenated histogram. The <code>density</code> parameter is given in samples per reciprocal lattice unit (R.L.U.).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/Binning.jl#L320-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.reciprocal_space_shell-Tuple{Crystal, Any, Any}" href="#Sunny.reciprocal_space_shell-Tuple{Crystal, Any, Any}"><code>Sunny.reciprocal_space_shell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reciprocal_space_shell(cryst::Crystal, radius, n)</code></pre><p>Sample <code>n</code> points on the reciprocal space sphere with a given <code>radius</code> (units of inverse length).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Sample wavevectors on the sphere at fixed density
reciprocal_space_shell(cryst, r, 4π*r^2*density)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/PowderAveraging.jl#L15-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.reference_bonds-Tuple{Crystal, Float64}" href="#Sunny.reference_bonds-Tuple{Crystal, Float64}"><code>Sunny.reference_bonds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reference_bonds(cryst::Crystal, max_dist)</code></pre><p>Returns a full list of bonds, one for each symmetry equivalence class, up to distance <code>max_dist</code>. The reference bond <code>b</code> for each equivalence class is selected according to a scoring system that prioritizes simplification of the elements in <code>basis_for_symmetry_allowed_couplings(cryst, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Symmetry/SymmetryAnalysis.jl#L225-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.remove_periodicity!-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.remove_periodicity!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.remove_periodicity!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_periodicity!(sys::System, dims)</code></pre><p>Remove periodic interactions along the dimensions where <code>dims</code> is <code>true</code>. The system must support inhomogeneous interactions via <a href="library.html#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>to_inhomogeneous</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Remove periodic boundaries along the 1st and 3rd dimensions
remove_periodicity!(sys::System, (true, false, true))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/PairExchange.jl#L530-L542">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.repeat_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N" href="#Sunny.repeat_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.repeat_periodically</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">repeat_periodically(sys::System{N}, counts::NTuple{3,Int}) where N</code></pre><p>Creates a <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> identical to <code>sys</code> but repeated a given number of times in each dimension, specified by the tuple <code>counts</code>.</p><p>See also <a href="library.html#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>reshape_supercell</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Reshaping.jl#L136-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.reshape_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reshape_supercell(sys::System, shape)</code></pre><p>Maps an existing <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> to a new one that has the shape and periodicity of a requested supercell. The columns of the <span>$3×3$</span> integer matrix <code>shape</code> represent the supercell lattice vectors measured in units of the original crystal lattice vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Reshaping.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.resize_supercell-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N" href="#Sunny.resize_supercell-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.resize_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resize_supercell(sys::System{N}, latsize::NTuple{3,Int}) where N</code></pre><p>Creates a <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> with a given number of conventional unit cells in each lattice vector direction. Interactions and other settings will be inherited from <code>sys</code>.</p><p>Convenience function for:</p><pre><code class="language-julia hljs">reshape_supercell(sys, [latsize[1] 0 0; 0 latsize[2] 0; 0 0 latsize[3]])</code></pre><p>See also <a href="library.html#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>reshape_supercell</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Reshaping.jl#L118-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.rotate_operator-Tuple{LinearAlgebra.Hermitian{ComplexF64, Matrix{ComplexF64}}, Any}" href="#Sunny.rotate_operator-Tuple{LinearAlgebra.Hermitian{ComplexF64, Matrix{ComplexF64}}, Any}"><code>Sunny.rotate_operator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_operator(A, R)</code></pre><p>Rotates the local quantum operator <code>A</code> according to the <span>$3×3$</span> rotation matrix <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Operators/Rotation.jl#L145-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.rotation_in_rlu-Tuple{Crystal, Any, Any}" href="#Sunny.rotation_in_rlu-Tuple{Crystal, Any, Any}"><code>Sunny.rotation_in_rlu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotation_in_rlu(cryst::Crystal, axis, angle)</code></pre><p>Returns a <span>$3×3$</span> matrix that rotates wavevectors in reciprocal lattice units (RLU). The axis vector is a real-space direction in absolute units (but arbitrary magnitude), and the angle is in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/Interpolation.jl#L200-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_coherent!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N" href="#Sunny.set_coherent!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N"><code>Sunny.set_coherent!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_coherent!(sys::System, Z, site::Site)</code></pre><p>Set a coherent spin state at a <a href="library.html#Sunny.Site"><code>Site</code></a> using the <span>$N$</span> complex amplitudes in <code>Z</code>.</p><p>For a standard <a href="library.html#Sunny.SpinInfo"><code>SpinInfo</code></a>, these amplitudes will be interpreted in the eigenbasis of <span>$𝒮̂ᶻ$</span>. That is, <code>Z[1]</code> represents the amplitude for the basis state fully polarized along the <span>$ẑ$</span>-direction, and subsequent components represent states with decreasing angular momentum along this axis (<span>$m = S, S-1, …, -S$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/System.jl#L506-L517">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_dipole!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N" href="#Sunny.set_dipole!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N"><code>Sunny.set_dipole!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_dipole!(sys::System, dir, site::Site)</code></pre><p>Polarize the spin at a <a href="library.html#Sunny.Site"><code>Site</code></a> along the direction <code>dir</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/System.jl#L526-L530">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N" href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_exchange!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_exchange!(sys::System, J, bond::Bond)</code></pre><p>Sets a 3×3 spin-exchange matrix <code>J</code> along <code>bond</code>, yielding a pairwise interaction energy <span>$𝐒_i⋅J 𝐒_j$</span>. This interaction will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous interactions on these bonds will be overwritten. The parameter <code>bond</code> has the form <code>Bond(i, j, offset)</code>, where <code>i</code> and <code>j</code> are atom indices within the unit cell, and <code>offset</code> is a displacement in unit cells.</p><p>The parameter <code>J</code> may be scalar or matrix-valued. As a convenience, <code>dmvec(D)</code> can be used to construct the antisymmetric part of the exchange, where <code>D</code> is the Dzyaloshinskii-Moriya pseudo-vector. The resulting interaction will be <span>$𝐃⋅(𝐒_i×𝐒_j)$</span>.</p><p>For more general interactions, such as biquadratic, use <a href="library.html#Sunny.set_pair_coupling!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Any}} where N"><code>set_pair_coupling!</code></a> instead. In the special that <code>sys</code> has <code>mode = :dipole_large_S</code>, this function will accept an optional named parameter <code>biquad</code> yielding scalar biquadratic interactions <code>(𝐒_i⋅𝐒_j)^2</code> <em>without</em> renormalization.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># An explicit exchange matrix
J1 = [2 3 0;
     -3 2 0;
      0 0 2]
set_exchange!(sys, J1, bond)

# An equivalent Heisenberg + DM exchange 
J2 = 2*I + dmvec([0,0,3])
set_exchange!(sys, J2, bond)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/PairExchange.jl#L318-L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N" href="#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>Sunny.set_exchange_at!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_exchange_at!(sys::System, J, site1::Site, site2::Site; offset=nothing)</code></pre><p>Sets an exchange interaction `<code>𝐒_i⋅J 𝐒_j</code> along the single bond connecting two <a href="library.html#Sunny.Site"><code>Site</code></a>s, ignoring crystal symmetry. Any previous coupling on this bond will be overwritten. The system must support inhomogeneous interactions via <a href="library.html#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>to_inhomogeneous</code></a>.</p><p>Use <a href="library.html#Sunny.symmetry_equivalent_bonds-Tuple{System, Bond}"><code>symmetry_equivalent_bonds</code></a> to find <code>(site1, site2, offset)</code> values that are symmetry equivalent to a given <a href="library.html#Sunny.Bond"><code>Bond</code></a> in the original system. For systems that are relatively small, the <code>offset</code> vector (in multiples of unit cells) will resolve ambiguities in the periodic wrapping.</p><p>For more general interactions, such as biquadratic, use <a href="library.html#Sunny.set_pair_coupling_at!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>set_pair_coupling_at!</code></a> instead. In the special that <code>sys</code> has <code>mode = :dipole_large_S</code>, this function will accept an optional named parameter <code>biquad</code> yielding scalar biquadratic interactions <code>(𝐒_i⋅𝐒_j)^2</code> <em>without</em> renormalization.</p><p>See also <a href="library.html#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_exchange!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/PairExchange.jl#L443-L463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_external_field!-Tuple{System, Any}" href="#Sunny.set_external_field!-Tuple{System, Any}"><code>Sunny.set_external_field!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_external_field!(sys::System, B::Vec3)</code></pre><p>Sets the external field <span>$𝐁$</span> that couples to all magnetic moments, <span>$- ∑_i 𝐁⋅μ_i$</span>. See <a href="library.html#Sunny.magnetic_moment-Tuple{System, Any}"><code>magnetic_moment</code></a> for the relationship between <span>$μ_i$</span> and the spin angular momentum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/Interactions.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_external_field_at!-Tuple{System, Any, Any}" href="#Sunny.set_external_field_at!-Tuple{System, Any, Any}"><code>Sunny.set_external_field_at!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_external_field_at!(sys::System, B::Vec3, site::Site)</code></pre><p>Sets a local field <span>$𝐁$</span> that couples to a single magnetic moment, <span>$-𝐁⋅μ_i$</span>. See <a href="library.html#Sunny.magnetic_moment-Tuple{System, Any}"><code>magnetic_moment</code></a> for the relationship between <span>$μ_i$</span> and the spin angular momentum. <a href="library.html#Sunny.Site"><code>Site</code></a> includes a unit cell and a sublattice index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/Interactions.jl#L99-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_onsite_coupling!-Tuple{System, Any, Int64}" href="#Sunny.set_onsite_coupling!-Tuple{System, Any, Int64}"><code>Sunny.set_onsite_coupling!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_onsite_coupling!(sys::System, op, i::Int)</code></pre><p>Set the single-ion anisotropy for the <code>i</code>th atom of every unit cell, as well as all symmetry-equivalent atoms. The operator <code>op</code> may be provided as an abstract function of the local spin operators, as a polynomial of <a href="library.html#Sunny.spin_matrices-Tuple{Any}"><code>spin_matrices</code></a>, or as a linear combination of <a href="library.html#Sunny.stevens_matrices-Tuple{Any}"><code>stevens_matrices</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># An easy axis anisotropy in the z-direction
set_onsite_coupling!(sys, S -&gt; -D*S[3]^3, i)

# The unique quartic single-ion anisotropy for a site with cubic point group
# symmetry
set_onsite_coupling!(sys, S -&gt; 20*(S[1]^4 + S[2]^4 + S[3]^4), i)

# An equivalent expression of this quartic anisotropy, up to a constant shift
O = stevens_matrices(spin_label(sys, i))
set_onsite_coupling!(sys, O[4,0] + 5*O[4,4], i)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/OnsiteCoupling.jl#L90-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_onsite_coupling_at!-Tuple{System, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}}" href="#Sunny.set_onsite_coupling_at!-Tuple{System, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}}"><code>Sunny.set_onsite_coupling_at!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_onsite_coupling_at!(sys::System, op, site::Site)</code></pre><p>Sets the single-ion anisotropy operator <code>op</code> for a single <a href="library.html#Sunny.Site"><code>Site</code></a>, ignoring crystal symmetry.  The system must support inhomogeneous interactions via <a href="library.html#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>to_inhomogeneous</code></a>.</p><p>See also <a href="library.html#Sunny.set_onsite_coupling!-Tuple{System, Any, Int64}"><code>set_onsite_coupling!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/OnsiteCoupling.jl#L164-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_pair_coupling!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Any}} where N" href="#Sunny.set_pair_coupling!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Any}} where N"><code>Sunny.set_pair_coupling!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_pair_coupling!(sys::System, op, bond)</code></pre><p>Sets an arbitrary coupling <code>op</code> along <code>bond</code>. This coupling will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous interactions on these bonds will be overwritten. The parameter <code>bond</code> has the form <code>Bond(i, j, offset)</code>, where <code>i</code> and <code>j</code> are atom indices within the unit cell, and <code>offset</code> is a displacement in unit cells. The operator <code>op</code> may be provided as an anonymous function that accepts two spin dipole operators, or as a matrix that acts in the tensor product space of the two sites.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Bilinear+biquadratic exchange involving 3×3 matrices J1 and J2
set_pair_coupling!(sys, (Si, Sj) -&gt; Si&#39;*J1*Sj + (Si&#39;*J2*Sj)^2, bond)

# Equivalent expression using an appropriate fixed matrix representation
S = spin_matrices(1/2)
Si, Sj = to_product_space(S, S)
set_pair_coupling!(sys, Si&#39;*J1*Sj + (Si&#39;*J2*Sj)^2, bond)</code></pre><p>See also <a href="library.html#Sunny.spin_matrices-Tuple{Any}"><code>spin_matrices</code></a>, <a href="library.html#Sunny.to_product_space-Tuple{Any, Any, Vararg{Any}}"><code>to_product_space</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/PairExchange.jl#L264-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_pair_coupling_at!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N" href="#Sunny.set_pair_coupling_at!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>Sunny.set_pair_coupling_at!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_pair_coupling_at!(sys::System, op, bond)</code></pre><p>Sets an arbitrary coupling along the single bond connecting two <a href="library.html#Sunny.Site"><code>Site</code></a>s, ignoring crystal symmetry. Any previous coupling on this bond will be overwritten. The system must support inhomogeneous interactions via <a href="library.html#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>to_inhomogeneous</code></a>.</p><p>Use <a href="library.html#Sunny.symmetry_equivalent_bonds-Tuple{System, Bond}"><code>symmetry_equivalent_bonds</code></a> to find <code>(site1, site2, offset)</code> values that are symmetry equivalent to a given <a href="library.html#Sunny.Bond"><code>Bond</code></a> in the original system. For systems that are relatively small, the <code>offset</code> vector (in multiples of unit cells) will resolve ambiguities in the periodic wrapping.</p><p>The operator <code>op</code> may be provided as an anonymous function that accepts two spin dipole operators, or as a matrix that acts in the tensor product space of the two sites. The documentation for <a href="library.html#Sunny.set_pair_coupling!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Any}} where N"><code>set_pair_coupling!</code></a> provides examples constructing <code>op</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/PairExchange.jl#L486-L503">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_spin_rescaling!-Tuple{System{0}, Any}" href="#Sunny.set_spin_rescaling!-Tuple{System{0}, Any}"><code>Sunny.set_spin_rescaling!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_spin_rescaling!(sys, α)</code></pre><p>In dipole mode, rescale all spin magnitudes <span>$S → α S$</span>. In SU(N) mode, rescale all SU(N) coherent states <span>$Z → √α Z$</span> such that every expectation value rescales like <span>$⟨A⟩ → α ⟨A⟩$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/System.jl#L547-L553">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_spiral_order!-Tuple{Any}" href="#Sunny.set_spiral_order!-Tuple{Any}"><code>Sunny.set_spiral_order!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_spiral_order!(sys; k, axis, S0)</code></pre><p>Initializes the system with a spiral order described by the wavevector <code>k</code>, an axis of rotation <code>axis</code>, and an initial dipole direction <code>S0</code> at the real-space origin. The wavevector is expected in repicrocal lattice units (RLU), while the direction vectors <code>axis</code> and <code>S0</code> are expected in global Cartesian coordinates.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Spiral order for a wavevector propagating in the direction of the first
# reciprocal lattice vector (i.e., orthogonal to the lattice vectors ``𝐚_2``
# and ``𝐚_3``), repeating with a period of 3 lattice constants, and spiraling
# about the ``ẑ``-axis. The spin at the origin will point in the direction
# ``𝐒_0 = ŷ + ẑ``.  Here, ``(x̂, ŷ, ẑ)`` are the axes of Cartesian coordinate
# system in the global frame.
set_spiral_order!(sys; k=[1/3, 0, 0], axis=[0, 0, 1], S0=[0, 1, 1])</code></pre><p>See also <a href="library.html#Sunny.set_spiral_order_on_sublattice!-Tuple{Any, Any}"><code>set_spiral_order_on_sublattice!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/MagneticOrdering.jl#L241-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_spiral_order_on_sublattice!-Tuple{Any, Any}" href="#Sunny.set_spiral_order_on_sublattice!-Tuple{Any, Any}"><code>Sunny.set_spiral_order_on_sublattice!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_spiral_order_on_sublattice!(sys, i; k, axis, S0)</code></pre><p>Initializes sublattice <code>i</code> with a spiral order described by the wavevector <code>k</code>, an axis of rotation <code>axis</code>, and an initial dipole direction <code>S0</code>. The phase is selected such that the spin at <code>sys.dipole[1,1,1,i]</code> will point in the direction of <code>S0</code>. The wavevector is expected in repicrocal lattice units (RLU), while the direction vectors <code>axis</code> and <code>S0</code> are expected in global Cartesian coordinates.</p><p>This function is not available for systems with reshaped unit cells.</p><p>See also <a href="library.html#Sunny.set_spiral_order!-Tuple{Any}"><code>set_spiral_order!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/MagneticOrdering.jl#L277-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.set_vacancy_at!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_vacancy_at!(sys::System, site::Site)</code></pre><p>Make a single site nonmagnetic. <a href="library.html#Sunny.Site"><code>Site</code></a> includes a unit cell and a sublattice index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/Interactions.jl#L110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.slice_2D_binning_parameters-Tuple{Vector{Float64}, Any, Any, Int64, Any}" href="#Sunny.slice_2D_binning_parameters-Tuple{Vector{Float64}, Any, Any, Int64, Any}"><code>Sunny.slice_2D_binning_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slice_2D_binning_parameter(sc::SampledCorrelations, cut_from_q, cut_to_q, cut_bins::Int64, cut_width::Float64; plane_normal = [0,0,1],cut_height = cutwidth)</code></pre><p>Creates <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> which make a cut along one dimension of Q-space.</p><p>The x-axis of the resulting histogram consists of <code>cut_bins</code>-many bins ranging from <code>cut_from_q</code> to <code>cut_to_q</code>.  The width of the bins in the transverse direciton is controlled by <code>cut_width</code> and <code>cut_height</code>.</p><p>The binning in the transverse directions is defined in the following way, which sets their normalization and orthogonality properties:</p><pre><code class="nohighlight hljs">cut_covector = normalize(cut_to_q - cut_from_q)
transverse_covector = normalize(plane_normal × cut_covector)
cotransverse_covector = normalize(transverse_covector × cut_covector)</code></pre><p>In other words, the axes are orthonormal with respect to the Euclidean metric.</p><p>If the cut is too narrow, there will be very few scattering vectors per bin, or the number per bin will vary substantially along the cut. If the output appears under-resolved, try increasing <code>cut_width</code>.</p><p>The four axes of the resulting histogram are:</p><ol><li>Along the cut</li><li>Fist transverse Q direction</li><li>Second transverse Q direction</li><li>Energy</li></ol><p>This function can be used without reference to a <a href="library.html#Sunny.SampledCorrelations"><code>SampledCorrelations</code></a> using this alternate syntax to manually specify the bin centers for the energy axis:</p><pre><code class="nohighlight hljs">slice_2D_binning_parameter(ω_bincenters, cut_from, cut_to,...)</code></pre><p>where <code>ω_bincenters</code> specifies the energy axis, and both <code>cut_from</code> and <code>cut_to</code> are arbitrary covectors, in any units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/Binning.jl#L227-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.spin_label-Tuple{System, Int64}" href="#Sunny.spin_label-Tuple{System, Int64}"><code>Sunny.spin_label</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spin_label(sys::System, i::Int)</code></pre><p>If atom <code>i</code> carries a single spin-<span>$S$</span> moment, then returns the half-integer label <span>$S$</span>. Otherwise, throws an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/System.jl#L200-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.spin_matrices-Tuple{Any}" href="#Sunny.spin_matrices-Tuple{Any}"><code>Sunny.spin_matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spin_matrices(S)</code></pre><p>Returns a triple of <span>$N×N$</span> spin matrices, where <span>$N = 2S+1$</span>. These are the generators of SU(2) in the spin-<code>S</code> representation.</p><p>If <code>S == Inf</code>, then the return values are abstract symbols denoting infinite-dimensional matrices that commute. These can be useful for repeating historical studies, or modeling micromagnetic systems. A technical discussion appears in the Sunny documentation page: <a href="renormalization.html#Interaction-Strength-Renormalization">Interaction Strength Renormalization</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">S = spin_matrices(3/2)
@assert S&#39;*S ≈ (3/2)*(3/2+1)*I
@assert S[1]*S[2] - S[2]*S[1] ≈ im*S[3]

S = spin_matrices(Inf)
@assert S[1]*S[2] - S[2]*S[1] == 0</code></pre><p>See also <a href="library.html#Sunny.print_stevens_expansion-Tuple{AbstractMatrix}"><code>print_stevens_expansion</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Operators/Spin.jl#L17-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.step!" href="#Sunny.step!"><code>Sunny.step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">step!(sys::System, dynamics)</code></pre><p>Advance the spin configuration one dynamical time-step. The <code>dynamics</code> object may be a continuous spin dynamics, such as <a href="library.html#Sunny.Langevin"><code>Langevin</code></a> or <a href="library.html#Sunny.ImplicitMidpoint"><code>ImplicitMidpoint</code></a>, or it may be a discrete Monte Carlo sampling scheme such as <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Integrators.jl#L296-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.stevens_matrices-Tuple{Any}" href="#Sunny.stevens_matrices-Tuple{Any}"><code>Sunny.stevens_matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stevens_matrices(S)</code></pre><p>Returns a generator of Stevens operators in the spin-<code>S</code> representation. The return value <code>O</code> can be indexed as <code>O[k,q]</code>, where <span>$0 ≤ k ≤ 6$</span> labels an irrep of SO(3) and <span>$-k ≤ q ≤ k$</span>. This will produce an <span>$N×N$</span> matrix where ``N = 2S</p><ul><li>1``. Linear combinations of Stevens operators can be used as a &quot;physical</li></ul><p>basis&quot; for decomposing local observables. To see this decomposition, use <a href="library.html#Sunny.print_stevens_expansion-Tuple{AbstractMatrix}"><code>print_stevens_expansion</code></a>.</p><p>If <code>S == Inf</code>, then symbolic operators will be returned. In this infinite dimensional limit, the Stevens operators become homogeneous polynomials of commuting spin operators.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">O = stevens_matrices(2)
S = spin_matrices(2)

A = (1/20)O[4,0] + (1/4)O[4,4] + (102/5)I
B = S[1]^4 + S[2]^4 + S[3]^4
@assert A ≈ B</code></pre><p>See also <a href="library.html#Sunny.spin_matrices-Tuple{Any}"><code>spin_matrices</code></a> and <a href="renormalization.html#Interaction-Strength-Renormalization">Interaction Strength Renormalization</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Operators/Stevens.jl#L225-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N" href="#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N"><code>Sunny.subcrystal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subcrystal(cryst, types) :: Crystal</code></pre><p>Filters sublattices of a <code>Crystal</code> by atom <code>types</code>, keeping the space group unchanged.</p><pre><code class="nohighlight hljs">subcrystal(cryst, classes) :: Crystal</code></pre><p>Filters sublattices of <code>Crystal</code> by equivalence <code>classes</code>, keeping the space group unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Symmetry/Crystal.jl#L533-L543">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.suggest_magnetic_supercell-Tuple{Any}" href="#Sunny.suggest_magnetic_supercell-Tuple{Any}"><code>Sunny.suggest_magnetic_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">suggest_magnetic_supercell(ks; tol=1e-12, maxsize=100)</code></pre><p>Suggests a magnetic supercell, in units of the crystal lattice vectors, that is consistent with periodicity of the wavevectors <code>ks</code> in RLU. If the wavevectors are incommensurate (with respect to the maximum supercell size <code>maxsize</code>), one can select a larger error tolerance <code>tol</code> to find a supercell that is almost commensurate.</p><p>Prints a <span>$3×3$</span> matrix of integers that is suitable for use in <a href="library.html#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>reshape_supercell</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># A magnetic supercell for a single-Q structure. Will print
k1 = [0, -1/4, 1/4]
suggest_magnetic_supercell([k1])       # [1 0 0; 0 2 1; 0 -2 1]

# A larger magnetic supercell for a double-Q structure
k2 = [1/4, 0, 1/4]
suggest_magnetic_supercell([k1, k2])   # [1 2 2; -1 2 -2; -1 2 2]

# If given incommensurate wavevectors, find an approximate supercell that
# is exactly commensurate for nearby wavevectors.
suggest_magnetic_supercell([[0, 0, 1/√5], [0, 0, 1/√7]]; tol=1e-2)

# This prints [1 0 0; 0 1 0; 0 0 16], which becomes commensurate under the
# approximations `1/√5 ≈ 7/16` and `1/√7 ≈ 3/8`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/MagneticOrdering.jl#L71-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.suggest_timestep-Union{Tuple{N}, Tuple{System{N}, Union{ImplicitMidpoint, Langevin}}} where N" href="#Sunny.suggest_timestep-Union{Tuple{N}, Tuple{System{N}, Union{ImplicitMidpoint, Langevin}}} where N"><code>Sunny.suggest_timestep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">suggest_timestep(sys, integrator; tol)</code></pre><p>Suggests a timestep for the numerical integration of spin dynamics according to a given error tolerance <code>tol</code>. The <code>integrator</code> should be <a href="library.html#Sunny.Langevin"><code>Langevin</code></a> or <a href="library.html#Sunny.ImplicitMidpoint"><code>ImplicitMidpoint</code></a>. The suggested <span>$dt$</span> will be inversely proportional to the magnitude of the effective field <span>$|dE/d𝐬|$</span> arising from the current spin configuration in <code>sys</code>. The recommended timestep <span>$dt$</span> scales like <code>√tol</code>, which assumes second-order accuracy of the integrator.</p><p>The system <code>sys</code> should be initialized to an equilibrium spin configuration for the target temperature. Alternatively, a reasonably timestep estimate can be obtained from any low-energy spin configuration. For this, one can use <a href="library.html#Sunny.randomize_spins!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>randomize_spins!</code></a> and then <a href="library.html#Sunny.minimize_energy!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>minimize_energy!</code></a>.</p><p>Large <code>damping</code> magnitude or target temperature <code>kT</code> will tighten the timestep bound. If <code>damping</code> exceeds 1, it will rescale the suggested timestep by an approximate the factor <span>$1/damping$</span>. If <code>kT</code> is the largest energy scale, then the suggested timestep will scale like <code>1/(damping*kT)</code>. Quantification of numerical error for stochastic dynamics is subtle. The stochastic Heun integration scheme is weakly convergent of order-1, such that errors in the estimates of averaged observables may scale like <code>dt</code>. This implies that the <code>tol</code> argument may actually scale like the <em>square</em> of the true numerical error, and should be selected with this in mind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Integrators.jl#L134-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.symmetry_equivalent_bonds-Tuple{System, Bond}" href="#Sunny.symmetry_equivalent_bonds-Tuple{System, Bond}"><code>Sunny.symmetry_equivalent_bonds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetry_equivalent_bonds(sys::System, bond::Bond)</code></pre><p>Given a <a href="library.html#Sunny.Bond"><code>Bond</code></a> for the original (unreshaped) crystal, return all symmetry equivalent bonds in the <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a>. Each returned bond is represented as a pair of <a href="library.html#Sunny.Site"><code>Site</code></a>s, which may be used as input to <a href="library.html#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>set_exchange_at!</code></a> or <a href="library.html#Sunny.set_pair_coupling_at!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>set_pair_coupling_at!</code></a>. Reverse bonds are not included in the iterator (no double counting).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">for (site1, site2, offset) in symmetry_equivalent_bonds(sys, bond)
    @assert site1 &lt; site2
    set_exchange_at!(sys, J, site1, site2; offset)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/System.jl#L347-L363">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.to_inhomogeneous</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_inhomogeneous(sys::System)</code></pre><p>Returns a copy of the system that allows for inhomogeneous interactions, which can be set using <a href="library.html#Sunny.set_onsite_coupling_at!-Tuple{System, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}}"><code>set_onsite_coupling_at!</code></a>, <a href="library.html#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>set_exchange_at!</code></a>, and <a href="library.html#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>set_vacancy_at!</code></a>.</p><p>Inhomogeneous systems do not support symmetry-propagation of interactions or system reshaping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/System/Interactions.jl#L39-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.to_product_space-Tuple{Any, Any, Vararg{Any}}" href="#Sunny.to_product_space-Tuple{Any, Any, Vararg{Any}}"><code>Sunny.to_product_space</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_product_space(A, B, ...)</code></pre><p>Given lists of operators acting on local Hilbert spaces individually, return the corresponding operators that act on the tensor product space. In typical usage, the inputs will represent local physical observables and the outputs will be used to define quantum couplings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Operators/TensorOperators.jl#L86-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.unit_resolution_binning_parameters-Tuple{Any, Any, Vararg{Any}}" href="#Sunny.unit_resolution_binning_parameters-Tuple{Any, Any, Vararg{Any}}"><code>Sunny.unit_resolution_binning_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unit_resolution_binning_parameters(sc::SampledCorrelations)</code></pre><p>Create <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> which place one histogram bin centered at each possible <code>(q,ω)</code> scattering vector of the crystal. This is the finest possible binning without creating bins with zero scattering vectors in them.</p><p>This function can be used without reference to a <a href="library.html#Sunny.SampledCorrelations"><code>SampledCorrelations</code></a> using an alternate syntax to manually specify the bin centers for the energy axis and the lattice size:</p><pre><code class="nohighlight hljs">unit_resolution_binning_parameters(ω_bincenters,latsize,[reciprocal lattice vectors])</code></pre><p>The last argument may be a 3x3 matrix specifying the reciprocal lattice vectors, or a <a href="library.html#Sunny.Crystal"><code>Crystal</code></a>.</p><p>Lastly, binning parameters for a single axis may be specifed by their bin centers:</p><pre><code class="nohighlight hljs">(binstart,binend,binwidth) = unit_resolution_binning_parameters(bincenters::Vector{Float64})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/Intensities/Binning.jl#L169-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.@mix_proposals-Tuple" href="#Sunny.@mix_proposals-Tuple"><code>Sunny.@mix_proposals</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@mix_proposals weight1 propose1 weight2 propose2 ...</code></pre><p>Macro to generate a proposal function that randomly selects among the provided functions according to the provided probability weights. For use with <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># A proposal function that proposes a spin flip 40% of the time, and a
# Gaussian perturbation 60% of the time.
@mix_proposals 0.4 propose_flip 0.6 propose_delta(0.2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/src/MonteCarlo/Samplers.jl#L56-L69">source</a></section></article><h2 id="Optional-Makie-extensions"><a class="docs-heading-anchor" href="#Optional-Makie-extensions">Optional Makie extensions</a><a id="Optional-Makie-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-Makie-extensions" title="Permalink"></a></h2><p>The following will be enabled through a package extension if either <code>GLMakie</code> or <code>WGLMakie</code> is loaded.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.plot_spins" href="#Sunny.plot_spins"><code>Sunny.plot_spins</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_spins(sys::System; arrowscale=1.0, color=:red, colorfn=nothing,
           colormap=:viridis, colorrange=nothing, show_cell=true, orthographic=false,
           ghost_radius=0, dims=3, compass=true)</code></pre><p>Plot the spin configuration defined by <code>sys</code>. Optional parameters are:</p><ul><li><code>arrowscale</code>: Scale all arrows by dimensionless factor.</li><li><code>color</code>: Arrow colors. May be symbolic or numeric. If scalar, will be shared among all sites.</li><li><code>colorfn</code>: Function that dynamically maps from a site index to a numeric color value. Useful for animations.</li><li><code>colormap</code>, <code>colorrange</code>: Used to populate colors from numbers following Makie conventions.</li><li><code>show_cell</code>: Show original crystallographic unit cell.</li><li><code>orthographic</code>: Use orthographic camera perspective.</li><li><code>ghost_radius</code>: Show periodic images up to a given distance (length units).</li><li><code>dims</code>: Spatial dimensions of system (1, 2, or 3).</li><li><code>compass</code>: If true, draw Cartesian axes in bottom left.</li></ul><p>Calling <code>notify</code> on the return value will animate the figure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/ext/PlottingExt.jl#L835-L856">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.view_crystal" href="#Sunny.view_crystal"><code>Sunny.view_crystal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">view_crystal(crystal::Crystal; refbonds=10, orthographic=false, ghost_radius=nothing, dims=3, compass=true)
view_crystal(sys::System; ...)</code></pre><p>Launches a graphical user interface to visualize the <a href="library.html#Sunny.Crystal"><code>Crystal</code></a> unit cell. If a <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> is provided, then the 3×3 exchange matrices for each bond will be depicted graphically.</p><ul><li><code>refbonds</code>: By default, calculate up to 10 reference bonds using the <code>reference_bonds</code> function. An explicit list of reference bonds may also be provided.</li><li><code>orthographic</code>: Use orthographic camera perspective.</li><li><code>ghost_radius</code>: Show periodic images up to a given distance. Defaults to the cell size.</li><li><code>dims</code>: Spatial dimensions of system (1, 2, or 3).</li><li><code>compass</code>: If true, draw Cartesian axes in bottom left.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/ext/PlottingExt.jl#L663-L679">source</a></section></article><h2 id="Optional-WriteVTK-extensions"><a class="docs-heading-anchor" href="#Optional-WriteVTK-extensions">Optional WriteVTK extensions</a><a id="Optional-WriteVTK-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-WriteVTK-extensions" title="Permalink"></a></h2><p>The following will be enabled through a package extension if <code>WriteVTK</code> is loaded.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.export_vtk" href="#Sunny.export_vtk"><code>Sunny.export_vtk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">export_vtk(filename,params::BinningParameters,data)</code></pre><p>Export a VTK-compatible file to <code>filename</code> (do not include file extension when specifying the file name) which contains the <code>data</code> as VTK Cell Data on a grid parameterized by <code>params</code>.</p><p>At least one axis of the <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> must be integrated over, since VTK does not support 4D data. See <a href="library.html#Sunny.integrate_axes!-Tuple{BinningParameters}"><code>integrate_axes!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/48da5a38f8074ae05b09f5f9c8127fe8d7727d86/ext/ExportVTKExt.jl#L59-L68">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="renormalization.html">« Interaction Strength Renormalization</a><a class="docs-footer-nextpage" href="versions.html">Version History »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 3 June 2024 04:03">Monday 3 June 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
