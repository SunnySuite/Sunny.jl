<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4. Generalized spin dynamics of FeI‚ÇÇ at finite T ¬∑ Sunny documentation</title><meta name="title" content="4. Generalized spin dynamics of FeI‚ÇÇ at finite T ¬∑ Sunny documentation"/><meta property="og:title" content="4. Generalized spin dynamics of FeI‚ÇÇ at finite T ¬∑ Sunny documentation"/><meta property="twitter:title" content="4. Generalized spin dynamics of FeI‚ÇÇ at finite T ¬∑ Sunny documentation"/><meta name="description" content="Documentation for Sunny documentation."/><meta property="og:description" content="Documentation for Sunny documentation."/><meta property="twitter:description" content="Documentation for Sunny documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="Sunny documentation logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Sunny documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Sunny documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Overview</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="01_LSWT_SU3_FeI2.html">1. Multi-flavor spin wave simulations of FeI‚ÇÇ (Showcase)</a></li><li><a class="tocitem" href="02_LSWT_CoRh2O4.html">2. Spin wave simulations of CoRh‚ÇÇO‚ÇÑ</a></li><li><a class="tocitem" href="03_LLD_CoRh2O4.html">3. Landau-Lifshitz dynamics of CoRh‚ÇÇO‚ÇÑ at finite <em>T</em></a></li><li class="is-active"><a class="tocitem" href="04_GSD_FeI2.html">4. Generalized spin dynamics of FeI‚ÇÇ at finite <em>T</em></a><ul class="internal"><li><a class="tocitem" href="#Finding-a-ground-state"><span>Finding a ground state</span></a></li><li><a class="tocitem" href="#Calculating-Thermal-Averaged-Correlations-\\langle-S{\\alpha\\beta}(ùê™,œâ)\\rangle"><span>Calculating Thermal-Averaged Correlations <span>$\langle S^{\alpha\beta}(ùê™,œâ)\rangle$</span></span></a></li><li><a class="tocitem" href="#Computing-Scattering-Intensities"><span>Computing Scattering Intensities</span></a></li><li class="toplevel"><a class="tocitem" href="#Unconventional-RLU-Systems-and-Constant-Energy-Cuts"><span>Unconventional RLU Systems and Constant Energy Cuts</span></a></li></ul></li><li><a class="tocitem" href="05_MC_Ising.html">5. Monte Carlo sampling of the Ising model</a></li><li><a class="tocitem" href="06_CP2_Skyrmions.html">6. Dynamical quench into CP¬≤ skyrmion liquid</a></li><li><a class="tocitem" href="07_Dipole_Dipole.html">7. Long-range dipole interactions</a></li><li><input class="collapse-toggle" id="menuitem-2-8" type="checkbox"/><label class="tocitem" for="menuitem-2-8"><span class="docs-label">SpinW tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="spinw/SW08_Kagome_AFM.html">SW8 - Kagome Antiferromagnet</a></li><li><a class="tocitem" href="spinw/SW15_Ba3NbFe3Si2O14.html">SW15 - Ba‚ÇÉNbFe‚ÇÉSi‚ÇÇO‚ÇÅ‚ÇÑ</a></li><li><a class="tocitem" href="spinw/SW18_Distorted_kagome.html">SW18 - Distorted kagome</a></li><li><a class="tocitem" href="spinw/SW19_Different_Ions.html">SW19 - Different magnetic ions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-9" type="checkbox"/><label class="tocitem" for="menuitem-2-9"><span class="docs-label">Contributed</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="contributed/MgCr2O4-tutorial.html">MgCr2O4 at Finite Temperature</a></li><li><a class="tocitem" href="contributed/kappa_tutorial.html">Enforcing the quantum sum rule with moment renormalization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-10" type="checkbox"/><label class="tocitem" for="menuitem-2-10"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../parallelism.html">Parallelizing Calculations</a></li><li><a class="tocitem" href="../writevtk.html">ParaView Rendering</a></li></ul></li></ul></li><li><span class="tocitem">Modeling Guides</span><ul><li><a class="tocitem" href="../structure-factor.html">Structure Factor Calculations</a></li><li><a class="tocitem" href="../renormalization.html">Interaction Strength Renormalization</a></li></ul></li><li><a class="tocitem" href="../library.html">Library API</a></li><li><a class="tocitem" href="../versions.html">Version History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href="04_GSD_FeI2.html">4. Generalized spin dynamics of FeI‚ÇÇ at finite <em>T</em></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="04_GSD_FeI2.html">4. Generalized spin dynamics of FeI‚ÇÇ at finite <em>T</em></a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SunnySuite/Sunny.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SunnySuite/Sunny.jl/blob/main/examples/04_GSD_FeI2.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>Download this example as <a href="../assets/notebooks/04_GSD_FeI2.ipynb">Jupyter notebook</a> or <a href="../assets/scripts/04_GSD_FeI2.jl">Julia script</a>.</p><h1 id="4.-Generalized-spin-dynamics-of-FeI-at-finite-*T*"><a class="docs-heading-anchor" href="#4.-Generalized-spin-dynamics-of-FeI-at-finite-*T*">4. Generalized spin dynamics of FeI‚ÇÇ at finite <em>T</em></a><a id="4.-Generalized-spin-dynamics-of-FeI-at-finite-*T*-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Generalized-spin-dynamics-of-FeI-at-finite-*T*" title="Permalink"></a></h1><pre><code class="language-julia hljs">using Sunny, LinearAlgebra, GLMakie</code></pre><p>In the <a href="01_LSWT_SU3_FeI2.html#1.-Multi-flavor-spin-wave-simulations-of-FeI-(Showcase)">previous FeI‚ÇÇ tutorial</a>, we used multi-flavor spin wave theory to calculate the dynamical structure factor. Here, we perform a similar calculation using a <a href="https://arxiv.org/abs/2209.01265">generalized classical spin dynamics</a> that captures the coupled dynamics of spin dipoles and quadrupoles for configurations sampled at finite temperature.</p><p>Compared to spin wave theory, simulations using classical dynamics will be slower and limited in <span>$k$</span>-space resolution. However, they make it is possible to study <a href="https://arxiv.org/abs/2310.19905">temperature driven phase transitions</a>. They may also be used to study out-of-equilibrium systems (e.g., relaxation of spin glasses), or systems with quenched inhomogeneities that require large simulation volumes.</p><p>In this tutorial, we show how to study the finite temperature dynamics of FeI‚ÇÇ using the classical approach. It is important to stress that the estimation of <span>$S(ùê™,œâ)$</span> with classical dynamics is fundamentally a Monte Carlo calculation: sample spin configurations are drawn from thermal equilibrium and used as initial conditions for generating dissipationless trajectories. The correlations of these trajectories are then averaged and used to calculate scattering intensities. It is therefore important to ensure that the initial spin configurations are sampled appropriately and that sufficient statistics are collected. We will demonstrate one approach here.</p><p>As an overview, we will:</p><ol><li>Identify the ground state.</li><li>Measure correlation data describing the excitations around that ground state.</li><li>Use the correlation data to compute scattering intensities.</li></ol><p>To begin, please follow our <a href="01_LSWT_SU3_FeI2.html#1.-Multi-flavor-spin-wave-simulations-of-FeI-(Showcase)">previous tutorial</a> to initialize a FeI‚ÇÇ <code>sys</code> with lattice dimensions <span>$4√ó4√ó4$</span>.</p><pre><code class="language-julia hljs">sys</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr4"><span class="sgr1">System [SU(3)]</span></span>
Lattice (4√ó4√ó4)√ó1
Energy per site -353/250
</code></pre><h2 id="Finding-a-ground-state"><a class="docs-heading-anchor" href="#Finding-a-ground-state">Finding a ground state</a><a id="Finding-a-ground-state-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-a-ground-state" title="Permalink"></a></h2><p>As <a href="01_LSWT_SU3_FeI2.html#1.-Multi-flavor-spin-wave-simulations-of-FeI-(Showcase)">previously observed</a>, direct energy minimization is susceptible to trapping in a local energy minimum.</p><pre><code class="language-julia hljs">randomize_spins!(sys)
minimize_energy!(sys)
plot_spins(sys; color=[s[3] for s in sys.dipoles])</code></pre><img src="04_GSD_FeI2-33c94cf5.png" alt="Example block output"/><p>Alternatively, one can search for the ordered state by sampling spin configurations from thermal equilibrium. Sunny supports this via a <a href="../library.html#Sunny.Langevin"><code>Langevin</code></a> dynamics of SU(<em>N</em>) coherent states. This dynamics involves a dimensionless <code>damping</code> magnitude and target temperature <code>kT</code> for thermal fluctuations.</p><pre><code class="language-julia hljs">kT = 0.2  # Temperature in meV
langevin = Langevin(; damping=0.2, kT)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Langevin(&lt;missing&gt;; damping=0.2, kT=0.2)
</code></pre><p>Use <a href="../library.html#Sunny.suggest_timestep-Union{Tuple{N}, Tuple{System{N}, Union{ImplicitMidpoint, Langevin}}} where N"><code>suggest_timestep</code></a> to select an integration timestep for the given error tolerance, e.g. <code>tol=1e-2</code>. The spin configuration in <code>sys</code> should ideally be relaxed into thermal equilibrium, but the current, energy-minimized configuration will also work reasonably well.</p><pre><code class="language-julia hljs">suggest_timestep(sys, langevin; tol=1e-2)
langevin.dt = 0.027;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Consider dt ‚âà 0.02734 for this spin configuration at tol = 0.01.</code></pre><p>Sample spin configurations using Langevin dynamics. We have carefully selected a temperature of 0.2 eV that is below the ordering temperature, but large enough to that the dynamics can overcome local energy barriers and annihilate defects.</p><pre><code class="language-julia hljs">for _ in 1:10_000
    step!(sys, langevin)
end</code></pre><p>Calling <a href="../library.html#Sunny.suggest_timestep-Union{Tuple{N}, Tuple{System{N}, Union{ImplicitMidpoint, Langevin}}} where N"><code>suggest_timestep</code></a> shows that thermalization has not substantially altered the suggested <code>dt</code>.</p><pre><code class="language-julia hljs">suggest_timestep(sys, langevin; tol=1e-2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Consider dt ‚âà 0.03196 for this spin configuration at tol = 0.01. Current value is dt = 0.027.</code></pre><p>Although thermal fluctuations are present, the correct antiferromagnetic order (2 up, 2 down) has been found.</p><pre><code class="language-julia hljs">plot_spins(sys; color=[s[3] for s in sys.dipoles])</code></pre><img src="04_GSD_FeI2-cb1c5a29.png" alt="Example block output"/><p>For other phases, it can be much harder to find thermal equilibrium, and more complicated sampling procedures may be necessary.</p><h2 id="Calculating-Thermal-Averaged-Correlations-\\langle-S{\\alpha\\beta}(ùê™,œâ)\\rangle"><a class="docs-heading-anchor" href="#Calculating-Thermal-Averaged-Correlations-\\langle-S{\\alpha\\beta}(ùê™,œâ)\\rangle">Calculating Thermal-Averaged Correlations <span>$\langle S^{\alpha\beta}(ùê™,œâ)\rangle$</span></a><a id="Calculating-Thermal-Averaged-Correlations-\\langle-S{\\alpha\\beta}(ùê™,œâ)\\rangle-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-Thermal-Averaged-Correlations-\\langle-S{\\alpha\\beta}(ùê™,œâ)\\rangle" title="Permalink"></a></h2><p>Our aim is to study the classical spin dynamics for states sampled in thermal equilibrium. To minimize finite size effects, and achieve sufficient momentum space resolution, we should significantly enlarge the system volume. The function <a href="../library.html#Sunny.resize_supercell-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>resize_supercell</code></a> takes new dimensions as multiples of the unit cell lattice vectors.</p><pre><code class="language-julia hljs">sys_large = resize_supercell(sys, (16,16,4)) # 16x16x4 copies of the original unit cell
plot_spins(sys_large; color=[s[3] for s in sys_large.dipoles])</code></pre><img src="04_GSD_FeI2-72ef85fb.png" alt="Example block output"/><p>Now we will re-thermalize the system to a configuration just above the ordering temperature. Sunny expects energies in meV by default, so we use <code>meV_per_K</code> to convert from kelvin.</p><pre><code class="language-julia hljs">kT = 3.5 * meV_per_K     # 3.5K ‚âà 0.30 meV
langevin.kT = kT
for _ in 1:10_000
    step!(sys_large, langevin)
end</code></pre><p>With this increase in temperature, the suggested timestep has increased slightly.</p><pre><code class="language-julia hljs">suggest_timestep(sys_large, langevin; tol=1e-2)
langevin.dt = 0.040;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Consider dt ‚âà 0.04039 for this spin configuration at tol = 0.01. Current value is dt = 0.027.</code></pre><p>The next step is to collect correlation data <span>$S^{\alpha\beta}$</span>. This will involve sampling spin configurations from thermal equilibrium, and then integrating <a href="https://arxiv.org/abs/2204.07563">an energy-conserving generalized classical spin dynamics</a> to collect Fourier-space information about normal modes. Quantization of these modes yields the magnons, and the associated dynamical spin-spin correlations can be compared with neutron scattering intensities <span>$S^{\alpha\beta}(q,\omega)$</span>. Because this a real-space calculation, data is only available for discrete <span>$q$</span> modes (the resolution scales like inverse system size).</p><p>The function <a href="../library.html#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N"><code>dynamical_correlations</code></a> creates an object to store sampled correlations. The integration timestep <code>dt</code> used for measuring dynamical correlations can be somewhat larger than that used by the Langevin dynamics. We must also specify <code>nœâ</code> and <code>œâmax</code>, which determine the frequencies over which intensity data will be collected.</p><pre><code class="language-julia hljs">dt = 2*langevin.dt
œâmax = 7.5  # Maximum energy to resolve (meV)
nœâ = 120    # Number of energies to resolve
sc = dynamical_correlations(sys_large; dt, nœâ, œâmax)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr4"><span class="sgr1">SampledCorrelations</span></span> (33.615 MiB)
[<span class="sgr1">S(q,œâ)</span> | nœâ = 120, Œîœâ = 0.0657 | 0 sample]
Lattice: (16, 16, 4)√ó1
6 correlations in SU(3) mode:
‚ïî ‚¨§ ‚¨§ ‚¨§ Sx
‚ïë ‚ãÖ ‚¨§ ‚¨§ Sy
‚ïö ‚ãÖ ‚ãÖ ‚¨§ Sz
</code></pre><p>The function <a href="../library.html#Sunny.add_sample!-Tuple{SampledCorrelations, System}"><code>add_sample!</code></a> will collect data by running a dynamical trajectory starting from the current system configuration.</p><pre><code class="language-julia hljs">add_sample!(sc, sys_large)</code></pre><p>To collect additional data, it is required to re-sample the spin configuration from the thermal distribution. For efficiency, the dynamics should be run long enough that consecutive samples are uncorrelated.</p><pre><code class="language-julia hljs">for _ in 1:2
    for _ in 1:1000               # Enough steps to decorrelate spins
        step!(sys_large, langevin)
    end
    add_sample!(sc, sys_large)
end</code></pre><p>Now, <code>sc</code> has more samples included:</p><pre><code class="language-julia hljs">sc</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr4"><span class="sgr1">SampledCorrelations</span></span> (33.615 MiB)
[<span class="sgr1">S(q,œâ)</span> | nœâ = 120, Œîœâ = 0.0657 | 3 samples]
Lattice: (16, 16, 4)√ó1
6 correlations in SU(3) mode:
‚ïî ‚¨§ ‚¨§ ‚¨§ Sx
‚ïë ‚ãÖ ‚¨§ ‚¨§ Sy
‚ïö ‚ãÖ ‚ãÖ ‚¨§ Sz
</code></pre><h2 id="Computing-Scattering-Intensities"><a class="docs-heading-anchor" href="#Computing-Scattering-Intensities">Computing Scattering Intensities</a><a id="Computing-Scattering-Intensities-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Scattering-Intensities" title="Permalink"></a></h2><p>With the thermally-averaged correlation data <span>$\langle S^{\alpha\beta}(q,\omega)\rangle$</span> in hand, we now need to specify how to extract a scattering intensity from this information. This is done by constructing an <a href="../library.html#Sunny.intensity_formula-Tuple{Function, Any, Any}"><code>intensity_formula</code></a>. By way of example, we will use a formula which computes the trace of the structure factor and applies a classical-to-quantum temperature-dependent rescaling <code>kT</code>.</p><pre><code class="language-julia hljs">formula = intensity_formula(sc, :trace; kT)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr4"><span class="sgr1">Classical Scattering Intensity Formula</span></span>
At discrete scattering modes S = S[ix_q,ix_œâ], use:

  Intensity[ix_q,ix_œâ] =   Intensity[ix_q,ix_œâ] = Tr S
<span class="sgr33">No form factors specified</span>
<span class="sgr32">Temperature corrected (kT = 0.3016066641750812) ‚úì</span>
</code></pre><p>Recall that <span>$\langle S^{\alpha\beta}(q,\omega)\rangle$</span> is only available at certain discrete <span>$q$</span> values, due to the finite lattice size. There are two basic approaches to handling this discreteness. The first approach is to interpolate between the available data using <a href="../library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a>. For example, we can plot single-<span>$q$</span> slices at (0,0,0) and (œÄ,œÄ,œÄ) using this method:</p><pre><code class="language-julia hljs">qs = [[0, 0, 0], [0.5, 0.5, 0.5]]
is = intensities_interpolated(sc, qs, formula; interpolation = :round)

œâs = available_energies(sc)
fig = lines(œâs, is[1,:]; axis=(xlabel=&quot;meV&quot;, ylabel=&quot;Intensity&quot;), label=&quot;(0,0,0)&quot;)
lines!(œâs, is[2,:]; label=&quot;(œÄ,œÄ,œÄ)&quot;)
axislegend()
fig</code></pre><img src="04_GSD_FeI2-6637ecbe.png" alt="Example block output"/><p>The resolution in energy can be improved by increasing <code>nœâ</code>, and the statistical accuracy can be improved by collecting additional samples from the thermal equilibrium.</p><p>For real calculations, one often wants to apply further corrections and more accurate formulas. Here, we apply <a href="../library.html#Sunny.FormFactor-Tuple{String}"><code>FormFactor</code></a> corrections appropriate for <code>Fe2</code> magnetic ions, and a dipole polarization correction <code>:perp</code>.</p><pre><code class="language-julia hljs">formfactors = [FormFactor(&quot;Fe2&quot;; g_lande=3/2)]
new_formula = intensity_formula(sc, :perp; kT, formfactors = formfactors)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr4"><span class="sgr1">Classical Scattering Intensity Formula</span></span>
At discrete scattering modes S = S[ix_q,ix_œâ], use:

  Intensity[ix_q,ix_œâ] =   Intensity[ix_q,ix_œâ] = ‚àë_ij (I - Q‚äóQ){i,j} S{i,j}
                         
                         (i,j = Sx,Sy,Sz)
<span class="sgr32">Form factors included in S ‚úì</span>
<span class="sgr32">Temperature corrected (kT = 0.3016066641750812) ‚úì</span>
</code></pre><p>Frequently, one wants to extract energy intensities along lines that connect special wave vectors‚Äìa so-called &quot;spaghetti plot&quot;. The function <a href="../library.html#Sunny.reciprocal_space_path-Tuple{Crystal, Any, Any}"><code>reciprocal_space_path</code></a> creates an appropriate horizontal axis for this plot by linearly sampling between provided <span>$q$</span>-points with a given sample density. The number of sample points between two wavevectors <code>q1</code> and <code>q2</code> is given by <code>dist*density</code> where <code>dist = norm(cryst.recipvecs * (q1 - q2))</code> is measured in the global frame.</p><pre><code class="language-julia hljs">points = [[0,   0, 0],  # List of wave vectors that define a path
          [1,   0, 0],
          [0,   1, 0],
          [1/2, 0, 0],
          [0,   1, 0],
          [0,   0, 0]]
density = 40
path, xticks = reciprocal_space_path(cryst, points, density);</code></pre><p>Again using <a href="../library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a>, we can evaluate the (interpolated) intensity at each point on the <code>path</code>. Since scattering intensities are only available at a certain discrete <span>$(Q,\omega)$</span> points, the intensity on the path can be calculated by interpolating between these discrete points:</p><pre><code class="language-julia hljs">is_interpolated = intensities_interpolated(sc, path, new_formula;
    interpolation = :linear,       # Interpolate between available wave vectors
);
# Add artificial broadening
is_interpolated_broadened = broaden_energy(sc, is, (œâ, œâ‚ÇÄ) -&gt; lorentzian(fwhm=0.1)(œâ-œâ‚ÇÄ));</code></pre><p>The second approach to handle the discreteness of the data is to bin the intensity at the discrete points into the bins of a histogram. First, the five sub-histograms are set up using <a href="../library.html#Sunny.reciprocal_space_path_bins-Tuple{Any, Any, Any, Vararg{Any}}"><code>reciprocal_space_path_bins</code></a> in analogy to <code>reciprocal_space_path</code>.</p><pre><code class="language-julia hljs">cut_width = 0.3
density = 15
paramsList, markers, ranges = reciprocal_space_path_bins(sc,points,density,cut_width);</code></pre><p>Then, the intensity data is computed using <a href="../library.html#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}"><code>intensities_binned</code></a> for each sub-histogram:</p><pre><code class="language-julia hljs">total_bins = ranges[end][end]
energy_bins = paramsList[1].numbins[4]
is_binned = zeros(Float64,total_bins,energy_bins)
integrated_kernel = integrated_lorentzian(fwhm=0.1) # Lorentzian broadening
for k in eachindex(paramsList)
    bin_data, counts = intensities_binned(sc,paramsList[k], new_formula;
        integrated_kernel = integrated_kernel
    )
    is_binned[ranges[k],:] = bin_data[:,1,1,:] ./ counts[:,1,1,:]
end</code></pre><p>The graph produced by interpolating (top) is similar to the one produced by binning (bottom):</p><pre><code class="language-julia hljs">fig = Figure()
ax_top = Axis(fig[1,1],ylabel = &quot;meV&quot;,xticklabelrotation=œÄ/8,xticklabelsize=12;xticks)
ax_bottom = Axis(fig[2,1],ylabel = &quot;meV&quot;,xticks = (markers, string.(points)),xticklabelrotation=œÄ/8,xticklabelsize=12)

heatmap!(ax_top,1:size(is_interpolated,1), œâs, is_interpolated;
    colorrange=(0.0,0.07),
)

heatmap!(ax_bottom,1:size(is_binned,1), œâs, is_binned;
    colorrange=(0.0,0.05),
)

fig</code></pre><img src="04_GSD_FeI2-3012bb5b.png" alt="Example block output"/><p>Note that we have clipped the colors in order to make the higher-energy excitations more visible.</p><h1 id="Unconventional-RLU-Systems-and-Constant-Energy-Cuts"><a class="docs-heading-anchor" href="#Unconventional-RLU-Systems-and-Constant-Energy-Cuts">Unconventional RLU Systems and Constant Energy Cuts</a><a id="Unconventional-RLU-Systems-and-Constant-Energy-Cuts-1"></a><a class="docs-heading-anchor-permalink" href="#Unconventional-RLU-Systems-and-Constant-Energy-Cuts" title="Permalink"></a></h1><p>Often it is useful to plot cuts across multiple wave vectors but at a single energy. We&#39;ll pick an energy,</p><pre><code class="language-julia hljs">œâidx = 60
target_œâ = œâs[œâidx]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3.8776980452258947</code></pre><p>and take a constant-energy cut at that energy. The most straightforward way is to make a plot whose axes are aligned with the conventional reciprocal lattice of the crystal. This is accomplished using <a href="../library.html#Sunny.unit_resolution_binning_parameters-Tuple{Any, Any, Vararg{Any}}"><code>unit_resolution_binning_parameters</code></a>:</p><pre><code class="language-julia hljs">params = unit_resolution_binning_parameters(sc)
params.binstart[1:2] .= -1 # Expand plot range slightly

# Set energy integration range
omega_width = 0.3
params.binstart[4] = target_œâ - (omega_width/2)
params.binend[4] = target_œâ # `binend` should be inside (e.g. at the center) of the range
params.binwidth[4] = omega_width

integrate_axes!(params, axes = 3) # Integrate out z direction entirely

params</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr4"><span class="sgr1">Binning Parameters</span></span>
<span class="sgr1">‚ä°    31 bins</span> from -1.000 to +0.969 along [+1.00 dx] (Œî = 0.064)
<span class="sgr1">‚ä°    31 bins</span> from -1.000 to +0.969 along [+1.00 dy] (Œî = 0.064)
<span class="sgr1">‚à´ Integrated</span> from -0.125 to +1.625 along [+1.00 dz] (Œî = 1.750)
<span class="sgr1">‚à´ Integrated</span> from +3.728 to +4.028 along [+1.00 dE] (Œî = 0.300)
</code></pre><p>In each of the following plots, black dashed lines represent (direct) lattice vectors. Since these plots are in reciprocal space, direct lattice vectors are represented as covectors (i.e. coordinate grids) instead of as arrows.</p><pre><code class="language-julia hljs">is, counts = intensities_binned(sc,params,new_formula)

fig = Figure()
ax = Axis(fig[1,1];
    title=&quot;Œîœâ=0.3 meV (Binned)&quot;, aspect=true,
    xlabel = &quot;[H, 0, 0]&quot;,
    ylabel = &quot;[0, K, 0]&quot;
)
bcs = axes_bincenters(params)
hm = heatmap!(ax,bcs[1],bcs[2],is[:,:,1,1] ./ counts[:,:,1,1])
add_lines!(ax,params)
Colorbar(fig[1,2], hm);
fig</code></pre><img src="04_GSD_FeI2-ff3d3be4.png" alt="Example block output"/><p>In the above plot, the dashed-line (direct) lattice vectors are clearly orthogonal. However, we know that in real space, the lattice vectors <span>$a$</span> and <span>$b$</span> are <em>not</em> orthogonal, but rather point along the edges of a hexagon (see lower left corner):</p><br><img src="https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/FeI2_crystal.jpg" width="400"><br><p>Thus, plotting the direct lattice vectors as orthogonal (even in reciprocal space) is somewhat misleading. Worse yet, the <code>[H,0,0]</code> by <code>[0,K,0]</code> plot apparently loses the 6-fold symmetry of the crystal! Lastly, if one works out the components of the real-space metric with respect to the axes of the plot, one finds that there are non-zero off-diagonal entries,</p><pre><code class="language-julia hljs">latvecs = sys.crystal.latvecs
metric = latvecs&#39; * I(3) * latvecs</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3√ó3 Matrix{Float64}:
 16.4035   -8.20174   0.0
 -8.20174  16.4035    0.0
  0.0       0.0      45.5914</code></pre><p>so real-space rotations and angles map into reciprocal space rotations angles in a complicated way.</p><p>To resolve these important issues, we want to use axes which are orthogonal (i.e. they diagonalize the metric and solve all of the problems just mentioned). The canonical choice is to use the combination <span>$\frac{1}{2}a + b$</span> of lattice vectors (equiv. <span>$a^* - \frac{1}{2}b^*$</span>), which is orthogonal to <span>$a$</span>:</p><pre><code class="language-julia hljs">(latvecs * [1/2,1,0]) ‚ãÖ (latvecs * [1,0,0]) == 0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>This new vector <span>$\frac{1}{2}a+b$</span> is visibly orthogonal to <span>$a$</span> in real space:</p><img src="04_GSD_FeI2-10a69360.png" alt="Example block output"/><p>To use &quot;projection onto the new vector&quot; as a histogram axis, only a single change is needed to the binning parameters. The second covector (previously <span>$b$</span>) must be swapped out for <span>$\frac{1}{2}a + b$</span> (recall that reciprocal space covectors, such as those used in <a href="../library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> correspond to direct space vectors).</p><pre><code class="language-julia hljs">params.covectors[2,1:3] = [1/2,1,0] # [1/2,1,0] times [a;b;c] is (a/2 + b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr4"><span class="sgr1">Binning Parameters</span></span>
<span class="sgr1">‚ä°    31 bins</span> from -1.000 to +0.969 along [+1.00 dx] (Œî = 0.064)
<span class="sgr1">‚ä°    31 bins</span> from -1.000 to +0.969 along [+0.50 dx +1.00 dy] (Œî = 0.057)
<span class="sgr1">‚à´ Integrated</span> from -0.125 to +1.625 along [+1.00 dz] (Œî = 1.750)
<span class="sgr1">‚à´ Integrated</span> from +3.728 to +4.028 along [+1.00 dE] (Œî = 0.300)
</code></pre><p>The second axis of the histogram now agrees with what is conventionally labelled as <code>[H,-H/2,0]</code>.</p><div class="admonition is-warning"><header class="admonition-header">Length of the new vector</header><div class="admonition-body"><p>Note that, although <span>$\frac{1}{2}a+b$</span> is orthogonal to <span>$a$</span>, it is not the same length as <span>$a$</span>. Instead, it is <code>sqrt(3/4)</code> times as long. Note the unsymmetrical axes labels in the plots that follow as a direct result of this!</p></div></div><pre><code class="language-julia hljs"># Zoom out horizontal axis
params.binstart[1], params.binend[1] = -2, 2

# Adjust vertical axis bounds to account for
# length of a/2 + b
params.binstart[2], params.binend[2] = -2 * sqrt(3/4), 2 * sqrt(3/4)

# Re-compute in the new coordinate system
is, counts = intensities_binned(sc,params,new_formula)

add_lines!(ax_right,params)</code></pre><p>For comparison purposes, we will make the same plot using <a href="../library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a> to emulate zero-width bins. This time, it&#39;s more convenient to think in terms of reciprocal vectors <span>$a^*$</span> and <span>$b^*$</span>. Now, our coordinate transformation consists of establishing a new, orthogonal basis to specify our wave vectors: <span>$a^* - \frac{1}{2}b^*$</span>, <span>$b^*$</span> and <span>$c^*$</span>. Writing this in matrix form allows us to sample a rectilinear grid of wave vectors in this frame. Finally, we&#39;ll convert these back into the original RLU system for input into Sunny.</p><pre><code class="language-julia hljs"># New basis matrix
A = [1    0 0
     -1/2 1 0
     0    0 1]

# Define our grid of wave vectors
npoints = 60
as = range(-2, 2, npoints)
bs = range(-3/‚àö3, 3/‚àö3, npoints)
qs_ortho = [[a, b, 0] for a in as, b in bs]

# Convert to original RLU system for input to Sunny
qs = [A * q for q in qs_ortho]

# Use interpolation to get intensities
is = intensities_interpolated(sc, qs, new_formula; interpolation=:linear)

add_lines!(ax_left,params)
fig</code></pre><img src="04_GSD_FeI2-4bf6d5f3.png" alt="Example block output"/><p>Now, not only are the dashed-line lattice vectors no longer misleadingly orthogonal, but the six-fold symmetry has been restored as well! Further, the metric has been diagonalized:</p><pre><code class="language-julia hljs">metric = (latvecs * inv(A&#39;))&#39; * I(3) * (latvecs * inv(A&#39;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3√ó3 Matrix{Float64}:
 16.4035   0.0      0.0
  0.0     12.3026   0.0
  0.0      0.0     45.5914</code></pre><p>Finally, we note that instantaneous structure factor data, <span>$ùíÆ(ùê™)$</span>, can be obtained from a dynamic structure factor with <a href="../library.html#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}"><code>instant_intensities_interpolated</code></a>. Here we&#39;ll reuse the grid of wave vectors we generated above.</p><pre><code class="language-julia hljs">is_static = instant_intensities_interpolated(sc, qs, new_formula; interpolation = :linear)

hm = heatmap(as, bs, is_static;
    axis=(
        title=&quot;Instantaneous Structure Factor&quot;,
        xlabel = &quot;[H, -1/2H, 0]&quot;,
        ylabel = &quot;[0, K, 0]&quot;,
        aspect=true
    )
)
Colorbar(hm.figure[1,2], hm.plot)
hm</code></pre><img src="04_GSD_FeI2-de686880.png" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="03_LLD_CoRh2O4.html">¬´ 3. Landau-Lifshitz dynamics of CoRh‚ÇÇO‚ÇÑ at finite <em>T</em></a><a class="docs-footer-nextpage" href="05_MC_Ising.html">5. Monte Carlo sampling of the Ising model ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 3 June 2024 04:03">Monday 3 June 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
